//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.17 build 40517.1100)
// Copyright (C) 1995-2004 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl; 

import ims.admin.domain.GPAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.GPAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ElectiveListStatusReason;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.domain.objects.DeathDetails;
import ims.core.clinical.domain.objects.PatientNoAlertInfo;
import ims.core.domain.Alerts;
import ims.core.helper.DTOHelper;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.CaseNoteFolderVo;
import ims.core.vo.CommChannelVoCollection;
import ims.core.vo.DeathDetailsVo;
import ims.core.vo.DeathDetailsVoCollection;
import ims.core.vo.GP;
import ims.core.vo.GpLiteToPracticeLiteVo;
import ims.core.vo.GpPracticeLiteVo;
import ims.core.vo.GpShortVo;
import ims.core.vo.GpToPracticesVo;
import ims.core.vo.GpToPracticesVoCollection;
import ims.core.vo.InsuranceVo;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocSiteShortVoCollection;
import ims.core.vo.LocSiteVo;
import ims.core.vo.LocSiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.NextOfKin;
import ims.core.vo.OrganisationVo;
import ims.core.vo.OrganisationWithSitesVo;
import ims.core.vo.Patient;
import ims.core.vo.PatientId;
import ims.core.vo.PatientIdCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.PersonAddress;
import ims.core.vo.PersonAddressCollection;
import ims.core.vo.PersonName;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.TaxonomyMapCollection;
import ims.core.vo.domain.DeathDetailsVoAssembler;
import ims.core.vo.domain.GPAssembler;
import ims.core.vo.domain.LocSiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.OrganisationWithSitesVoAssembler;
import ims.core.vo.domain.PatientAssembler;
import ims.core.vo.domain.PatientIdAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.AddressType;
import ims.core.vo.lookups.ChannelType;
import ims.core.vo.lookups.EthnicOrigin;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MRNStatus;
import ims.core.vo.lookups.MaritalStatus;
import ims.core.vo.lookups.NameType;
import ims.core.vo.lookups.Occupation;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PatientAlertStatus;
import ims.core.vo.lookups.PersonHealthActCategory;
import ims.core.vo.lookups.PersonRelationship;
import ims.core.vo.lookups.PersonTitle;
import ims.core.vo.lookups.Religion;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.ResultException;
import ims.dto.client.Alias;
import ims.dto.client.Alias.AliasRecord;
import ims.dto.client.Demographics;
import ims.dto.client.Demographics.DemographicsRecord;
import ims.dto.client.Gp_practice;
import ims.dto.client.Gp_practice.Gp_practiceRecord;
import ims.dto.client.Hadd;
import ims.dto.client.Hadd.HaddRecord;
import ims.dto.client.Sd_appt;
import ims.dto.client.Sd_appt.Sd_apptAppt_idRecord;
import ims.dto.client.Sd_appt.Sd_apptRecord;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.PartialDate;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientJourneyStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.JourneyStatus;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.vo.Appointment_StatusVo;
import ims.scheduling.vo.Appointment_StatusVoCollection;
import ims.scheduling.vo.BookingAppointmentLiteVo;
import ims.scheduling.vo.BookingAppointmentLiteVoCollection;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.Booking_AppointmentVoCollection;
import ims.scheduling.vo.domain.BookingAppointmentLiteVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;

import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

public class DemographicsImpl extends DTODomainImplementation implements ims.core.domain.Demographics, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;
	private static final int RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE = 36;

	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}

	/**
	 * Get's a specific Patient
	 * @throws  
	 * @throws UniqueKeyViolationException 
	 */
	public ims.core.vo.Patient getPatient(PatientShort patient) throws StaleObjectException
	{
		if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("LOCAL"))
			return getLocalPatient(patient);
		else if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("DTO"))
		{
			try
			{
				return getDTOPatient(patient);
			}
			catch (UniqueKeyViolationException e)
			{
				throw new DomainRuntimeException(e);
			}
		}

		return null;
	}

	private Patient getDTOPatient(PatientShort patient) throws StaleObjectException, UniqueKeyViolationException
	{
		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();
		
		Demographics patRec = (Demographics) getDTOInstance(Demographics.class);
		patRec.Filter.clear();
		PatientId intfId = patient.getInterfaceId();
		if (intfId == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid interface identifier");
		}

		//WDEV-10116
		if (intfId.getType().equals(PatIdType.PKEY))
		{
			patRec.Filter.Pkey = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.HOSPNUM))
		{
			patRec.Filter.Hospnum = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.NHSN))
		{
			patRec.Filter.Nhsn = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.CHARTNUM))
		{
			patRec.Filter.Chartnum = intfId.getIdValue();
		}
		else
		{
			throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
		}

		Result result = patRec.get();
		if (result != null)
		{
			String errMsg = intfId.getType().getText();
			
			if(errMsg != null)
				errMsg = "Error getting patient details for patient (" + errMsg + "=" + intfId.getValue() + ")." + "\nError - " + result.getMessage();
			else
				errMsg = "Error -" + result.getMessage();
			
			throw new DomainRuntimeException(errMsg);
		}

		DemographicsRecord dtop = patRec.DataCollection.get(0);
		// Check if this patient is in the local database
		// this will setup all the required ids
		ims.core.vo.Patient voPatient = new Patient();
		voPatient.setIdentifiers(new PatientIdCollection());
		voPatient.getIdentifiers().add(intfId);
		voPatient = getLocalPatient(voPatient);

		if (voPatient == null)
		{
			voPatient = new ims.core.vo.Patient();
		}
		if (voPatient.getIdentifiers() == null)
		{
			voPatient.setIdentifiers(new PatientIdCollection());
		}
		// wdev-8564 - set NHSN to verified if CSTA has a value of 1
		if (dtop.Csta != null && dtop.Csta.equals("1"))
			voPatient.addId(PatIdType.NHSN, dtop.Nhsn, true);
		else
			voPatient.addId(PatIdType.NHSN, dtop.Nhsn);
		voPatient.addId(PatIdType.PKEY, dtop.Pkey);
		voPatient.addId(PatIdType.HOSPNUM, dtop.Hospnum);
		voPatient.addId(PatIdType.PPSN, dtop.Ppsn);
		voPatient.addId(PatIdType.CHARTNUM, dtop.Chartnum);

		voPatient.setName(dtop.Snm, dtop.Fnm1, dtop.Fnm2);
		
		// wdev-12961 - Not sure why this line was in code since early 2009 and before.....removed. 
		//voPatient.setName(dtop.Snm, dtop.Fnm1, null);
		
		// Set Maiden Name
		if (dtop.Snmb != null && dtop.Snmb.length() >= 1)
			voPatient.setMaidenName(dtop.Snmb, dtop.Fnm1);
		else
			voPatient.setMaidenName(null);

		// sex
		voPatient.setSex((Sex) getLookupService().getLocalLookup(Sex.class, Sex.TYPE_ID, extSystem, dtop.Sex));

		// dob dod
		try
		{
			if (dtop.Dob != null && dtop.Dob.length() >= 4)
			{
				voPatient.setDob(new PartialDate(dtop.Dob));
			}
			if (dtop.Dod != null && dtop.Dod.length() == 8)
				voPatient.setDod(new Date(dtop.Dod, DateFormat.ISO));
			else
				voPatient.setDod(null);
		}
		catch (ParseException pe)
		{
		}

		// age
		voPatient.calculateAge();

		// address
		PersonAddress pa = voPatient.getAddress();
		if (pa == null)
			pa = new PersonAddress();
		pa.setLine1(dtop.Adr1);
		pa.setLine2(dtop.Adr2);
		pa.setLine3(dtop.Adr3);
		pa.setLine4(dtop.Adr4);
		pa.setLine5(null);
		pa.setPhone(dtop.Ntel);
		pa.setPostCode(dtop.Post);
		pa.setAddressType(AddressType.PERMANENT);
		
		voPatient.setAddress(pa);

		// Communication Channels - Work Phone
		if (voPatient.getCommChannels() == null)
		{
			voPatient.setCommChannels(new CommChannelVoCollection());
		}
		voPatient.addCommunicationChannel(ChannelType.WORK_PHONE, dtop.Dtel);		
		
		// Ward
		OrganisationAndLocation locImpl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		voPatient.setWard(locImpl.getLocationByLocalCode(dtop.Ploc, LocationType.WARD));
		
		// WDEV-17867 - Copy Current Responsible Consultant from Patient parameter record
		if (patient != null)
		{
			voPatient.setCurrentResponsibleConsultant(patient.getCurrentResponsibleConsultant());
		}

		// title
		if (dtop.Titl == null || dtop.Titl.length() <= 0)
		{
			// Used for Irish Pas - Title is not a coded item - PAS outputs the text for patient's Title
			dtop.Titl = dtop.Titltxt;
		}
		voPatient.getName().setTitle((PersonTitle) getLookupService().getLocalLookup(PersonTitle.class, PersonTitle.TYPE_ID, extSystem, dtop.Titl));

		// Marital Status
		voPatient.setMaritalStatus((MaritalStatus) getLookupService().getLocalLookup(MaritalStatus.class, MaritalStatus.TYPE_ID, extSystem, dtop.Mart));

		// Occupation
		voPatient.setOccupation((Occupation) getLookupService().getLocalLookup(Occupation.class, Occupation.TYPE_ID, extSystem, dtop.Poccdesc));

		// Religion
		voPatient.setReligion((Religion) getLookupService().getLocalLookup(Religion.class, Religion.TYPE_ID, extSystem, dtop.Relg));

		// EthnicOrigin
		voPatient.setEthnicOrigin((EthnicOrigin) getLookupService().getLocalLookup(EthnicOrigin.class, EthnicOrigin.TYPE_ID, extSystem, dtop.Ethc));

		// NOK
		NextOfKin nok = voPatient.getNok();
		//WDEV-12974 Name no longer mandatory so if any nok field has a value proceed
		if ((dtop.Name != null && dtop.Name.length() > 0) || (dtop.Nadr1 != null && dtop.Nadr1.length() > 0)
				|| (dtop.Nadr2 != null && dtop.Nadr2.length() > 0) || (dtop.Nadr3 != null && dtop.Nadr3.length() > 0)
				|| (dtop.Nadr4 != null && dtop.Nadr4.length() > 0) || (dtop.Nntel != null && dtop.Nntel.length() > 0)
				|| (dtop.Nkmobile != null && dtop.Nkmobile.length() > 0))
		{
			if (nok == null)
				nok = new NextOfKin();
			// name
			PersonName name = nok.getName();
			if (name == null)
			{
				name = new PersonName();
				nok.setName(name);
			}

			name.setSurname(dtop.Name);		
			// Address
			PersonAddress noka = nok.getAddress();
			if (noka == null)
			{
				noka = new PersonAddress();
				nok.setAddress(noka);
			}
			noka.setLine1(dtop.Nadr1);
			noka.setLine2(dtop.Nadr2);
			noka.setLine3(dtop.Nadr3);
			noka.setLine4(dtop.Nadr4);
			noka.setPhone(dtop.Nntel);
			
			noka.setAddressType(AddressType.NOKHOME);

			
			// Communication Channels - Work Phone and Mobile
			if (nok.getCommChannels() == null)
			{
				nok.setCommChannels(new CommChannelVoCollection());
			}
			nok.addCommunicationChannel(ChannelType.WORK_PHONE, dtop.Ndtel);		
			nok.addCommunicationChannel(ChannelType.MOBILE, dtop.Nkmobile);
		

			// Relationship
			if (dtop.Rel == null || dtop.Rel.length() <= 0)
			{
				// Used for Irish Pas - Relationship not a coded item - PAS outputs the text for NOK Relationship
				dtop.Rel = dtop.Kinreldesc;
			}
			nok.setRelationship((PersonRelationship) getLookupService().getLocalLookup(PersonRelationship.class, PersonRelationship.TYPE_ID, extSystem, dtop.Rel));
			voPatient.setNok(nok);
		}
		else
			voPatient.setNok(null);

		InsuranceVo insurance;
		if ((insurance = voPatient.getInsurance()) == null)
		{
			insurance = new InsuranceVo();
			voPatient.setInsurance(insurance);
		}
		insurance.setHealthActCategory((PersonHealthActCategory) getLookupService().getLocalLookup(PersonHealthActCategory.class, PersonHealthActCategory.TYPE_ID, extSystem, dtop.Healthcat));
		insurance.setMedicalCardNo(dtop.Medcardno);
		// wdev-7328 - null values in insurance are causing unnecessary patient updates
		// check value now, and if not set, clear the insurance for the patient
		if (insurance.getHealthActCategory() == null && (insurance.getMedicalCardNo() == null || insurance.getMedicalCardNo().equals("")))
			voPatient.setInsurance(null);

		if ((dtop.Gpcd!= null) && (dtop.Gpcd.length() > 0 &&  !dtop.Gpcd.equals("0")))
		{
			GPAdmin gpAdmin = (GPAdmin) getDomainImpl(GPAdminImpl.class);
			GP gp = gpAdmin.getGPByTaxonomyType(dtop.Gpcd, TaxonomyType.PAS);
			voPatient.setGp(gp);
			
			if (gp != null &&
					gp.getPracticesIsNotNull() && gp.getPractices().size() > 0)
			{
				if (gp.getPractices().get(0) != null)
				{
					OrganisationWithSitesVo gpPracticeVo = gp.getPractices().get(0).getPractice();
					if (gpPracticeVo != null && gpPracticeVo.getLocationSitesIsNotNull() && gpPracticeVo.getLocationSites().size() > 0)
					{
						LocSiteVo locSiteVo = gpPracticeVo.getLocationSites().get(0);
						LocSiteShortVo surgeryVo = new LocSiteShortVo(locSiteVo.getBoId(), locSiteVo.getBoVersion());
						surgeryVo.setAddress(locSiteVo.getAddress());
						surgeryVo.setAllSecureAccommodation(locSiteVo.getAllSecureAccommodation());
						surgeryVo.setCodeMappings(locSiteVo.getCodeMappings());
						surgeryVo.setIsActive(locSiteVo.getIsActive());
						surgeryVo.setIsVirtual(locSiteVo.getIsVirtual());
						surgeryVo.setIsRIE(locSiteVo.getIsRIE());
						surgeryVo.setName(locSiteVo.getName());
						surgeryVo.setReferringHospital(locSiteVo.getReferringHospital());
						surgeryVo.setSecureAccommodation(locSiteVo.getSecureAccommodation());
						surgeryVo.setTreatingHosp(locSiteVo.getTreatingHosp());
						surgeryVo.setType(locSiteVo.getType());
						voPatient.setGpSurgery(surgeryVo);
						
					}
					
				}
			}
		}
		
		// Convert the Value object to a business object and save to the local database
		try
		{
			voPatient = replicatePatient(voPatient);
		}
		catch (DomainInterfaceException e)
		{
			throw new DomainRuntimeException("replicate Patient failed " + e.getMessage());
		}
		
		// Set Allergies & Allerts
		voPatient.setHasAlerts(hasAlerts(voPatient.getID_Patient()));
		voPatient.setHasAllergies(hasAllergy(voPatient.getID_Patient()));

		if (voPatient.getIdentifiers() != null)
			voPatient.getIdentifiers().sort();
		if (voPatient.getCommChannels() != null)
			voPatient.getCommChannels().sort();
		
		return (voPatient);
	}
	
	//http://jira/browse/WDEV-12850
	private ims.core.patient.domain.objects.Patient getDomPatient(PatientShort patVo)
	{
		return getDomPatient(patVo,true);
	}
	
	private ims.core.patient.domain.objects.Patient getDomPatient(PatientShort patVo,boolean includeVerified)	
	{
		DomainFactory factory = getDomainFactory();

		if (patVo.getID_PatientIsNotNull())
		{
			return (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		}

		if (patVo.getIdentifiers() == null || patVo.getIdentifiers().size() == 0 || (patVo.getIdentifiers().get(0)) == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid identifier");
		}	
		ims.core.patient.domain.objects.Patient domPatient=null;
		int i=0;
		PatientId intfId = null;
	
		while (domPatient == null)
		{
			intfId = patVo.getIdentifiers().get(i);

			if (intfId.getIdValue() != null)
			{
				String idVal = intfId.getIdValue().trim();
				//wdev-9584 add verified as a field to check 
				//http://jira/browse/WDEV-12850
				String hql = "";

				if(includeVerified)
				{
					Boolean isVerified = intfId.getVerified()==null?Boolean.valueOf(false):intfId.getVerified();
					//if isVerified value being supplied to query is false - return false and null records
					if(!isVerified)
						hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue and ( ids.verified = False or ids.verified is null) ";		
					else
						//return only records with true
						hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue and ids.verified = True ";
				}
				else
				{
					hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue ";
				}
				java.util.List patientList = factory.find(hql, new String[]{"idValue", "idType"}, new Object[]{idVal, getDomLookup(intfId.getType())});
				if (patientList != null && !patientList.isEmpty())
				{
					// 	Patient Should be unique per id value and type
					if (patientList.size() > 1)
					{
						throw new DomainRuntimeException("More than one patient found with identifier type = " + intfId.getType() + " and value = " + idVal);
					}
					domPatient = (ims.core.patient.domain.objects.Patient) patientList.get(0);
				}
			}
			i++;
			if (i >= patVo.getIdentifiers().size())
				break;
		}
		
		return domPatient;
	}

	public Patient getPatient(PatientRefVo patRef)
	{
		if (patRef != null && patRef.getID_PatientIsNotNull())
		{
			DomainFactory factory = getDomainFactory();
			ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patRef.getID_Patient().intValue());
			if (patBo == null) 
				return null;
			
			return getLocalPatient(patBo);
		}
		return null;
	}
	
	public Patient getLocalPatient(PatientShort patient)
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient);
		return getLocalPatient(domPatient);
	}

	protected Patient getLocalPatient(ims.core.patient.domain.objects.Patient domPatient)
	{
		if (domPatient == null) 
			return null;

		//recurse to get master patient if this patient was merged
		ims.core.patient.domain.objects.Patient foundPatient = domPatient;
		boolean isMergedPatient = false;
		while(domPatient.getAssociatedPatient() != null)
		{
			domPatient = domPatient.getAssociatedPatient();
			isMergedPatient = true;
		}
			
		if(isMergedPatient)
			raiseAlert(domPatient.getMergedMessage(foundPatient));
		
		Patient voPatient = PatientAssembler.create(domPatient);
		if (voPatient != null && voPatient.getAge() == null)   //wdev-14325
			voPatient.calculateAge();
		
		if (voPatient != null && voPatient.getCommChannels() != null)	//wdev-14325
			voPatient.getCommChannels().sort();
		
		// Set Allergies & Allerts
		if(voPatient != null) //wdev-14325
		{
			voPatient.setHasAlerts(hasAlerts(domPatient.getId()));
			voPatient.setHasAllergies(hasAllergy(domPatient.getId()));
		}

		
		return voPatient;
	}

	private ims.core.vo.Patient replicatePatient(ims.core.vo.Patient voPatient) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		voPatient.getName().setUppers();
		if (voPatient.getIsActive() == null)
			voPatient.setIsActive(Boolean.TRUE);

		voPatient.getName().setUppers();
		if (voPatient.getOtherNames() != null)
		{
			for (int i = 0; i < voPatient.getOtherNames().size(); i++)
			{
				voPatient.getOtherNames().get(i).setUppers();
			}
		}
		if (voPatient.getIdentifiers() != null)
		{
			for (int i = 0; i < voPatient.getIdentifiers().size(); i++)
			{
				PatientId patId = voPatient.getIdentifiers().get(i);
				//WDEV-10116
				String val = patId.getIdValue().trim();
				if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
				{
					val = val.toUpperCase();
				}
				patId.setValue(val);
			}			
		}
		if (voPatient.getIsActive() == null)
			voPatient.setIsActive(Boolean.TRUE);

		// WDEV-6633 - call this method as it handles duplicate NHS numbers
		return savePatientRecord(getDomainFactory(), voPatient, 0, false, true);
	}

	public Boolean hasAlerts(Integer patientID)
	{
		if (patientID == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory(); 
		//WDEV-3160  - filter lists if the patient has any alerts, active or inactive, but not if recorded in error.
		//WDEV-11040 is now superceding above WDEV-3160 and including active in teh search criteria
		String filter = "select count (alert.id) from PatientAlert as alert where ( alert.isRIE = false or alert.isRIE is null ) and alert.isCurrentlyActiveAlert = true and alert.patient.id = :idPatient"; 
		List alerts = factory.find(filter, new String[]{"idPatient"}, new Object[]{patientID}); 
		int count = 0;
		if(alerts.size() > 0)
		{
			if(alerts.get(0) instanceof Integer)
				count = ((Integer)alerts.get(0)).intValue();
			else
				count = ((Long)alerts.get(0)).intValue();
		}
		
		return Boolean.valueOf(count > 0);
	}

	public Boolean hasAllergy(Integer patientID)
	{
		if (patientID == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory();

		String filter = "select count (allergy.id) from PatientAllergy as allergy where ( allergy.isRIE = false or allergy.isRIE is null ) and allergy.isCurrentlyActiveAllergy = true and allergy.patient.id = :idPatient";
		List allergys = factory.find(filter, new String[]{"idPatient"}, new Object[]{patientID});
		int count = 0;
		if(allergys.size() > 0)
		{
			if(allergys.get(0) instanceof Integer)
				count = ((Integer)allergys.get(0)).intValue();
			else
				count = ((Long)allergys.get(0)).intValue();
		}
		
		return Boolean.valueOf(count > 0);
	}
	
	public GP getPatientGp(GpShortVo gp)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.resource.people.domain.objects.Gp doGp = (ims.core.resource.people.domain.objects.Gp) factory.getDomainObject(ims.core.resource.people.domain.objects.Gp.class, gp.getID_Gp());
		return GPAssembler.create(doGp);
	}

	private static final String createPatientNumber(int patNum)
	{
		if (!ConfigFlag.DOM.USE_PATIENT_NUMBER.getValue())
		{
			return null;
		}
		else
		{
			try
			{
				String patNumPrefix=ConfigFlag.DOM.PATIENT_NUMBER_PREFIX.getValue().trim().substring(0,2);
				DecimalFormat numFormatter = new DecimalFormat("00000000");
				return patNumPrefix+numFormatter.format(patNum);

			} catch (IndexOutOfBoundsException ioobe)
			{
				throw new CodingRuntimeException ("PATIENT_NUMBER_PREFIX must be 2 characters");
			}
		}
		
	}

	public Patient savePatient(Patient patient, Boolean fromInterface) throws UniqueKeyViolationException, StaleObjectException, DomainInterfaceException, IndexOutOfBoundsException
	{
		DomainFactory factory = getDomainFactory();
		factory.setDirtyCheck(true);
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		patient.getName().setUppers();
		if (patient.getOtherNames() != null)
		{
			for (int i = 0; i < patient.getOtherNames().size(); i++)
			{
				patient.getOtherNames().get(i).setUppers();
			}
		}
		return this.savePatientRecord(factory, patient, 1, fromInterface);
	}
	
	// wdev-7328 - default is not from dtoCall
	private Patient savePatientRecord(DomainFactory factory, Patient patient, int duplicateCount, boolean fromInterface) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		return savePatientRecord(factory, patient, duplicateCount, fromInterface, false);
	}
	private Patient savePatientRecord(DomainFactory factory, Patient patient, int duplicateCount, boolean fromInterface, boolean fromDtoReplicate) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		if (patient.getIdentifiers() != null && !ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
		{
			for (int i = 0; i < patient.getIdentifiers().size(); i++)
			{
				PatientId patId = patient.getIdentifiers().get(i);
				String val = patId.getIdValue().trim();
				patId.setValue(val.toUpperCase());
			}			
		}
		if (patient.getIsActive() == null)
			patient.setIsActive(Boolean.TRUE);

		// WDEV-14130 For NOK Address, we need to enforce the address type as NOKHOME
		if (patient.getNokIsNotNull() && patient.getNok().getAddressIsNotNull())
			patient.getNok().getAddress().setAddressType(AddressType.NOKHOME);

		boolean bBlankTempAddress = false;
		if(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue() == true && !fromInterface)
		{
			
			if(patient.getAddressesIsNotNull())
			{
				if(patient.getAddresses().size() > 0)
				{
					for (int i = 0 ; i< patient.getAddresses().size() ; i++)
					{
						PersonAddress voTempAddress = patient.getAddresses().get(i);
						
						if (voTempAddress != null //To save a blanked / deleted address need to have an empty object to save in DTO / PAS. Cater for it here.
							&& voTempAddress.getAddressType() == null 
							&& voTempAddress.getLine1() == "")
						{
							bBlankTempAddress = true;
							patient.getAddresses().remove(i);
							break;
						}
					}
				}
			}
		}

		ims.core.patient.domain.objects.Patient domPatient = PatientAssembler.extractPatient(factory, patient);			

		try
		{
			// wdev-9585
			// set the newPatient flag to true if the id is null
			if (domPatient.getId() == null)
			{
				domPatient.setIsNewPatient(true);
			}
			else
				domPatient.setIsNewPatient(false);

			
			// wdev-2034 To force a deletion of re-insertion of identifiers
			// it is necessary to clear the collection and re-set the values.
			
			// wdev-7328 - If the number of items are the same? then don't clear?  don't want
			// constant updates from dto
			if (!fromDtoReplicate || (domPatient.getIdentifiers().size() != patient.getIdentifiers().size()))
			{
				// Check all verified values, if null, default to false
				for (int i=0; i<patient.getIdentifiers().size(); i++)
				{
					PatientId curId = patient.getIdentifiers().get(i);
					if (curId != null && curId.getType().equals(PatIdType.NHSN) && !curId.getVerifiedIsNotNull())
					{
						curId.setVerified(false);
					}
				}
				domPatient.getIdentifiers().clear();
				List lst = PatientIdAssembler.extractPatientIdList(factory, patient.getIdentifiers());
				domPatient.setIdentifiers(lst);
			}

			savePatientToDto(factory, domPatient, patient, fromInterface, fromDtoReplicate, bBlankTempAddress);
			if (ConfigFlag.DOM.USE_PATIENT_NUMBER.getValue())
			{
				if ( domPatient.isIsNewPatient()!=null &&  domPatient.isIsNewPatient().booleanValue()==true && !PatIdType.NHSN.equals(PatIdType.getNegativeInstance(ConfigFlag.GEN.GENERATE_PATID_TYPE.getValue())) )   //wdev-15754
				{	
					String patNum=createPatientNumber(domPatient.getId());
					ims.core.patient.domain.objects.PatientId patNumberId= new ims.core.patient.domain.objects.PatientId();
					patNumberId.setValue(patNum);
					//patNumberId.setType(getDomLookup ( PatIdType.PATNUM));
					patNumberId.setType(getDomLookup ( PatIdType.getNegativeInstance(ConfigFlag.GEN.GENERATE_PATID_TYPE.getValue()))); //wdev-15754
					domPatient.getIdentifiers().add(patNumberId);
					domPatient.setMRNStatus(getDomLookup(MRNStatus.WAITING));
				}
			}
			if (ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
				&& patient.getCancelSD_APPTSIsNotNull()
				&& patient.getCancelSD_APPTS().booleanValue() )
			{
				if (Boolean.TRUE.equals(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue())) 
					cancelSD_APPTS(patient);
				else
					cancelFutureAppointments(patient);
			}
			
			//WDEV-18326
			if (ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() && patient.getID_PatientIsNotNull())
			{
				if (patient.getDod() != null)
					saveRTTStatusForPatientRIP(patient);
				else 
					revertRTTStatus(patient);
			}
			
			//WDEV-18259
			if (patient.getID_Patient() != null && patient.getDod() != null)
				updatePatientElectiveListsForDOD(patient);
			
			domPatient.setSaveComplete(true); // wdev-9585  at last save now

			if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue()
				&& ! ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue()
				&& patient.getSaveAliasIsNotNull())
			{
				boolean bFound = false;
				//save the alias in other names 
				List othNames = domPatient.getOtherNames();
				for (int i = 0 ; i < othNames.size() ; i++)
				{
					ims.core.generic.domain.objects.PersonName doPN = (ims.core.generic.domain.objects.PersonName)othNames.get(i);
					if (doPN.getNameType()!= null && doPN.getNameType().getId() == NameType.ALIAS.getID()) // Wdev-18404
					{
						doPN.setSurname(patient.getSaveAlias());
						doPN.setUpperSurname(patient.getSaveAlias().toUpperCase()); //wdev-18307
						domPatient.getOtherNames().set(i, doPN);
						bFound = true;
					}
				}
				if ( !bFound)
				{
					ims.core.generic.domain.objects.PersonName doPN =  new ims.core.generic.domain.objects.PersonName();
					doPN.setSurname(patient.getSaveAlias());
					doPN.setUpperSurname(patient.getSaveAlias().toUpperCase()); //wdev-18307
					doPN.setNameType(getDomLookup ( NameType.ALIAS));
					domPatient.getOtherNames().add(doPN);
				}
			}
			
			factory.save(domPatient);
			

			if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue()
				&& ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue()
				&& patient.getSaveAliasIsNotNull())
			{
				if (patient.getHospnum() == null)
				{
					Patient savedPatient = PatientAssembler.create(domPatient); // patient is being created in CCO and the hospnum needs to be reteieved, so get patient.
					savedPatient.setSaveAlias(patient.getSaveAlias());
					saveAlias(savedPatient);
				}
				else
					saveAlias(patient);
			}
		}
		catch (UnqViolationUncheckedException e)
		{
			// now we need to figure out which type and id caused the exception
			// go through the collection of identifiers for the patient and try a getpatient for each one
			// for the one that is successful this is then the one that caused the unique constraint violation			
			PatientId voPatId = null;
			for (int i = 0; i < patient.getIdentifiers().size(); i++)
			{
				voPatId = patient.getIdentifiers().get(i);
				PatientIdCollection voCollIds = new PatientIdCollection();
				voCollIds.add(voPatId);
				ims.core.vo.Patient voPatFilter = new ims.core.vo.Patient();
				voPatFilter.setIdentifiers(voCollIds);
				
				// WDEV-11121
				// Catch the DomainRuntimeException thrown by getDomPatient() called by getLocalPatient()
				// At this point we already expect an exception and we want to display a message to the user
				// not crash the application
				try
				{
					if((voPatFilter = getLocalPatient(voPatFilter)) != null)  // wdev-6383
					{	 
						if(!voPatFilter.getID_Patient().equals(domPatient.getId()))  
						{
							// wdev-1276
							// If a flag is set to allow duplicate NHS Numbers, and the
							// duplicity is on the NHS number, then we can go ahead and
							// create one, otherwise, throw back the error
							if (ConfigFlag.GEN.ALLOW_DUPLICATE_NHS_NUMBERS.getValue() && voPatId.getType().equals(PatIdType.NHSN))
							{
								/**
								 * We want to clear the ID for new records as otherwise,
								 * hibernate attempts to do a get using the given id, and
								 * the record may not be there.
								 */
								//if (newPatientClinical)
								//	patient.setID_Patient(null);//WDEV-1015
								String nhsValue = voPatId.getIdValue().trim();

								int pos = nhsValue.indexOf(" (DUP");
								if (pos > 0)
									nhsValue = nhsValue.substring(0, pos);
								voPatId.setValue(nhsValue + " (DUP" + duplicateCount + ")");
								// Try the save again
								return (savePatientRecord(factory, patient, ++duplicateCount, fromInterface));
							}


							throw new UniqueKeyViolationException("A Patient with this " + voPatId.getType().getText() + " already exists", e);
						}
						//wdev-4188 Removed this and it sorted the problem	-> patient.setID_Patient(null); //WDEV-1015

					}
				}
				catch (DomainRuntimeException exception)
				{
					throw new UniqueKeyViolationException(exception.getMessage());
				}
			}
			throw new UniqueKeyViolationException("A Unique Constraint Violation Exception has occurred. Another Patient has this Identifier already.", e);			
		}
		//http://jira/browse/WDEV-17262
		if(patient.getPatientAlertsIsNotNull()&&patient.getPatientAlerts().size()!=0)
		{
			updatePatientNoAlertInfo(patient);
		}
	
		Patient voPatient = PatientAssembler.create(domPatient);		
		return voPatient;
	}

	//WDEV-18413
	private void revertRTTStatus(Patient patient) throws StaleObjectException
	{
		List <?> listofReferralsDO = getCatsReferralsToRevert(patient);
		
		if (listofReferralsDO == null || listofReferralsDO.size() == 0)
		{
			return;
		}
		
		for (int i=0; i<listofReferralsDO.size();i++)
		{
			if (listofReferralsDO.get(i) instanceof CatsReferral)
			{
				revertRTTforCatsReferral((CatsReferral) listofReferralsDO.get(i));
			}	
		}
		
	}
	
	private  List<?> getCatsReferralsToRevert(Patient patient)
	{
		String hql = "select ref from CatsReferral as ref left join ref.patient as pat left join ref.journey as journ left join journ.currentClock as currClock where currClock is not null and pat.id = :patientID";

		DomainFactory factory = getDomainFactory();

		List<?> results = factory.find(hql, new String[]{"patientID"}, new Object[] {patient.getID_Patient()});

		if (results != null && results.size() > 0)
		{
			return results;
		}
		
		return null;
	}

	private void revertRTTforCatsReferral(CatsReferral catsReferral) throws StaleObjectException
	{
		int nationalCode = RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE;

		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() || Boolean.FALSE.equals(catsReferral.isRTTClockImpact()))
			return;	

		if (catsReferral == null || (catsReferral != null && catsReferral.getCurrentRTTStatus() != null && catsReferral.getCurrentRTTStatus().getRTTStatus() != null &&  nationalCode != catsReferral.getCurrentRTTStatus().getRTTStatus().getNationalCode().intValue()))
			return;
		
		DomainFactory factory = getDomainFactory();
		
		if (catsReferral.getJourney() != null && catsReferral.getJourney().getCurrentClock() != null)
		{
			
			PathwayClock currentClock = catsReferral.getJourney().getCurrentClock();
			
			int statusHistorySize = currentClock.getRTTStatusHistory().size();
			
			if (statusHistorySize >= 2)
			{
				//current Status will be the second to last from the status history
				PathwayRTTStatus currentRTTStatus = ((PathwayRTTStatus)currentClock.getRTTStatusHistory().get(statusHistorySize - 2));
				
				currentClock.setCurrentRTTStatus(currentRTTStatus);
				catsReferral.setCurrentRTTStatus(currentRTTStatus);
				
				currentClock.getRTTStatusHistory().remove(statusHistorySize - 1);
			}
			
			factory.save(catsReferral);
		}
	}

	private void saveRTTStatusForPatientRIP(Patient patient) throws StaleObjectException, DomainInterfaceException  //WDEV-18326
	{
		List <?> listofReferralsDO = getCatsReferralsforPatient(patient);

		if (listofReferralsDO == null || listofReferralsDO.size() == 0)
		{
			return;
		}
		for (int i=0; i<listofReferralsDO.size();i++)
		{
			if (listofReferralsDO.get(i) instanceof CatsReferral)
			{
				updateRTTforCatsRef((CatsReferral) listofReferralsDO.get(i));
			}	
		}
	}

	private void updateRTTforCatsRef(CatsReferral catsRefDO) throws StaleObjectException, DomainInterfaceException //WDEV-18326 
	{
		int nationalCode = RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE;

		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() || Boolean.FALSE.equals(catsRefDO.isRTTClockImpact()))
			return;	

		if (catsRefDO == null || (catsRefDO != null && catsRefDO.getCurrentRTTStatus() != null && catsRefDO.getCurrentRTTStatus().getRTTStatus() != null && nationalCode == catsRefDO.getCurrentRTTStatus().getRTTStatus().getNationalCode()))
			return;

		DomainFactory factory = getDomainFactory();

		PatientPathwayJourney journeyDO = catsRefDO.getJourney();

		PathwayRTTStatus rttSTatusDO = createPathwRTTStatus(nationalCode);
		
		if (journeyDO != null && journeyDO.getCurrentClock() != null)
		{

			PathwayClock ptwClockDO = journeyDO.getCurrentClock();

			ptwClockDO.setCurrentRTTStatus(rttSTatusDO);

			List<PathwayRTTStatus> ptwClockHistory = ptwClockDO.getRTTStatusHistory();

			if (ptwClockHistory == null)
			{
				ptwClockHistory = new java.util.ArrayList();
			}
			ptwClockHistory.add(rttSTatusDO);

			instantiatePatientEvent(catsRefDO, rttSTatusDO);
		}
		
		catsRefDO.setCurrentRTTStatus(rttSTatusDO);
		
		factory.save(catsRefDO);

	}

	private PathwayRTTStatus createPathwRTTStatus(int nationalCode) throws StaleObjectException //WDEV-18326
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();

		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);

		rttSTatusDO.setRTTStatus(rttStatusPoint);

		Object mos = getMosUser();
		MemberOfStaff doMos = null;

		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}

		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(new java.util.Date());

		return rttSTatusDO;
	}

	private  List<?> getCatsReferralsforPatient(Patient patient)
	{
		String hql = "select ref from CatsReferral as ref left join ref.patient as pat left join ref.journey as journ left join journ.currentClock as cclock where journ.endedOnDate is null and cclock is not null and cclock.stopDate is null and pat.id = :patientID";

		DomainFactory factory = getDomainFactory();

		List<?> results = factory.find(hql, new String[]{"patientID"}, new Object[] {patient.getID_Patient()});

		if (results != null && results.size() > 0)
		{
			return results;
		}
		return null;
	}

	private void instantiatePatientEvent(CatsReferral doCats, PathwayRTTStatus pathRTTStatDO) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		RTTStatusEventMapVo  rttEventMap = null;

		if (pathRTTStatDO != null)
		{
			rttEventMap = getRTTStatusEventMap(pathRTTStatDO.getRTTStatus());
		}
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;

		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo) PatientListVoAssembler.create(doCats.getJourney().getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		try 
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
			ims.core.helper.IPathwayPatientEventHelper pathwayImp = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);
			pathwayImp.instantiatePatientEvent(patEvent);
		} 
		catch (ClassNotFoundException e) 
		{
			// You'll have to manage this -log the exception in system log please - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}

	}

	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18326
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();

		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);

		}
		return null;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18326
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}
	

	private void cancelFutureAppointments(Patient patient) throws StaleObjectException
	{
		if (patient == null || patient.getID_Patient() == null)
			return;
		
		// Get future appointments
		String query = "SELECT appt FROM Booking_Appointment AS appt LEFT JOIN appt.patient AS pat LEFT JOIN appt.apptStatus AS apptStat WHERE pat.id = :PAT_ID AND apptStat.id = :BOOKED_STATUS AND appt.appointmentDate >= :TODAY";
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("PAT_ID");			paramValues.add(patient.getID_Patient());
		paramNames.add("BOOKED_STATUS");	paramValues.add(Status_Reason.BOOKED.getID());
		paramNames.add("TODAY");			paramValues.add(new java.util.Date());
		
		BookingAppointmentLiteVoCollection bookedAppointments = BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(getDomainFactory().find(query, paramNames, paramValues));
		
		// Cancel future appointments
		if (bookedAppointments != null)
		{
			try
			{
				Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
				ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
				
				for (BookingAppointmentLiteVo appt : bookedAppointments)
				{
					Booking_AppointmentVo appointment = Booking_AppointmentVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(Booking_Appointment.class, appt.getID_Booking_Appointment()));
					appointment.setApptStatus(Status_Reason.CANCELLED);

					Appointment_StatusVo appointmentStatus = new Appointment_StatusVo();
					appointmentStatus.setStatus(Status_Reason.CANCELLED);
					appointmentStatus.setStatusReason(Status_Reason.SLOTOPENED);
					appointmentStatus.setStatusChangeDateTime(new DateTime());
					appointment.setCurrentStatusRecord(appointmentStatus);

					if (appointment.getApptStatusHistory() == null)
						appointment.setApptStatusHistory(new Appointment_StatusVoCollection());
					appointment.getApptStatusHistory().add(appointmentStatus);

					if (appointment.getSessionSlot() != null)
						appointment.getSessionSlot().setStatus(Status_Reason.SLOTOPENED);

					sessionAdminImp.cancelAppt(appointment, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested when Patient was marked as DOD.");
				}
			}
			catch (ClassNotFoundException e)
			{
				// log the exception in system log - but it should be fine
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
			}
		}
	}
	
	
	private void cancelSD_APPTS(Patient patient) throws DomainInterfaceException
	{
		Sd_appt apptRec = (Sd_appt)getDTOInstance(Sd_appt.class);
		apptRec.DataCollection.add();
		Sd_apptRecord rec = apptRec.DataCollection.get(0);

//		ret = put_text("*SERVICE", "SD_APPT");
//		ret = put_text("PKEY", pDoc->m_Patient.Demographics.pid);
//		ret = put_text("APPT_DT",DOD);
//		ret = put_text("ACTION", "CANCEL");
//		ret = Message(message,error);
		
		rec.Appt_idCollection.add();
		Sd_apptAppt_idRecord apptColl = rec.Appt_idCollection.get(0);
//		apptColl.Appt_dt = DTOHelper.convertToDtoDate(patient.getDod().getDate());
		apptColl.Appt_dt = ">" + DTOHelper.convertToDtoDate(patient.getDod().getDate());
		
		//rec.Hospnum = patient.getHospnum().getValue();
		rec.Pkey = patient.getPkey().getValue().toString();
		
		Result res = apptRec.executeAction("CANCEL");
		
		if (res != null 
			&& res.getId() < 0 
			&& res.getId() != -2
			&& res.getId() != -3)
			throw new DomainInterfaceException("Error occurred Cancelling Patient Appointments - " + res.getMessage());
	}

	private void saveAlias(Patient patient) throws DomainInterfaceException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return;

		if (patient.getHospnum() == null)
			throw new DomainInterfaceException("Attempting to save an Alias Failed - no hospital number supplied");
			
		Alias aliasRec = null;
		try
		{
			aliasRec  = (Alias) getDTOInstance(Alias.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		aliasRec.Filter.clear();
		aliasRec.DataCollection.add();
		AliasRecord dtoAlias = aliasRec.DataCollection.get(0);
	
		dtoAlias.Hospnum = patient.getHospnum().getIdValue();
		dtoAlias.Snm = patient.getSaveAlias();
		
		if (dtoAlias.Snm != "")
		{
			Result result = aliasRec.insert();
			if(result != null && result.getId() < 0)
				throw new DomainInterfaceException("Attempt to save Alias to Pas failed " + result.getMessage());
		}
	}

	private Patient savePatientToDto(DomainFactory factory, ims.core.patient.domain.objects.Patient domPatient, Patient voPatient, Boolean fromInterface, boolean fromDtoReplicate, boolean bBlankTempAddress) throws DomainInterfaceException, StaleObjectException
	{
		factory.save(domPatient);
		if(factory.isDirty(domPatient) || voPatient.getID_Patient() == null)
		{
			//WDEV- 6964 - update the pas and if new use the pasa generated hospnum for the local patient
			if(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue() == true && !fromInterface)
			{
				String[] newIds = updateOrInsertDTOPatient(voPatient, fromDtoReplicate, bBlankTempAddress);	
				if(newIds != null)
				{	
					ims.core.patient.domain.objects.PatientId patHospnumId = new ims.core.patient.domain.objects.PatientId();
					patHospnumId.setType(getDomLookup(PatIdType.HOSPNUM));
					patHospnumId.setValue(newIds[0]);
					domPatient.getIdentifiers().add(patHospnumId);
					
					ims.core.patient.domain.objects.PatientId patPkeyId = new ims.core.patient.domain.objects.PatientId();
					patPkeyId.setType(getDomLookup(PatIdType.PKEY));
					patPkeyId.setValue(newIds[1]);
					domPatient.getIdentifiers().add(patPkeyId);
					
					factory.save(domPatient);
					voPatient = PatientAssembler.create(domPatient);
				}
			}
		}
	
		factory.setDirtyCheck(false);
		return voPatient;
	}

	/**
	 * this method will try a get from DTO
	 * if a record is found it will be updated else an insert will occur
	 * @param fromDtoReplicate 
	 * @param patient
	 * @return
	 */
	private String[] updateOrInsertDTOPatient(Patient voPatient, boolean fromDtoReplicate, boolean bBlankTempAddressFields) throws DomainInterfaceException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		boolean isNew = false;
		
		//try a get
		DemographicsRecord dtoPatient = null;
		
		Demographics patRec = null;
		try
		{
			patRec = (Demographics) getDTOInstance(Demographics.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		patRec.Filter.clear();
		PatientId intfId = voPatient.getInterfaceId();
		Result result = null;
		if (intfId != null)
		{
			if (intfId.getType().equals(PatIdType.PKEY))
			{
				patRec.Filter.Pkey = intfId.getIdValue();
			}
			else if (intfId.getType().equals(PatIdType.HOSPNUM))
			{
				patRec.Filter.Hospnum = intfId.getIdValue();
			}
			else if (intfId.getType().equals(PatIdType.NHSN))
			{
				String strNHSN = intfId.getIdValue().replace(" ","");
				patRec.Filter.Nhsn =  strNHSN.length() > 10 ? strNHSN.substring(0, 10) : strNHSN;//wdev-18119
			}
			else if (intfId.getType().equals(PatIdType.CHARTNUM))
			{
				patRec.Filter.Chartnum = intfId.getIdValue();
			}
			else
			{
				throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
			}
			
			result = patRec.get();
			if (result != null)
				throw new DomainInterfaceException("Attempt to get from Pas failed " + result.getMessage());
				
			dtoPatient = patRec.DataCollection.get(0);
		}
		else
		{
			patRec.DataCollection.add();
			dtoPatient = patRec.DataCollection.get(0);
			isNew = true;
		}

		/////////////////////////////////////////////////
		
		if(voPatient.getNhsn() != null)
		{
			String strNHSN = voPatient.getNhsn().getValue().replace(" ","");
			dtoPatient.Nhsn =  strNHSN.length() > 10 ? strNHSN.substring(0, 10) : strNHSN;//wdev-18119
		}
		else
			dtoPatient.Nhsn = "";
		
		if(voPatient.getPkey() != null)
			dtoPatient.Pkey = voPatient.getPkey().getValue();
		else
			dtoPatient.Pkey = "";
		
		if(voPatient.getHospnum() != null)
			dtoPatient.Hospnum = voPatient.getHospnum().getValue();
		else
			dtoPatient.Hospnum = "";
		
		if(voPatient.getPpsn() != null)
			dtoPatient.Ppsn = voPatient.getPpsn().getValue();
		else
			dtoPatient.Ppsn = "";
		
		if(voPatient.getChartnum() != null)
			dtoPatient.Chartnum = voPatient.getChartnum().getValue();
		else
			dtoPatient.Chartnum = "";
		
		if(voPatient.getNameIsNotNull())
		{
			dtoPatient.Snm = voPatient.getName().getSurname();
			dtoPatient.Fnm1 = voPatient.getName().getForename();
			dtoPatient.Fnm2 = voPatient.getName().getMiddleName();
			
			if(voPatient.getName().getTitleIsNotNull())
				dtoPatient.Titl = DTOHelper.getPasMapping(getDomLookup(voPatient.getName().getTitle())); 
			else
				dtoPatient.Titl = "";
		}
		
		if(voPatient.getMaidenName() != null)
			dtoPatient.Snmb = voPatient.getMaidenName().getSurname();
		
		dtoPatient.Sex = DTOHelper.getPasMapping(getDomLookup(voPatient.getSex()));
		dtoPatient.Dob = DTOHelper.convertToDtoDate(voPatient.getDob());
		
		if(voPatient.getDodIsNotNull())
		{
			dtoPatient.Dod = DTOHelper.convertToDtoDate(voPatient.getDod().getDate());
			
			// WDEV-14378 - PAS will cancel appts, and the treatment plan actions
			if (ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
					&& voPatient.getCancelSD_APPTSIsNotNull()
					&& voPatient.getCancelSD_APPTS().booleanValue() )
				dtoPatient.Delpatact="Y";

			
		}
		else
			dtoPatient.Dod = "";

		if(voPatient.getAddressIsNotNull())
		{
			PersonAddress voPatAddress = voPatient.getAddress();
			dtoPatient.Adr1 = voPatAddress.getLine1();
			dtoPatient.Adr2 = voPatAddress.getLine2();
			dtoPatient.Adr3 = voPatAddress.getLine3();
			dtoPatient.Adr4 = voPatAddress.getLine4();
			dtoPatient.Post = voPatAddress.getPostCode();
		}
	
		if (voPatient.getHARCCodeIsNotNull())
			dtoPatient.Harc = voPatient.getHARCCode();

		//wdev-13498
		if((dtoPatient.Post == null || dtoPatient.Post.equals(""))
			&& (dtoPatient.Harc == null || dtoPatient.Harc.equals("")))
			dtoPatient.Harc = "X98";
		
		//WDEV-16975
		if (voPatient.getHARCCodeIsNotNull() && voPatient.getHARCCode().equals(""))
			dtoPatient.Harc = "";
			

		if(voPatient.getCommChannelsIsNotNull() && voPatient.getCommChannels().size() > 0)
		{
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE) != null)
				dtoPatient.Dtel  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE).getCommValue();
			else
				dtoPatient.Dtel = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.HOME_PHONE) != null)
				dtoPatient.Ntel  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.HOME_PHONE).getCommValue();
			else
				dtoPatient.Ntel = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.MOBILE) != null)
				dtoPatient.Mobile  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.MOBILE).getCommValue();		
			else
				dtoPatient.Mobile = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.FAX) != null)
				dtoPatient.Fax  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.FAX).getCommValue();		
			else
				dtoPatient.Fax = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.EMAIL) != null)
				dtoPatient.Email  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.EMAIL).getCommValue();		
			else
				dtoPatient.Email = "";
		}
		else
		{
			dtoPatient.Dtel = "";
			dtoPatient.Ntel = "";
			dtoPatient.Mobile = "";
			dtoPatient.Fax = "";
			dtoPatient.Email = "";
		}

		dtoPatient.Mart = DTOHelper.getPasMapping(getDomLookup(voPatient.getMaritalStatus()));
		dtoPatient.Relg = DTOHelper.getPasMapping(getDomLookup(voPatient.getReligion()));

		String strEthc = DTOHelper.getPasMapping(getDomLookup(voPatient.getEthnicOrigin()));
		
		if (Boolean.TRUE.equals(ConfigFlag.UI.PAS_PATIENT_ETHNIC_ORIGIN_MANDATORY.getValue()) && "".equals(strEthc))
		{
			dtoPatient.Ethc = "Z";
		}
		else
		{
			dtoPatient.Ethc = strEthc;
		}

		if(voPatient.getNokIsNotNull())
		{
			if(voPatient.getNok().getNameIsNotNull())
			{
				dtoPatient.Name = voPatient.getNok().getName().getSurname();
				if(voPatient.getNok().getName().getTitleIsNotNull())
					dtoPatient.Ntitl = DTOHelper.getPasMapping(getDomLookup(voPatient.getNok().getName().getTitle())); 
				else 
					dtoPatient.Ntitl = "";
			} 
			
			if(voPatient.getNok().getAddressIsNotNull())
			{
				dtoPatient.Nadr1 = voPatient.getNok().getAddress().getLine1();
				dtoPatient.Nadr2 = voPatient.getNok().getAddress().getLine2();
				dtoPatient.Nadr3 = voPatient.getNok().getAddress().getLine3();
				dtoPatient.Nadr4 = voPatient.getNok().getAddress().getLine4();
				dtoPatient.Npost = voPatient.getNok().getAddress().getPostCode();
				dtoPatient.Nntel = voPatient.getNok().getAddress().getPhone();
			}
			
			if(voPatient.getNok().getCommChannelsIsNotNull())
			{
				if(voPatient.getNok().getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE) != null)
					dtoPatient.Ndtel = voPatient.getNok().getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE).getCommValue();
				else
					dtoPatient.Ndtel = "";
			}
			
			dtoPatient.Rel = DTOHelper.getPasMapping(getDomLookup(voPatient.getNok().getRelationship()));
		}
		//WDEV-12974 clear dto fields wher nok is null
		else{
			dtoPatient.Name = "";
			dtoPatient.Ntitl = "";
			dtoPatient.Nadr1 = "";
			dtoPatient.Nadr2 = "";
			dtoPatient.Nadr3 = "";
			dtoPatient.Nadr4 = "";
			dtoPatient.Npost = "";
			dtoPatient.Nntel = "";
			dtoPatient.Rel = "";
		}
				
		if(voPatient.getAddressesIsNotNull())
		{
			if(voPatient.getAddresses().size() > 0)
			{
				for (int i = 0 ; i< voPatient.getAddresses().size() ; i++)
				{
					PersonAddress voTempAddress = voPatient.getAddresses().get(i);
					
					if ((voTempAddress != null 
						&& voTempAddress.getAddressTypeIsNotNull() 
						&& DTOHelper.getPasMapping(getDomLookup(voTempAddress.getAddressType())) != null //WDEV-14510
						&& DTOHelper.getPasMapping(getDomLookup(voTempAddress.getAddressType())).equals("C")) )
					{
						dtoPatient.Tadr1 = voTempAddress.getLine1();
						dtoPatient.Tadr2 = voTempAddress.getLine2();
						dtoPatient.Tadr3 = voTempAddress.getLine3();
						dtoPatient.Tadr4 = voTempAddress.getLine4();
						dtoPatient.Tpost = voTempAddress.getPostCode();
						dtoPatient.Tdtel = voTempAddress.getOtherphone();
						dtoPatient.Tntel = voTempAddress.getPhone();
					}
				}
			}
			if (bBlankTempAddressFields)
			{
				dtoPatient.Tadr1 = "";
				dtoPatient.Tadr2 = "";
				dtoPatient.Tadr3 = "";
				dtoPatient.Tadr4 = "";
				dtoPatient.Tpost = "";
				dtoPatient.Tdtel = "";
				dtoPatient.Tntel = "";
			}
		}
		
		if(voPatient.getGpIsNotNull())
		{
			dtoPatient.Gmcnum = voPatient.getGp().getNationalCode();
			dtoPatient.Gpcd = getMappingForGp(voPatient.getGp());
			dtoPatient.Prcd = getMappingForGpSurgery(voPatient.getGpSurgery());
		}
		else
		{
			dtoPatient.Gmcnum = "";
			dtoPatient.Gpcd = "";
			dtoPatient.Prcd = "";
		}
		
		//wdev-12963
		if (ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
			&& voPatient.getCancelSD_APPTSIsNotNull()
			&& voPatient.getCancelSD_APPTS().booleanValue() )
			dtoPatient.Delpatact = "Y"; 

		if(dtoPatient.Cnt == null || dtoPatient.Cnt.equals("")) 
			dtoPatient.Cnt = ConfigFlag.UI.PATIENT_REGISTRATION_DEFAULT_CASEFOLDER_LOCATION.getValue();//wdev-14659

		if (fromDtoReplicate)
			dtoPatient.Webadt = "Y";
		
		if(isNew)	
			result = patRec.insert();
		else
			result = patRec.update();
		
		if(result != null && result.getId() < 0)
			throw new DomainInterfaceException("Attempt to save to Pas failed " + result.getMessage());
		
		//return an array containing Hospnum and Pkey values generated by Pas
		if(isNew)	
			return new String[] {patRec.getLastResultData().getValue("HOSPNUM"), patRec.getLastResultData().getValue("PKEY")};
		
		return null;
	}

	private String getMappingForGpSurgery(LocSiteShortVo locSiteShortVo)
	{
		if(locSiteShortVo != null && locSiteShortVo.getCodeMappingsIsNotNull())
			return locSiteShortVo.getCodeMappings().getMappingValue(TaxonomyType.PAS);

		return "";
	}

	private String getMappingForGp(GpShortVo gp)
	{
		if(gp != null && gp.getCodeMappingsIsNotNull())
			return gp.getCodeMappings().getMappingValue(TaxonomyType.PAS);

		return "";
	}

	public Boolean deletePatient(Patient patient) throws StaleObjectException
	{
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (patient.getID_Patient() == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient().intValue());
		if (patBo == null)
			return Boolean.FALSE;

		// Check if patient is already inactive.
		if (patBo.isIsActive() != null && patBo.isIsActive().booleanValue() == false)
			return Boolean.TRUE;

		patBo.setIsActive(Boolean.FALSE);
		factory.save(patBo);
		return Boolean.TRUE;
	}

	public PatientShort getPatientShort(PatientRefVo patRefVo)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patRefVo.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}
	
	public GpLiteToPracticeLiteVo synchronizeGPPracticeDetails(String strGPCode)  throws StaleObjectException, UniqueKeyViolationException
	{
		Gp_practice gpPracticeRecord = (Gp_practice) getDTOInstance(Gp_practice.class);
		gpPracticeRecord.Filter.Gp_code = strGPCode;
		GP voGP = null;
		
		Result gpPracticeGetResult = gpPracticeRecord.get();
		if (gpPracticeGetResult != null)
			return null;
		
		Gp_practiceRecord gp_practice_record = gpPracticeRecord.DataCollection.get(0);
		OrganisationVo voSavedPractice = null;
		if (gpPracticeGetResult == null && gp_practice_record != null) 
		{
			// Extract the organisation which is in effect the practice and the location site
			// which is in effect the surgery and synchronise them withthe current date.			
			
			// If the Practice is in csp, get it and populate from dto, otherwise just populate from dto.
			try
			{
				voSavedPractice = saveOrganisation(populatePracticeFromDTORecord(gp_practice_record));
			}
			catch (UniqueKeyViolationException e)
			{
				// DARA TODO Comm Channels
			}
							
			voGP =  saveGP(populateGpFromDTORecord(gp_practice_record, voSavedPractice));
			
			GpLiteToPracticeLiteVo voGpLiteToPracticeLite = new GpLiteToPracticeLiteVo();
			// Just need a get here to see if you already have a gppracticeslite record.
			
			GpPracticeLiteVo voGpPracticeLite = new GpPracticeLiteVo();
			voGpPracticeLite.setAddress(voSavedPractice.getAddress());
			voGpPracticeLite.setID_Organisation(voSavedPractice.getID_Organisation());
			voGpPracticeLite.setIsActive(voSavedPractice.getIsActive());
			voGpPracticeLite.setName(voSavedPractice.getName());
			voGpPracticeLite.setType(OrganisationType.GPP);
			
			LocSiteShortVo voLocSiteShort = getLocSiteShortByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
			LocSiteShortVoCollection voCollLocations = new LocSiteShortVoCollection();
			voCollLocations.add(voLocSiteShort);
			voGpPracticeLite.setSurgeries(voCollLocations);
			
			voGpLiteToPracticeLite.setGp(voGP == null ? null : voGP);
			voGpLiteToPracticeLite.setPractice(voGpPracticeLite);
			return voGpLiteToPracticeLite;
			
		}
		
		return null;
		
		
	}

	private LocSiteVo populateLocSiteFromDTORecord(Gp_practiceRecord gp_practice_record)
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		LocSiteVo voLocSite = getLocSiteByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
		if (voLocSite == null) 
		{
			voLocSite = new LocSiteVo();
			voLocSite.setCodeMappings(newTaxonomyMapFromDTORecord(gp_practice_record));
			voLocSite.setType(LocationType.SURGERY);
			voLocSite.setIsActive(Boolean.TRUE);
			voLocSite.setIsVirtual(Boolean.FALSE);
		}

		// Phone,fax,address1,2,3,4,5
		PersonAddress voPracticeAddress = extractPracticeAddressFromDTOPracticeRecord(gp_practice_record);
		if (voLocSite != null)
			voLocSite.setAddress(voPracticeAddress);

		voLocSite.setName(gp_practice_record.Practice_name);
		return voLocSite;
	}

	private OrganisationVo populatePracticeFromDTORecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		OrganisationVo voPractice = getOrganisationByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
		if (voPractice == null) 
		{
			voPractice = new OrganisationVo();
			voPractice.setCodeMappings(newTaxonomyMapFromDTORecord(gp_practice_record));
			voPractice.setType(OrganisationType.GPP);
			voPractice.setIsActive(Boolean.TRUE);	
		}

		// Phone,fax,address1,2,3,4,5
		PersonAddress voPracticeAddress = extractPracticeAddressFromDTOPracticeRecord(gp_practice_record);
		if (voPracticeAddress != null)
			voPractice.setAddress(voPracticeAddress);

		voPractice.setName(gp_practice_record.Practice_name);		
		LocSiteVo voSurgery  = populateLocSiteFromDTORecord(gp_practice_record);

		if (voPractice.getLocationSites() != null && voPractice.getLocationSites().size() == 1)
			voPractice.getLocationSites().set(0, voSurgery);				
		else if (voPractice.getLocationSitesIsNotNull())
			voPractice.getLocationSites().add(voSurgery);
		else
		{
			LocSiteVoCollection locCollVo = new LocSiteVoCollection();
			locCollVo.add(voSurgery);
			voPractice.setLocationSites(locCollVo);
		}
		
		
		return voPractice;
	}

	private TaxonomyMapCollection newTaxonomyMapFromDTORecord(Gp_practiceRecord gp_practice_record )
	{
		TaxonomyMap voTaxonomy = new TaxonomyMap();
		voTaxonomy.setTaxonomyName(TaxonomyType.PAS);
		voTaxonomy.setTaxonomyCode(gp_practice_record.Gp_practice_id);
		voTaxonomy.setDescription("DTO GP Practice");
		TaxonomyMapCollection voCollTaxonomyMap = new TaxonomyMapCollection();
		voCollTaxonomyMap.add(voTaxonomy);
		return voCollTaxonomyMap;
	}

	private GP populateGpFromDTORecord(Gp_practiceRecord gp_practice_record, OrganisationVo voGPPractice) 
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		GP voGP = getGpByPasId(gp_practice_record.Gp_id);

		if (voGP == null) 
		{
			voGP = new GP();
			TaxonomyMap voTaxonomy = new TaxonomyMap();
			voTaxonomy.setTaxonomyName(TaxonomyType.PAS);
			voTaxonomy.setTaxonomyCode(gp_practice_record.Gp_id);
			voTaxonomy.setDescription("DTO GP");
			TaxonomyMapCollection voCollTaxonomyMap = new TaxonomyMapCollection();
			voCollTaxonomyMap.add(voTaxonomy);
			voGP.setCodeMappings(voCollTaxonomyMap);
		}

		voGP.setName(extractPersonNameFromGPPracticeRecord(gp_practice_record));
		voGP.setMobile(gp_practice_record.Gp_mobile_no == null ? null: gp_practice_record.Gp_mobile_no);
		voGP.setEmailAddress(gp_practice_record.Gp_email == null ? null: gp_practice_record.Gp_email);
						
		
		if (voGP.getID_Gp() == null)
		{			
			voGP.setPractices(newGpToPracticesCollectionFromDTORecord(gp_practice_record, voGP));
		}
		else
		{
			boolean bFound = false;
			int i=0;
			GpToPracticesVo voGpToPractice = new GpToPracticesVo();
			// gptopractice exists - find and update it
			for (i=0; i < voGP.getPractices().size(); i++)
			{
				voGP.getPractices().get(i).setIsPrimaryPractice(Boolean.FALSE);
				if ((voGP.getPractices().get(i).getPracticeIsNotNull()) && (voGP.getPractices().get(i).getPractice().getID_Organisation().equals(voGPPractice.getID_Organisation())))
				{
					voGpToPractice = voGP.getPractices().get(i); 
					bFound = true;
					break;
				} 
			}
			
			voGpToPractice.setGp(voGP);
			voGpToPractice.setPractice(voGPPractice);	
			voGpToPractice.setIsPrimaryPractice(Boolean.TRUE);

			if (bFound == false)
				voGP.getPractices().add(voGpToPractice);
			else
				voGP.getPractices().set(i, voGpToPractice);				
		}				

		voGP.setCommChannels(new CommChannelVoCollection());
		return voGP;		
	}
		
	private GpToPracticesVoCollection newGpToPracticesCollectionFromDTORecord(Gp_practiceRecord gp_practice_record, GpShortVo voGP )
	{
		GpToPracticesVo voGpToPractice = new GpToPracticesVo();
		voGpToPractice.setGp(voGP);
		voGpToPractice.setGpCode(gp_practice_record.Gp_code);
		// TODO voGpToPractice.setPractice(voGPPractice);
		voGpToPractice.setIsPrimaryPractice(Boolean.TRUE);
		GpToPracticesVoCollection voCollGpToPractices = new GpToPracticesVoCollection();
		voCollGpToPractices.add(voGpToPractice);
		return voCollGpToPractices;
	}

	private PersonAddress extractPracticeAddressFromDTOPracticeRecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record == null)
			return null;

		PersonAddress voPracticeAddress = new PersonAddress();

		voPracticeAddress.setPhone(gp_practice_record.Practice_phone_no == null ? null : gp_practice_record.Practice_phone_no);
		voPracticeAddress.setFax(gp_practice_record.Practice_fax_no == null ? null: gp_practice_record.Practice_fax_no);
		voPracticeAddress.setLine1(gp_practice_record.Address_line1 == null ? null: gp_practice_record.Address_line1);
		voPracticeAddress.setLine2(gp_practice_record.Address_line2 == null ? null: gp_practice_record.Address_line2);
		voPracticeAddress.setLine3(gp_practice_record.Address_line3 == null ? null: gp_practice_record.Address_line3);
		voPracticeAddress.setLine4(gp_practice_record.Address_line4 == null ? null: gp_practice_record.Address_line4);
		voPracticeAddress.setLine5(gp_practice_record.Address_line5 == null ? null: gp_practice_record.Address_line5);
		// TODO ask leader voPracticeAddress.setCounty()
		return voPracticeAddress;
	}

	private PersonName extractPersonNameFromGPPracticeRecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record == null || gp_practice_record.Gp_surname == null	|| gp_practice_record.Gp_first_name == null)
			return null;

		PersonName voPersonName = new PersonName();
		PersonTitle voPersonTitle = new PersonTitle();
		voPersonTitle.setText(gp_practice_record.Gp_title == null ? null: gp_practice_record.Gp_title);
		voPersonName.setTitle(voPersonTitle);
		voPersonName.setForename(gp_practice_record.Gp_first_name);
		voPersonName.setSurname(gp_practice_record.Gp_surname);
		voPersonName.setUppers();
		return voPersonName;
	}
	
	private OrganisationVo saveOrganisation(OrganisationVo voOrganisation) throws StaleObjectException, UniqueKeyViolationException 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.saveOrganisation(voOrganisation);		
	}
	
	private GP getGpByPasId(String pasId) 
	{
		GPAdmin impl = (GPAdmin) getDomainImpl(GPAdminImpl.class);
		return impl.getGPByTaxonomyType(pasId, TaxonomyType.PAS);
	}

	public OrganisationVo getOrganisationByTaxonomyType(String extId,TaxonomyType taxonomyType) 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getOrganisationByTaxonomyType(extId, taxonomyType);
	}
	
	private LocSiteVo getLocSiteByTaxonomyType(String extId,TaxonomyType taxonomyType)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getLocSiteByTaxonomyType(extId, taxonomyType);
	}

	private LocSiteShortVo getLocSiteShortByTaxonomyType(String extId,TaxonomyType taxonomyType)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getLocSiteShortByTaxonomyType(extId, taxonomyType);
	}
	
	private GP saveGP(GP voGP) throws StaleObjectException, UniqueKeyViolationException 
	{
		String[] arrErrors = null;
		if (voGP != null)
			arrErrors = voGP.validate();

		if (arrErrors != null)
			return null;
		
		GPAdmin impl = (GPAdmin) getDomainImpl(GPAdminImpl.class);
		return impl.saveGp(voGP);
		
	}

	/** 
	 * getPatientList
	 * This method will return an active patient, either the patient matching
	 * the search criteria provided, or it's equivalent new merged patient
	 * Used by HL7engine.
	 */
	public PatientLiteVo getPatientLite(PatientShort patVo)
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patVo);
		if (domPatient != null)
		{
			// Check associated value if not null, then get this patient
			while(domPatient.getAssociatedPatient() != null)
			{
				domPatient = domPatient.getAssociatedPatient();
			}
		}
		
		return PatientLiteVoAssembler.create(domPatient);
	}

	public DeathDetailsVo saveDeathDetails(DeathDetailsVo deathDetails) throws StaleObjectException 
	{
		// Ensure the value object has been validated
		if (!deathDetails.isValidated())
			throw new DomainRuntimeException("Death details has not been validated");
		
		DomainFactory factory = getDomainFactory();
		DeathDetails doDD = DeathDetailsVoAssembler.extractDeathDetails(factory, deathDetails);
		
		if (deathDetails.getIsRIE() != null)
			doDD.setIsRIE(deathDetails.getIsRIE());
		
		factory.save(doDD);
		
		return DeathDetailsVoAssembler.create(doDD);
	}
	
	//WDEV-18259
	private void updatePatientElectiveListsForDOD(PatientShort patientShort) throws StaleObjectException
	{
		if (!ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
			return;

		DomainFactory factory = getDomainFactory();

		String patientElectiveListQuery = "select electiveList from PatientElectiveList as electiveList left join electiveList.electiveListStatus as elStatus left join elStatus.electiveListStatus as stat left join electiveList.patient as pat where pat.id = :patId and stat.id <> :statusId";
		List<?> electiveList = factory.find(patientElectiveListQuery, new String[] { "patId", "statusId" }, new Object[] { patientShort.getID_Patient(), WaitingListStatus.REMOVED.getID() });

		if (electiveList == null || electiveList.size() == 0)
			return;

		// update patientElectiveLists for current Patient
		PatientElectiveList doPatientElectiveList = null;

		MemberOfStaff domainMOS = null;
		Object mosUser = getMosUser();

		if (mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
		}

		Date currentDate = new Date();

		for (int i = 0; i < electiveList.size(); i++)
		{
			doPatientElectiveList = (PatientElectiveList) electiveList.get(i);

			if (doPatientElectiveList != null)
			{
				// create new Elective List Status
				ElectiveListStatus status = new ElectiveListStatus();
				status.setElectiveListStatus(getDomLookup(WaitingListStatus.REMOVED));
				status.setRemovalReason(getDomLookup(ElectiveListStatusReason.PATIENT_DIED));
				status.setAuthoringUser(domainMOS);
				status.setStatusDateTime(new java.util.Date());

				doPatientElectiveList.setElectiveListStatus(status);

				// add this status to the Status History
				if (doPatientElectiveList.getElectiveListStatusHistory() == null)
					doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());

				doPatientElectiveList.getElectiveListStatusHistory().add(status);

				// update the future TCIs
				TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();

				if (doTCIDetails != null && doTCIDetails.isIsActive() && doTCIDetails.getTCIDate() != null && currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) <= 0)
				{
					// create a new Outcome
					TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();

					if (currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) < 0)
					{
						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_BEFORE_6));
					}
					else if (currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) == 0)
					{
						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
					}

					newOutcome.setChangeBy(domainMOS);
					newOutcome.setStatusDateTime(new java.util.Date());
					newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.CANCELLEDBYREMOVALOFELECTIVELISTRECORD));

					doTCIDetails.setCurrentOutcome(newOutcome);
					doTCIDetails.setIsActive(false);

					// add new outcome to Outcome History
					if (doTCIDetails.getOutcomeHistory() == null)
						doTCIDetails.setOutcomeHistory(new ArrayList());

					doTCIDetails.getOutcomeHistory().add(newOutcome);

				}
			}

			// Stop the current clock
			if (doPatientElectiveList.getReferral() != null && doPatientElectiveList.getReferral().getJourney() != null)
			{
				PatientPathwayJourney doJourney = doPatientElectiveList.getReferral().getJourney();

				if (doJourney != null && doJourney.getCurrentStatus() != null && !doJourney.getCurrentStatus().getStatus().equals(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY)))
				{

					PatientJourneyStatus journeyStatus = new PatientJourneyStatus();
					journeyStatus.setDateTime(new java.util.Date());
					journeyStatus.setStatus(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY));

					if (doJourney.getStatusHistory() == null)
					{
						doJourney.setStatusHistory(new HashSet());
					}

					if (doJourney.getCurrentClock() != null)
					{
						doJourney.getCurrentClock().setStopDate(patientShort.getDod().getDate());
					}

					doJourney.setEndedOnDate(patientShort.getDod().getDate());
					doJourney.setCurrentStatus(journeyStatus);
					doJourney.getStatusHistory().add(journeyStatus);

				}
			}

			factory.save(doPatientElectiveList);
		}
	}

	public ims.core.vo.Patient getMergedPatient(PatientShort patient) 
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient);
		// The id sent down for the patient could be the main one, we may need
		// to check whether this patient id is used as an associated patient anywhere!
		if (domPatient != null && domPatient.getAssociatedPatient() == null)
		{
			DomainFactory factory = getDomainFactory();
			List lst = factory.find("from Patient p where p.associatedPatient.id = :assoc", new String[]{"assoc"}, new Object[]{domPatient.getId()});
			if (lst != null && lst.size() > 0)
				return PatientAssembler.create((ims.core.patient.domain.objects.Patient) lst.get(0));
		}
		return PatientAssembler.create(domPatient);
	}

	public Patient saveDemographics(Patient patient, DeathDetailsVo deathDetails) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException, IndexOutOfBoundsException
	{
		saveDeathDetails(deathDetails);
		
		if(patient != null)
		return savePatient(patient,false);
		
		return null;
	
	}

	public DeathDetailsVo getDeathDetails(PatientShort value)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" from DeathDetails dd"); 
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		hql.append(" where dd.patient.id = :pId");
		
		markers.add("pId");
		values.add(value.getID_Patient());

		hql.append(" and dd.isRIE is null");


		List listNotes = factory.find(hql.toString(), markers,values);
		if(listNotes != null && listNotes.size() > 0)
		{ 
			DeathDetailsVoCollection voColl = DeathDetailsVoAssembler.createDeathDetailsVoCollectionFromDeathDetails(listNotes);
			if(voColl != null && voColl.size() > 0)
				return voColl.get(0);
		}
		return null;
		
	}

	/* New method
	 * http://jira/browse/WDEV-11792
	 * @see ims.core.domain.Demographics#validatePatient(ims.core.vo.Patient, ims.core.patient.vo.PatientRefVo)
	 */
	public Boolean validatePatient(Patient patientVOFromMsg, PatientRefVo patientRefFromOrder)
	{
		
		if (!ConfigFlag.HL7.VALIDATE_MSG_PATIENT_WITH_ORDER_PATIENT.getValue())
		{
			// If the flag is not set always true i.e. the patient is always valid
			return true;
		}
		// Get the patient from the message
		ims.core.patient.domain.objects.Patient domPatientFromMsg = getDomPatient(patientVOFromMsg,false);
		if (domPatientFromMsg == null) 
			return false;

		//recurse to get master patient if this patient was merged
		while(domPatientFromMsg.getAssociatedPatient() != null)
		{
			domPatientFromMsg = domPatientFromMsg.getAssociatedPatient();
		}
		
		//get the patient from the order
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient domPatientFromOrder = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patientRefFromOrder.getID_Patient().intValue());
		
		while(domPatientFromOrder.getAssociatedPatient() != null)
		{
			domPatientFromOrder = domPatientFromOrder.getAssociatedPatient();
		}
		
		if(domPatientFromOrder!=null&&domPatientFromMsg!=null&&
				domPatientFromOrder.getId()!=null&&
				domPatientFromOrder.getId().equals(domPatientFromMsg.getId()))
		{
			return true;
		}
		else 
		{
			return false;
		}

	}

	public CaseNoteFolderVo getCaseNoteFolderLocation(String strHospNum) 
	{
		ims.dto.client.Patient patRec = (ims.dto.client.Patient) getDTOInstance(ims.dto.client.Patient.class);

		patRec.Filter.clear();
		if (strHospNum == null)
		{
			throw new DomainRuntimeException("CaseNote Get call must contain valid interface identifier");
		}

		patRec.Filter.Hospnum = strHospNum;

		Result result = patRec.get();
		if (result != null)
		{
			return null;//WDEV-14481
		//	throw new DomainRuntimeException("Error getting Case Note details for patient " + strHospNum + "\nError - " + result.getMessage());
		}

		ims.core.vo.CaseNoteFolderVo voCaseNote = new CaseNoteFolderVo();
		voCaseNote.setLocation(patRec.DataCollection.get(0).Cflname);
		voCaseNote.setComments(patRec.DataCollection.get(0).Cflcomm);

		return (voCaseNote);
	}

	//------------------wdev-8696----------------
	/*public AppImageVo getAppImage(Integer imageId) 
	{
		DomainFactory factory = getDomainFactory();
		return AppImageVoAssembler.create((AppImage)factory.getDomainObject(AppImage.class, imageId));
	}*/
	//----------------------------------------------

	//
	public void insertDTOHistoricAddress(PersonAddress previousAddress, String pkey) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return;

		HaddRecord dtoHistoricAddress = null;
		Hadd historicAddressRec = null;
		
		try
		{
			historicAddressRec = (Hadd) getDTOInstance(Hadd.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		historicAddressRec.Filter.clear();
		
		historicAddressRec.DataCollection.add();
		dtoHistoricAddress = historicAddressRec.DataCollection.get(0);
		
		dtoHistoricAddress.Hospnum = pkey;
		dtoHistoricAddress.Adr1 = previousAddress.getLine1();
		dtoHistoricAddress.Adr2 = previousAddress.getLine2();
		dtoHistoricAddress.Adr3 = previousAddress.getLine3();
		dtoHistoricAddress.Adr4 = previousAddress.getLine4();
		dtoHistoricAddress.Post = previousAddress.getPostCode();
		if(previousAddress.getNotificationDateIsNotNull())
			dtoHistoricAddress.Datefrom = DTOHelper.convertToDtoDate(previousAddress.getNotificationDate().getDate());
		//if(dtoPatient.Post == null || dtoPatient.Post.equals(""))
		//	dtoHistoricAddress.Harc = "X98";
			
		Result result = historicAddressRec.insert();
		
		//WDEV-13440 
		if(result != null && result.getId() == -5)
			throw new DomainInterfaceException("Attempt to save Historic Address to Pas failed, " + "Address already exists for this date.");
		if(result != null && result.getId() < 0)
			throw new DomainInterfaceException("Attempt to save Historic Address to Pas failed " + result.getMessage());
		
	}

	public String getCCOAlias(String szHospnum) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		Alias aliasRec = null;
		try
		{
			aliasRec  = (Alias) getDTOInstance(Alias.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		aliasRec.Filter.clear();
		aliasRec.Filter.Hospnum = szHospnum;
		
		Result result = aliasRec.list();
		
		//wdev-15845
		if( result != null && result.getId() == -7 )
			throw new DomainInterfaceException("Demographics details cannot be edited - Please contact the system administrator with the details for this patient");
		//-------------
		
		if(result != null 
			&& result.getId() < 0
			&& result.getId() != -2
			&& result.getId() != -3)
			throw new DomainInterfaceException("Attempt to list Alias from Pas failed - " + result.getMessage());
		
		if (result != null
			&& result.getId() == -2
			&& result.getId() == -3)
			return null;
		else
		{
			if (aliasRec.DataCollection.count() > 0)
				return aliasRec.DataCollection.get(0).Snm;
			else
				return null;
		}
	}

	public PersonAddressCollection getDTOHistoricAddresses(String hospnum) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;
		
		Hadd historicAddressRec = null;
		try
		{
			historicAddressRec  = (Hadd) getDTOInstance(Hadd.class);		
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		PersonAddressCollection collPersonAddress = new PersonAddressCollection();
		
		historicAddressRec.Filter.clear();
		historicAddressRec.Filter.Hospnum = hospnum;
		
		Result result = historicAddressRec.list();
		
		if(result != null 
			&& result.getId() < 0
			&& result.getId() != -2
			&& result.getId() != -3)
			throw new DomainInterfaceException("Attempt to list Historic Addresses from Pas failed - " + result.getMessage());
		
		if (result != null
			&& result.getId() == -2
			&& result.getId() == -3)
			return null;
		else
		{
			for (int i = 0; i < historicAddressRec.DataCollection.count(); i++)
			{
				PersonAddress voPersonAddress = new PersonAddress();
			
				voPersonAddress.setLine1(historicAddressRec.DataCollection.get(i).Adr1);
				voPersonAddress.setLine2(historicAddressRec.DataCollection.get(i).Adr2);
				voPersonAddress.setLine3(historicAddressRec.DataCollection.get(i).Adr3);
				voPersonAddress.setLine4(historicAddressRec.DataCollection.get(i).Adr4);
				voPersonAddress.setAddressPostCode(historicAddressRec.DataCollection.get(i).Post);
				try {
					voPersonAddress.setNotificationDate(new Date(historicAddressRec.DataCollection.get(i).Datefrom, DateFormat.ISO));
				} catch (ParseException e) {
					e.printStackTrace();
				}
				voPersonAddress.setAddressType(AddressType.HISTORICAL);
				
				collPersonAddress.add(voPersonAddress);
			}
		}
		
		return collPersonAddress;
	}

	public ims.dto.client.Patient getCCODTOPatient(String pkey) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		if(pkey == null)
			throw new DomainRuntimeException("Cannot get Patient for null pkey");
		
		ims.dto.client.Patient patient = (ims.dto.client.Patient)getDTOInstance(ims.dto.client.Patient.class);
		patient.Filter.clear();
		patient.Filter.Pkey = pkey;
		
		Result result = patient.get();
		if (result != null)
		{
			if(result.getId() == -2)
				throw new DomainInterfaceException("Error Getting Patient Details for pkey = " + pkey);

			throw new DomainInterfaceException(result.getMessage());
		}

		if (patient.DataCollection.count()!= 1)
			throw new DomainInterfaceException("Failed to get patient record.");
		
		return patient;
	}
	//wdev-12889
	public LocSiteVo getLocationSite(LocationRefVo locSiteId) 
	{
		if(locSiteId == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		ims.core.resource.place.domain.objects.LocSite locSiteDO = (ims.core.resource.place.domain.objects.LocSite) factory.getDomainObject(ims.core.resource.place.domain.objects.LocSite.class, locSiteId.getID_Location());
		return LocSiteVoAssembler.create(locSiteDO);

	}

	//WDEV-16051
	public OrganisationWithSitesVo getGPPractice(OrganisationRefVo organisationRef)
	{
		if(organisationRef == null)
			throw new CodingRuntimeException("Cannot get Organisation on null Id.");
		
		return OrganisationWithSitesVoAssembler.create((Organisation) getDomainFactory().getDomainObject(Organisation.class, organisationRef.getID_Organisation()));
	}

	public String[] listPatientAlertsTextByTaxonomy(PatientRefVo patient,Boolean active, TaxonomyType type)
	{
		Alerts alerts = (Alerts) getDomainImpl(AlertsImpl.class);
		return alerts.listPatientAlertsTextByTaxonomy(patient, active, type);
	}

	//http://jira/browse/WDEV-17262
	private void updatePatientNoAlertInfo(PatientRefVo patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		String hql = new String("from PatientNoAlertInfo alertInfo where alertInfo.patient.id = :patient");
		List<?> list = factory.find(hql,new String[]{ "patient"},new Object[]{patient.getBoId()});
		if (list!=null||list.isEmpty())
		{
			for (Object object : list)
			{
				PatientNoAlertInfo alertInfo =(PatientNoAlertInfo)object;
				if(alertInfo.getAlertStatus()==null
						||alertInfo.getAlertStatus().equals(getDomLookup(PatientAlertStatus.NOKNOWNALERTS)))
				{
					alertInfo.setAlertStatus(getDomLookup(PatientAlertStatus.HASALERTS));
					factory.save(alertInfo);
				}
			}
		}	
	}
}	
