//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Barbara Worwood using IMS Development Environment (version 1.70 build 3314.22227)
// Copyright (C) 1995-2009 IMS MAXIMS plc. All rights reserved.

package ims.ccosched.domain.impl;

import ims.ccosched.domain.BookingConfirmation;
import ims.ccosched.domain.PatientDiary;
import ims.configuration.InitConfig;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.domain.objects.Referral;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.patient.vo.PatientRefVo;
import ims.core.vo.EpisodeofCareShortVoCollection;
import ims.core.vo.PatientApptDiaryVoCollection;
import ims.core.vo.domain.EpisodeofCareShortVoAssembler;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.impl.DomainImplFlyweightFactory;
import ims.dto.DTODomainImplementation;
import ims.dtomove.vo.SchedActivityVoCollection;
import ims.dtomove.vo.domain.SchedActivityVoAssembler;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.ocrr.vo.ProviderSystemVo;
import ims.ocrr.vo.domain.ProviderSystemVoAssembler;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.vo.EventVo;
import ims.pathways.vo.ExternalEventMappingVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.lookups.PathwaysDetail;
import ims.pathways.vo.lookups.PathwaysGroup;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

public class BookingConfirmationImpl extends DTODomainImplementation implements BookingConfirmation
{
	private static final org.apache.log4j.Logger LOG = ims.utils.Logging.getLogger(BookingConfirmationImpl.class);

	private static final long serialVersionUID = 1L;
	
	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.dto.DTOLookupServiceImpl.class;
	}
	
	/** wdev-6628
	 * Look for an existing patient journey for the given rkey.  If one found, instantiate an event
	 * wdev-8873 - please note that this method is called from ClinicViewCancel and RebookingConfirmation
	 * as well as from the BookingConfirmation Logic
	 */
	public void instantiateEvent(String rkey, String firstApptId, String firstApptDt, String activity, String callerSource, EpisodeOfCareRefVo episode) throws DomainInterfaceException, StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		
		// WDEV-13403
		// If rkey is null, we can try to get the value from the EpisodeOfCare
		if (rkey == null && episode != null)
		{
			EpisodeOfCare domEpis = (EpisodeOfCare) factory.getDomainObject(EpisodeOfCare.class, episode.getID_EpisodeOfCare());
			if (domEpis != null)
			{
				Referral domRef = domEpis.getCurrentReferral();
				if (domRef != null && domRef.getExtReferralKey() != null)
					rkey = domRef.getExtReferralKey();
			}
		}
		
		if (rkey == null)
		{
			throw new DomainInterfaceException("RKEY Value not provided and not found for this episode");
		}
		
		String hql = " select j from PatientPathwayJourney j, Referral r where r.extReferralKey = :rkey and j.referral = r.id";
		ArrayList<String> names = new ArrayList<String>();
		ArrayList<String> values = new ArrayList<String>();

				names.add("rkey");
		values.add(rkey);
		List l = factory.find(hql, names, values);
		if (l == null || l.size() == 0)
			return;
		if (l.size() > 1)
			throw new DomainInterfaceException("More than one PatientPathwayJourney found for this referral - cannot send event (" + rkey + ")");
		
		
		PatientJourneyVo voJourney = PatientJourneyVoAssembler.create((PatientPathwayJourney) l.get(0));
		PatientEventVo patientEvent = new PatientEventVo();
		patientEvent.setActionCode("UP");
		if (callerSource == null)
			patientEvent.setDescription("Event sent from Scheduling Booking Confirmation Screen"); 
		else
			patientEvent.setDescription(callerSource);
		
		patientEvent.setEventDateTime(new DateTime());
		patientEvent.setJourney(voJourney);
		patientEvent.setMessageId("FromMaxims");
		patientEvent.setExternalEventId(Integer.valueOf(firstApptId));
		patientEvent.setPatient(voJourney.getPatient());
		try {
			patientEvent.setScheduledDate(new DateTime(firstApptDt));
		} catch (ParseException e) {
			LOG.error("Invalid date specified for FirstApptDt = " + firstApptDt);
		}

		// Get the PAS Provider System
		ProviderSystemVo voProv = ProviderSystemVoAssembler.create(ProviderSystem.getProviderSystemFromHl7Application(factory, "HEARTS"));
		if (voProv == null)
		{
			throw new DomainInterfaceException("Provider System not found with HL7App = HEARTS");
		}
		
		// Get the lookup with the external mapping the same as the negative value for ACTIVITY
		// As this impl uses dto for lookupService, we want to get the localLookupService too in order to get the PathwaysDetails value
		ims.domain.lookups.LookupService localLookupService;
		try {
			localLookupService = (ims.domain.lookups.LookupService) DomainImplFlyweightFactory.getInstance().create(ims.domain.lookups.impl.LookupServiceImpl.class, getDomainFactory().getDomainSession(), getDomainFactory());
		} catch (InstantiationException e) 
		{
			throw new DomainInterfaceException("InstantiationException occurred creating localLookupService - " + e.getMessage(), e);
		} catch (IllegalAccessException e) {
			throw new DomainInterfaceException("IllegalAccessException occurred creating localLookupService - " + e.getMessage(), e);		}
		
		PathwaysDetail pthDetailLkp =(PathwaysDetail) localLookupService.getLocalLookup(PathwaysDetail.class, PathwaysDetail.TYPE_ID, voProv.getCodeSystem().getText(), activity);
		if (pthDetailLkp == null)
		{
			throw new DomainInterfaceException("PathwaysDetails lookup not found for activity " + activity);
		}
		
		
		HL7PathwayIf impl = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
		
		// Get the External Event
		ExternalEventMappingVo extMap = new ExternalEventMappingVo();
		extMap.setDetail(pthDetailLkp);
		extMap.setGroup(PathwaysGroup.CPT);
		extMap.setProviderSystem(voProv);
		ExternalEventMappingVo extEvt = impl.getExternalEventMappings(extMap);
		if (extEvt == null)
		{
			throw new DomainInterfaceException("ExternalEventMapping not found for CPT and Pathways Details " + pthDetailLkp.getText());
		}
		
		// Get the Actual Event
		EventVo event = impl.getEventByExternalMappings(extEvt);
		if (event == null)
		{
			throw new DomainInterfaceException("Event not found for ExternalEventMapping - "+ extEvt.getID_ExternalEventMapping());
		}
		patientEvent.setEvent(event);
		patientEvent.setExternalEvent(extEvt);
		
		impl.instantiatePatientEvent(patientEvent);
	}

	/**
	 * WDEV-13261
	 * List EpisodeOfCare records for the given patient
	 */
	public EpisodeofCareShortVoCollection listEpisodesForPatient(PatientRefVo patient) 
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> names = new ArrayList<String>();
		ArrayList values = new ArrayList();

		names.add("patient");
		values.add(patient.getID_Patient());

		List  lst = factory.find("select epis from EpisodeOfCare epis join epis.careSpell cs left join epis.currentStatus as currentStatus where (cs.patient.id = :patient and (currentStatus is null or currentStatus.status.id <> -2218))", names, values); //WDEV-14326
		if (lst != null && lst.size() > 0)
			return EpisodeofCareShortVoAssembler.createEpisodeofCareShortVoCollectionFromEpisodeOfCare(lst);
		return null;
	}

	public SchedActivityVoCollection getSchedActivities() 
	{
		DomainFactory factory = getDomainFactory();

		List<?> schList = factory.find("from SchedActivity");
		
		if(schList == null || schList.size() == 0)
			return null;
		
		return SchedActivityVoAssembler.createSchedActivityVoCollectionFromSchedActivity(schList);
	}

	//WDEV-15168
	public PatientApptDiaryVoCollection listPatientAppts(PatientRefVo patient, Date fromDate, Date toDate, Boolean activeOnly)
	{
		PatientDiary diaryImpl = (PatientDiary) getDomainImpl(PatientDiaryImpl.class);
		return diaryImpl.listPatientAppts(patient, fromDate, toDate, activeOnly);
	}
	
}
