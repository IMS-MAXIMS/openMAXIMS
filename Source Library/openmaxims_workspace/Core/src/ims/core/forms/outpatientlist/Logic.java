//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Neil McAnaspie using IMS Development Environment (version 1.45 build 2385.22037)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.core.forms.outpatientlist;

import ims.configuration.gen.ConfigFlag;
import ims.core.helper.DocumentHelper;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.vo.ClinicLiteVoCollection;
import ims.core.vo.ColumnSortOrderVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MedicLiteVo;
import ims.core.vo.MedicLiteVoCollection;
import ims.core.vo.MedicVo;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.OutPatientListSearchCriteriaVo;
import ims.core.vo.OutPatientListVo;
import ims.core.vo.OutPatientListVoCollection;
import ims.core.vo.PatientDocumentStatusVo;
import ims.core.vo.PatientDocumentStatusVoCollection;
import ims.core.vo.PatientDocumentVo;
import ims.core.vo.PatientIdCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.ServerDocumentVo;
import ims.core.vo.lookups.DocumentStatus;
import ims.core.vo.lookups.FileType;
import ims.core.vo.lookups.MedicGrade;
import ims.core.vo.lookups.PatIdType;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.Control;
import ims.framework.FormName;
import ims.framework.MessageButtons;
import ims.framework.MessageIcon;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.PartialDate;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.Comparator;

public class Logic extends BaseLogic
{
	private static final long	serialVersionUID	= 1L;
	
	private static final int IDENTIFIER_COLUMN = 0;
	private static final int SURNAME_COLUMN = 1;
	private static final int FORENAME_COLUMN = 2;
	private static final int SEX_COLUMN = 3;
	private static final int DOB_COLUMN = 4;
	private static final int AGE_COLUMN = 5;
	private static final int CLINIC_COLUMN = 6;
	private static final int SPECIALTY_COLUMN = 7;
	private static final int CLINIC_DATE_COLUMN = 8;
	
	private String errorS = null;

	@Override
	protected void onContextMenuItemClick(int menuItemID, Control sender) throws PresentationLogicException
	{
		switch (menuItemID)
		{
			case GenForm.ContextMenus.CoreNamespace.OutpatientList.VIEW_DEMOGRAPHICS:
				viewDemographics();
				break;

			case GenForm.ContextMenus.CoreNamespace.OutpatientList.NEW_DOCUMENT:
				createNewDocument();
				break;
		}
	}


	private void createNewDocument()
	{
		// Get selected value
		OutPatientListVo outpatient = form.grdOutPatient().getValue();
		
		form.getGlobalContext().Core.setPatientShort(outpatient != null && outpatient.getPasEvent() != null && outpatient.getPasEvent().getPatient() != null ? outpatient.getPasEvent().getPatient() : null);

		engine.open(form.getForms().Core.PatientCorrespondenceTemplates);
	}


	private void viewDemographics()
	{
		// Get selected value
		OutPatientListVo outpatient = form.grdOutPatient().getValue();
		
		form.getGlobalContext().Core.setPatientShort(outpatient != null && outpatient.getPasEvent() != null && outpatient.getPasEvent().getPatient() != null ? outpatient.getPasEvent().getPatient() : null);
		
		engine.open(ConfigFlag.UI.DEMOGRAPHICS_FORM.getValue());
	}

	
	protected void onImbClearClick() throws ims.framework.exceptions.PresentationLogicException
	{
		form.getGlobalContext().Core.setSelectingPatientForm(null);
		
		form.getGlobalContext().Core.setPatientShort(null);
		form.getGlobalContext().Core.setPatientToBeDisplayed(null);
		form.getGlobalContext().Core.setOutpatientAttendanceForOrder(null);
		form.getGlobalContext().Core.setCurrentCareContext(null);

		clearInstanceControls();
		
		updateControlsState();
	}

	private void clearInstanceControls()
	{
		clearClinicCombo();
		form.qmbClinic().setEnabled(false);
		form.cmbLocation().setValue(null);
		clearConsultantCombo();
		form.dteClinic().setValue(null);
		clearOutPatientList();
		form.cmbSpecialty().setValue(null);
		form.getGlobalContext().Core.setOutPatientSearchCriteria(null);

	}

	private void clearOutPatientList()
	{
		form.grdOutPatient().getRows().clear();
		form.grdOutPatient().setValue(null);

	}

	private void clearConsultantCombo()
	{
		form.qmbConsultant().clear();

	}

	protected void onImbSearchClick() throws ims.framework.exceptions.PresentationLogicException
	{
		form.getGlobalContext().Core.setPatientShort(null);
		form.getGlobalContext().Core.setPatientToBeDisplayed(null);
		form.getGlobalContext().Core.setOutpatientAttendanceForOrder(null);
		form.getGlobalContext().Core.setCurrentCareContext(null);
		form.getGlobalContext().Core.setSelectingPatientForm(null);
		
		search();
		
		updateControlsState();
	}

	private void search()
	{

		clearOutPatientList();

		if (form.dteClinic().getValue() == null || (form.qmbClinic().getValue() == null && form.qmbConsultant().getValue() == null))
		{
			engine.showMessage("Valid search criteria must be specified - Please enter a Clinic Date and a Clinic and/or Consultant");
			return;
		}

		
		OutPatientListVoCollection outpatientAttendances = domain.listOutpatients(form.qmbClinic().getValue(), form.qmbConsultant().getValue(), form.cmbSpecialty().getValue(), form.dteClinic().getValue());

		if (outpatientAttendances == null || outpatientAttendances.size() == 0)
		{
			engine.showMessage("No matching patients found.");
			clearOutPatientList();
			return;
		}
		
		populateOutPatientList(outpatientAttendances);
		
		OutPatientListSearchCriteriaVo searchCriteria = form.getGlobalContext().Core.getOutPatientSearchCriteria();
		
		if (searchCriteria != null && searchCriteria.getColumnSortOrder() != null)
		{
			setSortOrderForColumn(searchCriteria.getColumnSortOrder().getColumnId(), searchCriteria.getColumnSortOrder().getSortOrder());
		}

	}

	private void setSortOrderForColumn(Integer columnId, Integer sortOrderId)
	{
		SortOrder order;
		
		if (sortOrderId == 1) // 1 is ascending but for the form to work correct we need to reverse this
			order = SortOrder.DESCENDING;
		else
			order = SortOrder.ASCENDING;
		
		if (IDENTIFIER_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderIdentifier(order);
			sortColumn(IDENTIFIER_COLUMN);
		}
		else if (SURNAME_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderSurname(order);
			sortColumn(SURNAME_COLUMN);
		}
		else if (FORENAME_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderForename(order);
			sortColumn(FORENAME_COLUMN);
		}
		else if (SEX_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderSex(order);
			sortColumn(SEX_COLUMN);
		}
		else if (DOB_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderDOB(order);
			sortColumn(DOB_COLUMN);
		}
		else if (AGE_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderAge(order);
			sortColumn(AGE_COLUMN);
		}
		else if (CLINIC_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderClinic(order);
			sortColumn(CLINIC_COLUMN);
		}
		else if (SPECIALTY_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderSpecialty(order);
			sortColumn(SPECIALTY_COLUMN);
		}
		else if (CLINIC_DATE_COLUMN == columnId)
		{
			form.getLocalContext().setSortOrderDate(order);
			sortColumn(CLINIC_DATE_COLUMN);
		}
	}


	private void populateOutPatientList(OutPatientListVoCollection outpatientAttendances)
	{
		clearOutPatientList();

		if (outpatientAttendances == null || outpatientAttendances.size() == 0)
		{
			return;
		}

		storeSearchCriteria();
		
		GenForm.grdOutPatientRow row = null;
			
		for (OutPatientListVo outpatient : outpatientAttendances)
		{
			if (outpatient != null && outpatient.getPasEventIsNotNull() && outpatient.getPasEvent().getPatientIsNotNull())
			{
				PatientShort patient = outpatient.getPasEvent().getPatient();

				row = form.grdOutPatient().getRows().newRow();
				
				if (patient.getNameIsNotNull())
				{
					row.setcolForename(patient.getName().getForename());
					row.setcolSurname(patient.getName().getSurname());
				}

				ims.core.vo.PatientId voPatId = patient.getDisplayId();
				if (voPatId != null)
					row.setcolHospnum(voPatId.getValue());
				
				//WDEV-16710
				StringBuffer patientIdentifiers = new StringBuffer();
				PatientIdCollection identifiers = patient.getIdentifiers();
				
				if (identifiers != null)
				{
					for (int a = 0; a < identifiers.size(); a++)
					{
						patientIdentifiers.append("<b>" + identifiers.get(a).getType().toString() + ":</b> " + identifiers.get(a).getValue() + "<br>");
					}
				}
				
				row.setTooltipForcolHospnum(patientIdentifiers.toString());

				if (patient.getDobIsNotNull())
					row.setcolDob(patient.getDob().toString());

				if (patient.getAgeIsNotNull())
					row.setColAge(patient.getAge().toString());
				else
				{
					//WDEV-12716
					Integer age = patient.calculateAge();
					if (age != null) row.setColAge(age.toString());
				}

				if (patient.getSexIsNotNull())
					row.setcolSex(patient.getSex().getText());

				if (outpatient.getClinicIsNotNull())
					row.setcolClinic(outpatient.getClinic().getClinicName());

				if (outpatient.getPasEvent() != null && outpatient.getPasEvent().getSpecialty() != null)
					row.setcolSpecialty(outpatient.getPasEvent().getSpecialty().getText());

				if (outpatient.getAppointmentDateTimeIsNotNull())
					row.setcolClinicDate(outpatient.getAppointmentDateTime().toString());

				if (patient.getIsDead() != null && patient.getIsDead().booleanValue())
					row.setBackColor(ConfigFlag.UI.RIP_COLOUR.getValue());

				row.setValue(outpatient);
			}
		}
	}

	private void storeSearchCriteria()
	{
		OutPatientListSearchCriteriaVo voOutPatSearch;
		
		if (form.getGlobalContext().Core.getOutPatientSearchCriteria() != null)
		{
			voOutPatSearch = (OutPatientListSearchCriteriaVo) form.getGlobalContext().Core.getOutPatientSearchCriteria().clone();
		}
		else
			voOutPatSearch = new OutPatientListSearchCriteriaVo();
		
		if(form.getLocalContext().getUserAccessVoIsNotNull())
		{
			voOutPatSearch.setClinic(form.cmbClinic().getValue());
			voOutPatSearch.setConsultant(form.cmbConsultant().getValue());
		}
		else
		{
			voOutPatSearch.setClinic(form.qmbClinic().getValue());
			voOutPatSearch.setConsultant(form.qmbConsultant().getValue());
		}
		
		voOutPatSearch.setClinicDate(form.dteClinic().getValue());
		voOutPatSearch.setLocation(form.cmbLocation().getValue());
		voOutPatSearch.setSpecialty(form.cmbSpecialty().getValue());
		form.getGlobalContext().Core.setOutPatientSearchCriteria(voOutPatSearch);

	}

	protected void onFormOpen() throws PresentationLogicException
	{
		initialize();
		open();

	}

	private void open()
	{
		if (form.getGlobalContext().Core.getOutPatientSearchCriteriaIsNotNull())
		{
			displaySearchCriteria();
			search();
		}

	}

	private void displaySearchCriteria()
	{
		form.dteClinic().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getClinicDate());
		form.qmbConsultant().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getConsultant());
		if (form.qmbConsultant().getValue() == null && form.getGlobalContext().Core.getOutPatientSearchCriteria().getConsultantIsNotNull())
		{
			form.qmbConsultant().newRow(form.getGlobalContext().Core.getOutPatientSearchCriteria().getConsultant(), form.getGlobalContext().Core.getOutPatientSearchCriteria().getConsultant().toString());
			form.qmbConsultant().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getConsultant());
		}

		form.cmbLocation().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getLocation());
		form.cmbSpecialty().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getSpecialty());
		if (form.cmbLocation().getValue() != null && form.getGlobalContext().Core.getOutPatientSearchCriteria().getClinicIsNotNull())
		{
			form.qmbClinic().newRow(form.getGlobalContext().Core.getOutPatientSearchCriteria().getClinic(), form.getGlobalContext().Core.getOutPatientSearchCriteria().getClinic().getClinicName());
			form.qmbClinic().setValue(form.getGlobalContext().Core.getOutPatientSearchCriteria().getClinic());
		}

	}

	private void initialize()
	{
		form.getGlobalContext().Core.setOutpatientAttendanceForOrder(null);
		
		form.qmbClinic().setEnabled(false);

		PatIdType dispIdType = PatIdType.getNegativeInstance(ConfigFlag.UI.DISPLAY_PATID_TYPE.getValue());
		form.grdOutPatient().setcolHospnumCaption(dispIdType.getText());
		loadClinicLocationCombo();

		form.qmbClinic().setVisible(true);
		form.qmbClinic().setEnabled(true);
		form.cmbClinic().setVisible(false);
		form.qmbConsultant().setVisible(true);
		form.cmbConsultant().setVisible(false);
			// WDEV-2847
		populateQmbConsultants();
	
		form.dteClinic().setValue(new Date());

	}

	private void loadClinicLocationCombo()
	{
		LocationLiteVoCollection voLocationLiteColl = domain.listActiveHospitalsLite();
		if (voLocationLiteColl != null)
		{
			String currentLocName = "";
			for (int i = 0; i < voLocationLiteColl.size(); i++)
			{
				form.cmbLocation().newRow(voLocationLiteColl.get(i), voLocationLiteColl.get(i).getName().toString());
				//WDEV-4585
				
				if (engine.getCurrentLocation() != null)
				{
					// WDEV-2847
					currentLocName = engine.getCurrentLocation().getName();
					if (currentLocName.equals(voLocationLiteColl.get(i).getName()))
					{
						form.cmbLocation().setValue(voLocationLiteColl.get(i));
						form.qmbClinic().setEnabled(true);
					}
				}
			}

		}

	}

	protected void onGrdOutPatientSelectionChanged() throws PresentationLogicException
	{
		// Set form selecting the Patient as Outpatient List
		form.getGlobalContext().Core.setSelectingPatientForm(engine.getFormName());

		OutPatientListVo outpatient = form.grdOutPatient().getValue();
		
		if (outpatient != null && outpatient.getPasEvent() != null && outpatient.getPasEvent().getPatient() != null)
		{
			form.getGlobalContext().Core.setPatientShort(outpatient.getPasEvent().getPatient());
			form.getGlobalContext().Core.setPatientToBeDisplayed(outpatient.getPasEvent().getPatient());
			
			form.getGlobalContext().Core.setOutpatientAttendanceForOrder(outpatient);
			
			// Update CareContext if one exists for the Pas Event
			form.getGlobalContext().Core.setCurrentCareContext(domain.getContextForPasEvent(outpatient.getPasEvent()));
		}
		
		updateControlsState();

		if (Boolean.FALSE.equals(ConfigFlag.UI.OUTPAT_CREATE_CORRESPONDENCE_DETAILS.getValue()))
		{
			viewDemographics();
		}
	}

	protected void onCmbLocationValueChanged() throws PresentationLogicException
	{
		if (form.cmbLocation().getValue() != null)
			form.qmbClinic().setEnabled(true);
		else
			form.qmbClinic().setEnabled(false);
		
		form.qmbClinic().clear();//WDEV-15039 WDEV-17679

	}

	private void clearClinicCombo()
	{
		form.qmbClinic().clear();

	}

	protected void onQmbConsultantTextSubmited(String value) throws PresentationLogicException
	{
		clearConsultantCombo();
		if (value != null)
		{
			MedicLiteVoCollection voMedicColl = domain.listActiveMedics(value);
			if (voMedicColl != null)
			{
				for (int i = 0; i < voMedicColl.size(); i++)
				{
					MedicLiteVo med = voMedicColl.get(i);
					form.qmbConsultant().newRow(med, med.toString());
				}
			}
			if (voMedicColl != null && voMedicColl.size() == 1)
				form.qmbConsultant().setValue(voMedicColl.get(0));
			else if (voMedicColl != null && voMedicColl.size() > 1)
				form.qmbConsultant().showOpened();
		}
	}

	// WDEV-2847
	private void populateQmbConsultants()
	{
		MedicLiteVo voMedic = new MedicLiteVo();
		//WDEV-8199
		HcpLiteVo currHcpUser = (HcpLiteVo) domain.getHcpLiteUser();
		
		if (domain.getHcpUser() instanceof MedicVo && MedicGrade.CONS.equals(((MedicVo)domain.getHcpUser()).getGrade()))
		{
			voMedic.setMos(currHcpUser.getMos());
			voMedic.setID_Hcp(currHcpUser.getID_Hcp());//wdev-10188
			form.qmbConsultant().newRow(voMedic, voMedic.getName().toString());
			form.qmbConsultant().setValue(voMedic);
		}
	}

	protected void onQmbClinicTextSubmited(String value) throws PresentationLogicException
	{
		if (form.cmbLocation().getValue() == null)
		{
			engine.showMessage("Please select a Location");
			form.cmbLocation().setFocus();
			return;
		}
		loadClinicsbyLocation(form.cmbLocation().getValue(), value);

	}

	private void loadClinicsbyLocation(LocationLiteVo voLocLite, String strClinicName)
	{
		clearClinicCombo();

		if (voLocLite != null)
		{
			ClinicLiteVoCollection voClinicLiteColl = domain.listClinicsforLocation(voLocLite, strClinicName);

			if (voClinicLiteColl != null)
			{
				for (int i = 0; i < voClinicLiteColl.size(); i++)
				{
					form.qmbClinic().newRow(voClinicLiteColl.get(i), voClinicLiteColl.get(i).getClinicName());
				}
				if (voClinicLiteColl.size() == 1)
					form.qmbClinic().setValue(voClinicLiteColl.get(0));
				else if (voClinicLiteColl.size() > 1)
					form.qmbClinic().showOpened();
			}
		}

	}


	private void updateControlsState()
	{
		form.getContextMenus().Core.getOutpatientListVIEW_DEMOGRAPHICSItem().setVisible(form.grdOutPatient().getSelectedRow() != null && Boolean.TRUE.equals(ConfigFlag.UI.OUTPAT_CREATE_CORRESPONDENCE_DETAILS.getValue()));
		form.getContextMenus().Core.getOutpatientListNEW_DOCUMENTItem().setVisible(form.grdOutPatient().getSelectedRow() != null && Boolean.TRUE.equals(ConfigFlag.UI.OUTPAT_CREATE_CORRESPONDENCE_DETAILS.getValue()));
	}

	@Override
	protected void onGrdOutPatientGridHeaderClicked(int column) throws PresentationLogicException
	{
		sortColumn(column);
		
	}

	//WDEV-18647
	private void sortColumn(int column)
	{
		OutPatientListVoCollection values = form.grdOutPatient().getValues();
		form.grdOutPatient().getRows().clear();
		
		switch (column)
		{
			case IDENTIFIER_COLUMN:
				form.getLocalContext().setSortOrderIdentifier(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderIdentifier()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new IdentifierComparator(form.getLocalContext().getSortOrderIdentifier()));
				addColumnSortToSearchCriteriaGC(IDENTIFIER_COLUMN, form.getLocalContext().getSortOrderIdentifier());
			break;
			case SURNAME_COLUMN:
				form.getLocalContext().setSortOrderSurname(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderSurname()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new SurnameComparator(form.getLocalContext().getSortOrderSurname()));
				addColumnSortToSearchCriteriaGC(SURNAME_COLUMN, form.getLocalContext().getSortOrderSurname());
			break;
			case FORENAME_COLUMN:
				form.getLocalContext().setSortOrderForename(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderForename()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new ForenameComparator(form.getLocalContext().getSortOrderForename()));
				addColumnSortToSearchCriteriaGC(FORENAME_COLUMN, form.getLocalContext().getSortOrderForename());
			break;
			case SEX_COLUMN:
				form.getLocalContext().setSortOrderSex(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderSex()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new SexComparator(form.getLocalContext().getSortOrderSex()));
				addColumnSortToSearchCriteriaGC(SEX_COLUMN, form.getLocalContext().getSortOrderSex());
			break;
			case DOB_COLUMN:
				form.getLocalContext().setSortOrderDOB(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderDOB()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new DOBComparator(form.getLocalContext().getSortOrderDOB()));
				addColumnSortToSearchCriteriaGC(DOB_COLUMN, form.getLocalContext().getSortOrderDOB());
			break;
			case AGE_COLUMN:
				form.getLocalContext().setSortOrderAge(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderAge()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new AgeComparator(form.getLocalContext().getSortOrderAge()));
				addColumnSortToSearchCriteriaGC(AGE_COLUMN, form.getLocalContext().getSortOrderAge());
			break;
			case CLINIC_COLUMN:
				form.getLocalContext().setSortOrderClinic(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderClinic()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new ClinicComparator(form.getLocalContext().getSortOrderClinic()));
				addColumnSortToSearchCriteriaGC(CLINIC_COLUMN, form.getLocalContext().getSortOrderClinic());
			break;
			case SPECIALTY_COLUMN:
				form.getLocalContext().setSortOrderSpecialty(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderSpecialty()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new SpecialtyComparator(form.getLocalContext().getSortOrderSpecialty()));
				addColumnSortToSearchCriteriaGC(SPECIALTY_COLUMN, form.getLocalContext().getSortOrderSpecialty());
			break;
			case CLINIC_DATE_COLUMN:
				form.getLocalContext().setSortOrderDate(SortOrder.ASCENDING.equals(form.getLocalContext().getSortOrderDate()) ? SortOrder.DESCENDING : SortOrder.ASCENDING);
				values.sort(new DateComparator(form.getLocalContext().getSortOrderDate()));
				addColumnSortToSearchCriteriaGC(CLINIC_DATE_COLUMN, form.getLocalContext().getSortOrderDate());
			break;
			default:
			break;
		}
		
		populateOutPatientList(values);
		
	}


	private void addColumnSortToSearchCriteriaGC(int identifierColumnId, SortOrder sortOrder)
	{
		if (form.getGlobalContext().Core.getOutPatientSearchCriteria() == null)
			return;
		
		ColumnSortOrderVo columnSortOrder = new ColumnSortOrderVo();
		
		columnSortOrder.setColumnId(identifierColumnId);
		
		if (SortOrder.ASCENDING.equals(sortOrder))
			columnSortOrder.setSortOrder(1);
		else
			columnSortOrder.setSortOrder(-1);
		
		form.getGlobalContext().Core.getOutPatientSearchCriteria().setColumnSortOrder(columnSortOrder);
		
	}
	
	public class IdentifierComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public IdentifierComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public IdentifierComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo )
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().getDisplayId() != null) ? ps1.getPasEvent().getPatient().getDisplayId().getValue():null;
			}
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().getDisplayId() != null) ? ps2.getPasEvent().getPatient().getDisplayId().getValue():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class SurnameComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public SurnameComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public SurnameComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo )
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().getName() != null 
						&& ps1.getPasEvent().getPatient().getName() != null) ? ps1.getPasEvent().getPatient().getName().getSurname():null;
			}
			
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().getName() != null 
						&& ps2.getPasEvent().getPatient().getName() != null) ? ps2.getPasEvent().getPatient().getName().getSurname():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class ForenameComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public ForenameComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public ForenameComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().getName() != null 
						&& ps1.getPasEvent().getPatient().getName() != null) ? ps1.getPasEvent().getPatient().getName().getForename():null;
			}
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().getName() != null 
						&& ps2.getPasEvent().getPatient().getName() != null) ? ps2.getPasEvent().getPatient().getName().getForename():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class SexComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public SexComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public SexComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().getSex() != null ) 
						? ps1.getPasEvent().getPatient().getSex().getText():null;
			}
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().getSex() != null ) 
						? ps2.getPasEvent().getPatient().getSex().getText():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class DOBComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public DOBComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public DOBComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			PartialDate rez1 = null;
			PartialDate rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().getDob() != null ) 
						? ps1.getPasEvent().getPatient().getDob():null;
			}
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().getDob() != null ) 
						? ps2.getPasEvent().getPatient().getDob():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareTo(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class AgeComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public AgeComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public AgeComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			Integer rez1 = null;
			Integer rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getPatient() != null && ps1.getPasEvent().getPatient().calculateAgeText() != null && ps1.getPasEvent().getPatient().calculateAgeText() != "-") ? Integer.parseInt(ps1.getPasEvent().getPatient().calculateAgeText()):null;
			}
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getPatient() != null && ps2.getPasEvent().getPatient().calculateAgeText() != null && ps2.getPasEvent().getPatient().calculateAgeText() != "-") ? Integer.parseInt(ps2.getPasEvent().getPatient().calculateAgeText()):null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareTo(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class ClinicComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public ClinicComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public ClinicComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = ps1.getClinic() != null ? ps1.getClinic().getClinicName():null;
			}
			
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = ps2.getClinic() != null ? ps2.getClinic().getClinicName():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class SpecialtyComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public SpecialtyComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public SpecialtyComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			String rez1 = null;
			String rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = (ps1.getPasEvent() != null && ps1.getPasEvent().getSpecialty() != null) ? ps1.getPasEvent().getSpecialty().getText():null;
			}
			
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = (ps2.getPasEvent() != null && ps2.getPasEvent().getSpecialty() != null) ? ps2.getPasEvent().getSpecialty().getText():null;
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareToIgnoreCase(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}
	
	public class DateComparator implements Comparator<Object>
	{
		private int direction = 1;
		
		public DateComparator()
		{
			this(SortOrder.ASCENDING);
		}
		
		public DateComparator(SortOrder order)
		{
			if (order == SortOrder.DESCENDING)
				direction = -1;
			
		}
		public int compare(Object ob1, Object ob2) 
		{
			DateTime rez1 = null;
			DateTime rez2 = null;
			
			if(ob1 instanceof OutPatientListVo)
			{
				OutPatientListVo ps1 = (OutPatientListVo)ob1;
				rez1 = ps1.getAppointmentDateTime();
			}
			
			if(ob2 instanceof OutPatientListVo)
			{
				OutPatientListVo ps2 = (OutPatientListVo)ob2;
				rez2 = ps2.getAppointmentDateTime();
			}
			
			if(rez1 != null && rez2 != null)
				return  rez1.compareTo(rez2)*direction;
			
			if(rez1 != null && rez2 == null)
				return  direction;
			
			if(rez2 != null && rez1 == null)
				return (-1)*direction;
			
			return 0;
		}
	}

	@Override
	protected void onFormDialogClosed(FormName formName, DialogResult result) throws PresentationLogicException
	{
		if (formName.equals(form.getForms().Core.PatientCorrespondenceTemplates))
		{
    		if(result.equals(DialogResult.OK))
    		{
    			form.getLocalContext().setSelectedDocument(form.getGlobalContext().Core.getPatientCorrespondence());
    			
    			editInstance();
    		}
		}
		
		if (formName.equals(form.getForms().Core.LocalSettingsDialog))
		{
			if (DialogResult.OK.equals(result) && form.getLocalContext().getShouldOpenAfterPathIsSetIsNotNull() && form.getLocalContext().getShouldOpenAfterPathIsSet())
			{
				form.getLocalContext().setShouldOpenAfterPathIsSet(false);
				String path = engine.getLocalSettings().getWordEditorPath();

				if (path != null && path.length() > 0)
				{
					openDocForEditFromWorkArea(form.getLocalContext().getSelectedDocument());
				}
			}
			
			return;
		}
		if (formName.equals(form.getForms().Core.PatientDocumentEdit))
		{
			form.getLocalContext().setSelectedDocument(form.getGlobalContext().Core.getPatientCorrespondence());
			
			if (result.equals(DialogResult.OK) && form.getGlobalContext().Core.getNewDocumentStatus() != null)
			{
				changeStatus(form.getGlobalContext().Core.getNewDocumentStatus(),form.getGlobalContext().Core.getPatientCorrespondence(), true, false);
			}
			else if (result.equals(DialogResult.ABORT) && form.getGlobalContext().Core.getNewDocumentStatus() != null)
			{
				PatientDocumentVo patientDocument = null;
				try
				{
					patientDocument = domain.getPatientDocument(form.getLocalContext().getSelectedDocument());
				}	
				catch (StaleObjectException e)
				{
					engine.showErrors(new String[] { ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue() });
					form.getLocalContext().setSelectedDocument(null);
					open();
					return;
				}
				if(patientDocument != null && (patientDocument.getIsRIE() == null || (patientDocument.getIsRIE() != null &&  !patientDocument.getIsRIE())))
				{					
					form.getLocalContext().setSelectedDocument(patientDocument);					
					changeStatus(form.getGlobalContext().Core.getNewDocumentStatus(),form.getLocalContext().getSelectedDocument(), true, false);
				}
				else
				{
					engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue(), "Unable to change status", MessageButtons.OK, MessageIcon.ERROR);
					open();
				}
			}
		}
	}

	private PatientDocumentVo changeStatus(DocumentStatus newStatus, PatientDocumentVo doc, boolean showErrors,boolean isBatch)
	{	
		if (doc == null)
			throw new CodingRuntimeException("There is no document selected to change status for");
		
		errorS = null;

		PatientDocumentStatusVo newDocStatus = new PatientDocumentStatusVo();
		newDocStatus.setCorrespondenceStatus(newStatus);
		newDocStatus.setRecordingDateTime(new DateTime());
		newDocStatus.setRecordingUser((MemberOfStaffLiteVo) domain.getMosUser());

		if (!doc.getDocumentStatusHistoryIsNotNull())
		{
			doc.setDocumentStatusHistory(new PatientDocumentStatusVoCollection());
		}
		doc.getDocumentStatusHistory().add(newDocStatus);
		doc.setCurrentDocumentStatus(newDocStatus);

		String[] errors = doc.validate();
		if (errors != null && errors.length > 0 )
		{
			errorS = "Could not change status.\nThe document is not valid";
			
			if (showErrors)
				engine.showErrors(errors);
			
			return null;
		}
		
		PatientDocumentVo patDoc = null;
		if (newStatus.equals(DocumentStatus.READY_TO_SEND))
		{
			if (isStale(doc))
			{
				errorS ="Could not finalise document.\nThe document has been modified by another user";
				if (showErrors)
				{
					engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue(), "Unable to change status", MessageButtons.OK, MessageIcon.ERROR);
					open();
				}
				
				return null;
			}
			patDoc = lockPatientDoc(doc, false, null);
			if (patDoc == null)
			{
				errorS = "Could not finalise document";
				if (showErrors)
				{
					engine.showErrors(new String[] { errorS});
					open();
				}
				
				return null;
			}
		}
		else
		{
			try
			{
				patDoc = domain.savePatientDocument(doc);
			}
			catch (StaleObjectException e)
			{
				errorS= "Could not change status.\nThe document has been modified by another user";
				if (showErrors)
				{
					engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue(), "Unable to change status", MessageButtons.OK, MessageIcon.ERROR);
					open();
				}
				
				return null;
			}
		}

		return patDoc;
	}
	
	private PatientDocumentVo lockPatientDoc(PatientDocumentVo patientDocument, boolean changeToCompleted, DocumentStatus status)
	{
		if (patientDocument == null)
			throw new CodingRuntimeException("Trying to lock null patient document");

		String rtfFileName = null;

		PatientDocumentStatusVo finalS = new PatientDocumentStatusVo();
		if (changeToCompleted && status != null)
		{
			finalS.setCorrespondenceStatus(status);
			finalS.setRecordingDateTime(new DateTime());
			finalS.setRecordingUser((MemberOfStaffShortVo) domain.getMosUser());
		}

		ServerDocumentVo document = patientDocument.getServerDocument();
		String pdfFileName = null;
		if (document != null)
		{
			rtfFileName = document.getFileName();
			pdfFileName = DocumentHelper.convertRtfToPdf(engine, this, rtfFileName, true);
			
			if(pdfFileName == null)
				return null;

			int year  = new DateTime().getDate().getYear();
			int month = new DateTime().getDate().getMonth();
			int day   = new DateTime().getDate().getDay();
						
			document.setFileName(year + "\\" + month + "\\" + day + "\\" + pdfFileName);
			document.setFileType(FileType.PDF);
		}

		patientDocument.setServerDocument(document);
		if (changeToCompleted && status != null)
		{
			if (!patientDocument.getDocumentStatusHistoryIsNotNull())
				patientDocument.setDocumentStatusHistory(new PatientDocumentStatusVoCollection());
			patientDocument.getDocumentStatusHistory().add(finalS);
			patientDocument.setCurrentDocumentStatus(finalS);
		}

		String[] errs = patientDocument.validate();
		if (errs != null && errs.length > 0)
		{
			return null;
		}
		PatientDocumentVo result = null;
		
		try
		{
			if(!DocumentHelper.checkIfPdfFileExist(pdfFileName, rtfFileName))
			{
				int year  = new DateTime().getDate().getYear();
				int month = new DateTime().getDate().getMonth();
				int day   = new DateTime().getDate().getDay();
				DocumentHelper.deleteFile(DocumentHelper.getPDFStorePath() + year + "\\" + month + "\\" + day + "\\" + pdfFileName);
				return null;
			}
		}
		catch (Exception e)
		{
			return null;
		}
		
		try
		{
			result = domain.savePatientDocument(patientDocument);
		}
		catch (StaleObjectException e)
		{
			// Delete converted file (Simulating transaction)
			
			int year  = new DateTime().getDate().getYear();
			int month = new DateTime().getDate().getMonth();
			int day   = new DateTime().getDate().getDay();
			
			DocumentHelper.deleteFile(DocumentHelper.getPDFStorePath() + year + "\\" + month + "\\" + day + "\\" + pdfFileName);
			if (ConfigFlag.UI.CORRESPONDENCE_ARCHIVE_RTF_FILES.getValue())
			{
				DocumentHelper.deleteFile(DocumentHelper.getArchiveStorePath() + year + "\\" + month + "\\" + day + "\\" + pdfFileName.substring(0, pdfFileName.lastIndexOf('.')) + ".rtf");
			}	
			
			e.printStackTrace();
			return null;
		}

		if (rtfFileName != null)
		{
			DocumentHelper.deleteFile(DocumentHelper.getWorkAreaPath() + rtfFileName);
		}
		
		return result;
	}

	private void editInstance()
	{
		form.getLocalContext().setSelectedDocument(checkoutDoc(form.getLocalContext().getSelectedDocument()));
		if (!form.getLocalContext().getSelectedDocumentIsNotNull())
		{
			engine.showErrors(new String[] { errorS });
			open();
			return;
		}
		
		openDocForEditFromWorkArea(form.getLocalContext().getSelectedDocument());
	}
	
	private PatientDocumentVo checkoutDoc(PatientDocumentVo doc)
	{
		validateNonFinalDocument(doc);

		String fileName = doc.getServerDocument().getFileName();
		String sourceFilePath = (DocumentHelper.getWorkAreaPath() + fileName).replace("/", "\\");
		String destinationFilePath = (DocumentHelper.getCheckOutWorkArea() + fileName).replace("/", "\\");
		FileChannel inChan = null;
		FileChannel outChan = null;
		PatientDocumentVo result = null;
		// prepare for read
		try
		{
			try
			{
				inChan = new FileInputStream(sourceFilePath).getChannel();
			}
			catch (FileNotFoundException e)
			{
				
					errorS = "Unable to find file in Document Store";
			
				throw e;
			}

			//It might be a latency issue so if at first if fails , wait a sec and try again
			// create work area document and path
			boolean retry = false;
			boolean success = false;
			while (!success)
			{
				success = true;
				
				File destinationFile = new File(destinationFilePath);
				if (!destinationFile.exists())
					try
				{
						File parentDir = destinationFile.getParentFile();
						if (!parentDir.exists())
							parentDir.mkdirs();
						destinationFile.createNewFile();
				}
				catch (IOException e)
				{
					System.out.println("File does not exist and cannot be created: "+e.getMessage());
					success = false;
					if (retry)
					{
						errorS = "Could not create the document in work area. An I/O error occurred";
						throw e;
					}
				}
				finally
				{
					DocumentHelper.tryClose(outChan);
				}

				// prepare for write
				if (success)
				{
					try
					{
						outChan = new RandomAccessFile(destinationFile, "rw").getChannel();
					}
					catch (FileNotFoundException e)
					{
						System.out.println("File exists but write access cannot be obtained: "+e.getMessage());
						success = false;
						if (retry)
						{
							errorS = "Could not create the document in work area. An I/O error occurred";
							throw e;
						}
					}					
				}
				
				if (!success)
				{
					retry  = true;
					System.out.println("Could not create file. Sleep a sec");
					wait(1000);
				}
			}

			FileLock outLock = null;
			try
			{

				outLock = outChan.tryLock();
			}
			catch (IOException e)
			{
				errorS = "An I/O error occured . Please contact your administrator";
				throw e;
			}
			if (!(outLock != null && outLock.isValid()))
			{
				errorS = "Unable to complete checked out at the moment . Try again later";
				throw new CodingRuntimeException("Lock is null or invalid");
			}

			// save
			doc.setIsLockedForEditing(true);
			doc.setLockedByUser((MemberOfStaffRefVo) domain.getMosUser());
			doc.setLockedOnDateTime(new DateTime());
			doc.validate();

			try
			{
				result = domain.savePatientDocument(doc);
			}
			catch (StaleObjectException e)
			{
				errorS = ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue();
				throw e;

			}

			// Everything is fine . do the copy
			try
			{
				int maxCount = 64 * 1024;
				long size;

				size = inChan.size();

				long position = 0;
				while (position < size)
				{
					position += inChan.transferTo(position, maxCount, outChan);
				}
			}
			catch (IOException e)
			{
				errorS = "An I/O error occured during copy. The file remains checked out";
				throw e;

			}
			finally
			{
				outLock.release();
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			if (isStale(result))
			{
				errorS = ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue();
			}
			if (errorS == null)
			{
				errorS = "An unknown error occured";
			}
			result = null;
		}
		finally
		{
			DocumentHelper.tryClose(inChan);
			DocumentHelper.tryClose(outChan);
		}
		
		return result;
	}
	
	private boolean validateNonFinalDocument(PatientDocumentVo selectedDocument)
	{
		if (selectedDocument == null)
			throw new CodingRuntimeException("Trying to validate null document");
		
		String[] errors = selectedDocument.validate();
		if (errors != null && errors.length > 0)
		{
			throw new CodingRuntimeException("The document is not valid. Posible data corruption");

		}
		if (isDocumentFinal(selectedDocument) || !FileType.DOC.equals(selectedDocument.getServerDocument().getFileType()))
		{
			//This is a stale exception
			engine.showErrors(new String[] { ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue() });
			form.getLocalContext().setSelectedDocument(null);
			open();
			return false;
			
		}
		
		return true;
	}
	
	private boolean isDocumentFinal(PatientDocumentVo value)
	{
		if (value == null || !value.getCurrentDocumentStatusIsNotNull())
			return false;

		return DocumentStatus.COMPLETED.equals(value.getCurrentDocumentStatus().getCorrespondenceStatus()) || DocumentStatus.READY_TO_SEND.equals(value.getCurrentDocumentStatus().getCorrespondenceStatus());
	}
	
	private void openDocForEditFromWorkArea(PatientDocumentVo doc)
	{
		validateNonFinalDocument(doc);
		
		String winPath = engine.getLocalSettings().getWordEditorPath();

		if ((winPath == null || winPath.length() == 0) && ConfigFlag.GEN.AUTODETECT_DOCUMENT_EDITOR.getValue() == false)	
		{
			form.getLocalContext().setShouldOpenAfterPathIsSet(true);
			engine.open(form.getForms().Core.LocalSettingsDialog);
			return;
		}

		String filePath = (DocumentHelper.getCheckOutWorkArea() + doc.getServerDocument().getFileName()).replace("/", "\\");
		
		form.getGlobalContext().Core.setPatientCorrespondence(doc);
		engine.open(form.getForms().Core.PatientDocumentEdit, false);
		
		if(ConfigFlag.GEN.AUTODETECT_DOCUMENT_EDITOR.getValue() == true)
			engine.runExternalApplication(filePath, true, false);
		else
			engine.runExternalApplication(winPath + " " + filePath, false);
	}
	
	private boolean isStale(PatientDocumentVo patientDocument)
	{
		if (patientDocument == null || !patientDocument.getServerDocumentIsNotNull() || !patientDocument.getServerDocument().getFileNameIsNotNull())
			return false;
		File rtfFile = new File(patientDocument.getServerDocument().getFileName());

		if (!rtfFile.exists())
		{
			if (domain.isStaleObjectException(patientDocument))
				return true;
		}

		return false;
	}
}
