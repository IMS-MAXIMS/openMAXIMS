//#############################################################################
//#                                                                           #
//#  Copyright (C) <2014>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.30 build 2046.20208)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.clinical.vo.lookups.DischargeLetterStatus;
import ims.clinical.vo.lookups.EDischargeSummarySection;
import ims.clinical.vo.lookups.EDischargeSummarySectionStatus;
import ims.clinical.vo.lookups.VTEAsessmentStatus;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextHistory;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.domain.objects.DementiaConfiguration;
import ims.core.admin.domain.objects.EmergencyAttendance;
import ims.core.admin.domain.objects.EpisodeOfCareHistory;
import ims.core.admin.pas.domain.objects.AEAttendance;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.BedSpaceStateStatus;
import ims.core.admin.pas.domain.objects.ConsultantStay;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.OutpatientAttendance;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.domain.objects.PendingElectiveAdmission;
import ims.core.admin.pas.domain.objects.PendingEmergencyAdmission;
import ims.core.admin.pas.domain.objects.PendingTransfers;
import ims.core.admin.pas.domain.objects.TransferHistory;
import ims.core.admin.pas.domain.objects.WardStay;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.vo.EmergencyAttendanceRefVo;
import ims.core.clinical.domain.objects.AuthoringInformation;
import ims.core.clinical.domain.objects.Dementia;
import ims.core.clinical.domain.objects.DementiaAssessAndInvestigate;
import ims.core.clinical.domain.objects.DementiaFind;
import ims.core.clinical.domain.objects.DementiaWorklistStatus;
import ims.core.clinical.domain.objects.Procedure;
import ims.core.clinical.domain.objects.VTERiskAssessment;
import ims.core.configuration.domain.objects.PrivateInsuranceCompany;
import ims.core.domain.Demographics;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.scheduler.domain.objects.PatientApptDiary;
import ims.core.vo.AneAttendanceVo;
import ims.core.vo.CareContextInterfaceVo;
import ims.core.vo.DischargedEpisodeVo;
import ims.core.vo.GpLiteToPracticeLiteVo;
import ims.core.vo.InpatientEpisodeVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.MedicWithMappingsLiteVo;
import ims.core.vo.OutPatientAttendanceVo;
import ims.core.vo.PasEventVo;
import ims.core.vo.PatientShort;
import ims.core.vo.PendingElectiveAdmissionHl7Vo;
import ims.core.vo.PendingEmergencyAdmissionVo;
import ims.core.vo.PendingEmergencyAdmissionVoCollection;
import ims.core.vo.PrivateInsuranceCompanyVo;
import ims.core.vo.domain.AneAttendanceVoAssembler;
import ims.core.vo.domain.CareContextInterfaceVoAssembler;
import ims.core.vo.domain.DischargedEpisodeVoAssembler;
import ims.core.vo.domain.ExtendedAdmissionDetailVoAssembler;
import ims.core.vo.domain.InpatientEpisodeVoAssembler;
import ims.core.vo.domain.OutPatientAttendanceVoAssembler;
import ims.core.vo.domain.PasEventVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PendingElectiveAdmissionHl7VoAssembler;
import ims.core.vo.domain.PendingEmergencyAdmissionVoAssembler;
import ims.core.vo.domain.PrivateInsuranceCompanyVoAssembler;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.ElectiveAdmissionStatus;
import ims.core.vo.lookups.EmergencyAdmissionStatus;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.PasEventType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.TaxonomyType;
import ims.correspondence.vo.PasContactVo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.impl.DomainImpl;
import ims.domain.lookups.LookupInstance;
import ims.edischarge.domain.objects.DischargeDetails;
import ims.edischarge.domain.objects.ReadyToLeave;
import ims.edischarge.domain.objects.Summary;
import ims.edischarge.domain.objects.SummaryDetail;
import ims.emergency.domain.objects.EDPartialAdmission;
import ims.emergency.vo.ifEDAttendanceVo;
import ims.emergency.vo.ifInpatientADTVo;
import ims.emergency.vo.domain.ifEDAttendanceVoAssembler;
import ims.emergency.vo.domain.ifInpatientADTVoAssembler;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.DateTime;
import ims.framework.utils.PartialDate;
import ims.framework.utils.Time;
import ims.hl7adtout.domain.objects.InPatientADTMessageQueue;
import ims.hl7adtout.vo.InPatientADTMessageQueueRefVo;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.vo.Appointment_StatusVo;
import ims.scheduling.vo.BookingAppointmentTheatreVo;
import ims.scheduling.vo.BookingAppointmentTheatreVoCollection;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupInstVo;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import org.apache.log4j.Logger;
import org.hibernate.StaleObjectStateException;
import org.joda.time.Days;
import org.joda.time.Hours;

public class ADTImpl extends DomainImpl implements ims.core.domain.ADT, ims.domain.impl.Transactional
{
	/**
	 * 
	 */
	private static final long	serialVersionUID	= -4990538760120461815L;
	private static final Logger			LOG		= Logger.getLogger(ADTImpl.class);

	public ims.core.vo.InpatientEpisodeVo admitPatient(PatientShort patVo, ims.core.vo.InpatientEpisodeVo episVo, DateTime transactionDT) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!episVo.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainInterfaceException("Internal Patient ID must be valued.");
		}
		// Ignore the ID if sent in. Don't throw exception. If patient already admitted, will be caught in later check.
		// WDEV-4759 Checking ConfigFlag here as we are associating a saved PasEvent with the Inpatient Episode - the code was nulling our attempts at this 
		DomainFactory factory = getDomainFactory();
		if(ConfigFlag.HL7.ADT_IN_UPDATE_PARTIAL_ADMISSION_ONLY.getValue()) //WDEV-17135
		{
			// Get and update the Partial Admission record
			if(episVo!=null&&episVo.getPasEvent()!=null&&episVo.getPasEvent().getPasEpisodeId()!=null)
			{
				String partialAdmissionId=episVo.getPasEvent().getPasEpisodeId();
				try
				{
					int id=Integer.parseInt(partialAdmissionId);
					EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
					if(episVo!=null&&episVo.getPasEvent()!=null&&episVo.getPasEvent().getLocation()!=null)
					{
						LocationLiteVo wardVo=episVo.getPasEvent().getLocation();
						Location ward=(Location)factory.getDomainObject(Location.class, wardVo.getID());
						partialAdmission.setAdmissionWard(ward);
					}
					if(episVo!=null&&episVo.getAdmissionDateTimeIsNotNull())
					{
						partialAdmission.setAdmissionDateTime(episVo.getAdmissionDateTime().getJavaDate());
					}
					factory.save(partialAdmission);
					return null;
				}
				catch (NumberFormatException e)
				{
					if(episVo.getPasEvent()!=null)
					{
						throw new DomainInterfaceException("Failed to parse Partial Admission ID "+episVo.getPasEvent().getPasEpisodeId());
					}
					else
					{
						throw new DomainInterfaceException("Failed to read Partial Admission ID.");
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
					throw new DomainInterfaceException(e.getMessage());
				}
			}
			else throw new DomainInterfaceException("Partial Admission ID not found in PV1-50");
		}
		if (!(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()))
		{
			episVo.setID_InpatientEpisode(null);
			episVo.getPasEvent().setID_PASEvent(null);
		}
		else
		{
			if (episVo.getPasEventIsNotNull()&&episVo.getPasEvent().getID_PASEventIsNotNull())
			{
				CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + episVo.getPasEvent().getID_PASEvent());
				if (doCareContext!=null)
				{
					doCareContext.setContext(getDomLookup( ContextType.INPATIENT));
					
					doCareContext.setCurrentStatus(new CareContextStatusHistory());
					doCareContext.getCurrentStatus().setStatusDateTime(new Date());
					doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
					doCareContext.getStatusHistory().add(doCareContext.getCurrentStatus());
				
					// Set the estiimated Discharge Date if in the InpatientEpisode
					//http://jira/browse/WDEV-13288
					if (episVo.getEstDischargeDate() != null)
						doCareContext.setEstimatedDischargeDate(episVo.getEstDischargeDate().getDate());
					
					factory.save(doCareContext);
				}
				
			}
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo != null)
		{
			//throw new DomainInterfaceException("Patient is already an inpatient. Cannot Admit.");
			return InpatientEpisodeVoAssembler.create(ipDo);
		}

		
		ims.core.patient.domain.objects.Patient domPatient =  (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		
		
//		PASEvent domPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPasEvent().getPasEventId());
		
		//Get TCI PASEvent
		PASEvent domTCIPas=null;
		if (episVo!=null&&episVo.getPreAdmitNumber()!=null)
		 domTCIPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPreAdmitNumber());
		
		
		PendingElectiveAdmission domPEA =  getDomPendingElectiveAdmission(domPatient,domTCIPas);
		if(null!=domPEA)
		{
			domPEA.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
			factory.save(domPEA);
		}
		
		ipDo = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, episVo);
		if (ipDo!=null)
		{
			WardStay ws = new WardStay();
			ws.setTransferDateTime(ipDo.getAdmissionDateTime());
			if (ipDo.getPasEvent()!=null)
				ws.setWard(ipDo.getPasEvent().getLocation());
			ws.setWardType(ipDo.getWardType());
		
			if(ipDo.getPasEvent()!=null&&ipDo.getPasEvent().getConsultant()!=null)
			{
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(ipDo.getPasEvent().getConsultant());
				cs.setTransferDateTime(ipDo.getAdmissionDateTime());
				ipDo.getConsultantStays().add(cs);
			}
			ipDo.getWardStays().add(ws);
			
			//wdev-14784
			http://jira/browse/WDEV-15128 Added flag condition as well
			if( ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue()&&
					ipDo.getPasEvent()!=null &&	ipDo.getPasEvent().getLocation()!=null&&
					!Boolean.TRUE.equals(ipDo.getPasEvent().getLocation().isVTEAsessmentNotRequired())  )
			{
				ipDo.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}

		}
		factory.save(ipDo);

		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(ipDo,episVo, transactionDT);
		factory.save(ad);
		domPatient.setWard(ipDo.getPasEvent().getLocation());
		domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());		// WDEV-17867 - Retain current responsible consultant
		factory.save(domPatient);
		
		// WDEV-16240 - check to see if a new Dementia Record is required
		createDementiaRecordIfRequired(factory, ad);
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}

	
	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		return transferPatient( patVo,  hcp,  ward,null);
	}
	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		return transferPatient( patVo,  hcp,  ward, stay,null,null,null,null);

	}
	public ims.core.vo.InpatientEpisodeVo transferPatient(PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay,LocationRefVo fromWard, DateTime transferDateTime, DateTime transactionDT, LookupInstVo specialty) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (patVo == null)
		{
			throw new DomainRuntimeException("Patient cannot be null!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo == null)
		{
			//Patient is not currently an inpatient, so ignore transfer event.
			return null;	
		}	
		performTransfer(ipDo, patVo, hcp, ward,stay,fromWard,transferDateTime,transactionDT,specialty);
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}

	public ims.core.vo.DischargedEpisodeVo dischargePatient(ims.core.vo.PatientShort patVo, ims.core.vo.DischargedEpisodeVo dischEpisVo, CareContextInterfaceVo voCareContext) throws ForeignKeyViolationException, DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!dischEpisVo.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainInterfaceException("Internal Patient ID must be valued.");
		}

		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		DischargedEpisode disDo = DischargedEpisodeVoAssembler.extractDischargedEpisode(factory, dischEpisVo);
		PASEvent peDo = disDo.getPasEvent();
		
		InpatientEpisode ipDo = getCurrentAdmission(factory, patVo);
		
		AdmissionDetail doAdmissionDetail = null;	//WDEV-12825 
		
		if (ipDo != null)
		{
			//Want to re-use the one that was created for the Admission. No need for a new one on Discharge.
			peDo = ipDo.getPasEvent();
			factory.initialize(peDo);
			
			//WDEV-8312
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
			if(admList != null && admList.size() > 0)
			{
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				doAdmissionDetail.setWard(null);
				doAdmissionDetail.setBed(null);
				//factory.save(doAdmissionDetail); //WDEV-12825 
			}
			
			disDo.setPasEvent(peDo);
			disDo.setAdmissionDetail(doAdmissionDetail);
			disDo.setAdmissionType(ipDo.getAdmissionType());//WDEV-16397
			
			disDo.setVTEAssessmentStatus(ipDo.getVTEAssessmentStatus());
			disDo.setVTERiskAssessment(ipDo.getVTERiskAssessment());
			
			updateBed(factory, peDo);
			
			if(ipDo != null)
			{
				PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
				if(doTransfer != null)
					getDomainFactory().delete(doTransfer);
				//http://jira/browse/WDEV-13288
				if(ipDo.getDischargeReadyDate()!=null)
				{
					disDo.setDischargeReadyDate(ipDo.getDischargeReadyDate());
				}
				//http://jira/browse/WDEV-15997
				disDo.getWardStays().addAll(ipDo.getWardStays());
				disDo.getConsultantStays().addAll(ipDo.getConsultantStays());
			}

			factory.delete(ipDo);
		} 
		else if (ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()==false 
				&& ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()==false
				&& ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()==false) //wdev-16771
		{
			throw new StaleObjectException(null);//null as ipDo no longer exists - wdev-16798
		}
		else if(peDo != null && peDo.getPasEventId()!=null)// Try and get the PAS event   //wdev-15823
		{
			peDo = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient,peDo.getPasEventId());
		}
		
		if( peDo != null )  //wdev-15823
		    factory.save(peDo);
		
		disDo.setPasEvent(peDo);
		factory.save(disDo);
		
		//JME: 20061023: Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear current medic from Patient record. No longer an inpatient, it doesn't have a current responsible medic
		domPatient.setCurrentResponsibleConsultant(null);
		factory.save(domPatient);
		
		//WDEV-10231
		if( ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() || ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue() )  //wdev-16427
		{
			CareContext careContextDom=null;
			if(voCareContext != null)
			{
				careContextDom=CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext);
			}
			else
			{
				if( peDo != null)  //wdev-16427
				    careContextDom = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
			}
			if (careContextDom!=null)
			{
				careContextDom.setBedNumber(null);
				careContextDom.setContext(getDomLookup(ContextType.INPATIENT));
				careContextDom.setCurrentStatus(new CareContextStatusHistory());
				careContextDom.getCurrentStatus().setStatusDateTime(new Date());
				// WDEV-12694 Set EndDateTime if not already set i.e. this isn't called from HL7Engine
				if (careContextDom.getEndDateTime() == null)
					careContextDom.setEndDateTime(dischEpisVo.getDischargeDateTime().getJavaDate());
				careContextDom.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
				careContextDom.getStatusHistory().add(careContextDom.getCurrentStatus());
				factory.save(careContextDom);
			
				// Set the admission date time as it may have been updated
				Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + careContextDom.getId());
				if (domSummary != null)
				{
					domSummary.setAdmissionDateTime(careContextDom.getStartDateTime());
					factory.save(domSummary);

					// WDEV-12731 Only update the edischarge details if a letter has NOT been generated 
					if (domSummary.getDischargeDocuments() == null || domSummary.getDischargeDocuments().size() == 0)
					{
						// WDEV-12588 Update the discharging ward, consultant and specialty
						// only if value already set as otherwise problems exist when trying
						// to mark ready to leave
						DischargeDetails domEDischarge = (DischargeDetails) getDomainFactory().findFirst("from DischargeDetails dd where dd.careContext.id = " + careContextDom.getId());
						if (domEDischarge != null)
						{
							if (domEDischarge.getDischargingWard() != null && peDo.getLocation() != null)
								domEDischarge.setDischargingWard(peDo.getLocation());
							if (domEDischarge.getDischargingConsultant() != null && disDo.getPasEvent().getConsultant() != null)
								domEDischarge.setDischargingConsultant(disDo.getPasEvent().getConsultant());
							if (domEDischarge.getDischargingSpecialty() != null && disDo.getPasEvent().getSpecialty() != null)
								domEDischarge.setDischargingSpecialty(disDo.getPasEvent().getSpecialty());
							if (domEDischarge.getDateOfDischarge() != null && disDo.getDischargeDateTime() != null)
								domEDischarge.setDateOfDischarge(disDo.getDischargeDateTime());
							factory.save(domEDischarge);
						}
					}
					
					//WDEV-12825 - Start
					if(doAdmissionDetail == null)
					{
						List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
						if(admList != null && admList.size() > 0)
						{
							doAdmissionDetail =  (AdmissionDetail) admList.get(0);
						}
					}
					
					if(doAdmissionDetail != null)
					{
						if(DischargeLetterStatus.GENERATED.getID() != domSummary.getDischargeLetterStatus().getId())
						{
							doAdmissionDetail.setAdmissionDateTime(careContextDom.getStartDateTime());					
						}
					}
					//WDEV-12825 - End
				}
			}
		}
		
		//WDEV-12825
		if(doAdmissionDetail != null)
			factory.save(doAdmissionDetail);
	
		// WDEV-16240 Check if a dementia record is to be updated
		updateDementiaRecordForDischarge(factory, doAdmissionDetail, disDo);
		
		if (doAdmissionDetail.getPasEvent().getPasEventId() != null)
			markAssociatedAppoinmentAsDischarged(factory, new Integer(doAdmissionDetail.getPasEvent().getId()));//wdev-18155
		
		return DischargedEpisodeVoAssembler.create(disDo);
	}

	private void markAssociatedAppoinmentAsDischarged(DomainFactory factory, Integer pasEventID) throws StaleObjectException
	{

		String hql = "from Booking_Appointment ba " + 
		" where ba.pASEvent.id = :eventId " +
		"and ba.currentStatusRecord.status = :statID";

		ArrayList<String> labels = new ArrayList<String>();
		labels.add("eventId");
		labels.add("statID");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(pasEventID);
		values.add(getDomLookup(Status_Reason.ADMITTED));
	
		BookingAppointmentTheatreVoCollection voList = BookingAppointmentTheatreVoAssembler.createBookingAppointmentTheatreVoCollectionFromBooking_Appointment(getDomainFactory().find(hql.toString(), labels, values));

		if (voList != null
			&& voList.size() > 0)
		{
			for (int i = 0 ; i < voList.size() ; i++)
			{
				BookingAppointmentTheatreVo vo = voList.get(i);
				Booking_Appointment doAppt = (Booking_Appointment) getDomainFactory().getDomainObject(vo);
				
				doAppt.getApptStatusHistory().add(doAppt.getCurrentStatusRecord());

				Appointment_Status doApptStat = new Appointment_Status();
				doApptStat.setStatus(getDomLookup(Status_Reason.DISCHARGED));
				doApptStat.setStatusChangeDateTime(new DateTime().getJavaDate());
				doAppt.setCurrentStatusRecord(doApptStat);
				doAppt.setApptStatus(getDomLookup(Status_Reason.DISCHARGED));
				
				factory.save(doAppt);
			}
		}
		
	}


	private BedSpaceState getBedSpaceStateByPasEvent(PASEvent peDo)
	{
		if (peDo == null || peDo.getId() == null)
			throw new CodingRuntimeException("peDo is null or id not provided in method getBedSpaceStateByPasEvent");
		
		String hql = "from BedSpaceState as bed join fetch bed.inpatientEpisode.pasEvent as pe where pe.id = " + peDo.getId();
		List lstBeds = getDomainFactory().find(hql);
		if(lstBeds != null && lstBeds.size() == 1)
			return (BedSpaceState) lstBeds.get(0);
		
		return null;
	}

	public Boolean cancelAdmission(PatientShort patVo) throws ForeignKeyViolationException, StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo == null)
		{
			//Return Silently if patieOnt is not currently an inpatient
			return Boolean.FALSE;					
		}
		PASEvent peDo = ipDo.getPasEvent();
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		// WDEV-7506, If Episodes are being instantiated, we want
		// to remove the link between the PasEvent and CareContext and close the carecontext
		// to allow deletion to proceed
		disconnectFromPasEvent(factory, peDo);
		if(ipDo != null)
		{
			PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
			if(doTransfer != null)
			{
				getDomainFactory().delete(doTransfer);
			}
			updateBed( factory, peDo); 
		}
		factory.delete(ipDo);
		// wdev-8301 - can't delete as AdmissionDetails will exist
		// factory.delete(peDo);
		
		//JME: 20061023: Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear the Current Responsible Consultant from Patient record. No longer an inpatient
		domPatient.setCurrentResponsibleConsultant(null);
		factory.save(domPatient);
		
		rieDementiaRecords(factory, peDo);  // WDEV-16240 rie the Dementia records as this admission is no longer valid
		return Boolean.TRUE;
	}


	/**
	 * WDEV-7506
	 * disconnectFromPasEvent
	 * Check if there is a CareConext linked to this PasEvent
	 * if there is, remove the link and close the carecontext
	 * @param factory
	 * @param peDo
	 * @throws StaleObjectException 
	 */
	private void disconnectFromPasEvent(DomainFactory factory, PASEvent peDo) throws StaleObjectException 
	{
		if (!(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()||ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()))
			return;
			
		List lst= CareContext.listCareContextByPasEvent(factory, peDo);
		if (lst != null && lst.size() > 0)
		{
			// Only one CareContext per pas event
			CareContext domCareContext = (CareContext) lst.get(0);
			domCareContext.setPasEvent(null);
			domCareContext.setEndDateTime(new java.util.Date());
			//WDEV-10231
			domCareContext.setCurrentStatus(new CareContextStatusHistory());
			domCareContext.getCurrentStatus().setStatusDateTime(new Date());
			domCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.CANCELLED));
			domCareContext.getStatusHistory().add(domCareContext.getCurrentStatus());
			
			factory.save(domCareContext);
		}
	}

	public DischargedEpisodeVo getCurrentDischarge(PatientShort patVo, DischargedEpisodeVo dischEpisVo)
	{
		DomainFactory factory = getDomainFactory();
		DischargedEpisode domDischarge = getCurrentDischargeRecord(factory, patVo, dischEpisVo);
		return (DischargedEpisodeVoAssembler.create(domDischarge));
	}
	
	private DischargedEpisode getCurrentDischargeRecord(DomainFactory factory, PatientShort patVo, DischargedEpisodeVo dischEpisVo)
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		DischargedEpisode disEpisBo = DischargedEpisodeVoAssembler.extractDischargedEpisode(factory, dischEpisVo);
		PASEvent peDo = disEpisBo.getPasEvent();		

		
		String hql = "from DischargedEpisode de " + 
					" where de.pasEvent.patient = :pat " + 
					" and de.pasEvent.pasEventId = :eventId ";
		
		ArrayList<String> labels = new ArrayList<String>();
		labels.add("pat");
		labels.add("eventId");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(domPatient);
		values.add(peDo.getPasEventId());
		if (disEpisBo.getDischargeDateTime() != null)
		{
			hql +=" and de.dischargeDateTime = :disDate";
			labels.add("disDate");
			values.add(disEpisBo.getDischargeDateTime());
		}
		List<?> l = factory.find(hql, labels, values);		
		if (l != null && l.size() > 0)
		{
			if (l.size() > 1)
				throw new DomainRuntimeException("Duplicate data found for Patient, PasEvent and DateTime");
			
			return (DischargedEpisode) l.get(0);
		}
		
		return null;
	}
	

	//wdev-16657
	private PendingEmergencyAdmissionVoCollection listPendingEmergencyAdmissions(DomainFactory factory, PatientShort patVo, PasEventVo pasEvent)
	{
		String hql = "from PendingEmergencyAdmission pea " + 
					" where pea.pasEvent.patient.id = :pat " + 
					" and pea.pasEvent.id = :eventId ";
		
		ArrayList<String> labels = new ArrayList<String>();
		labels.add("pat");
		labels.add("eventId");
		
		ArrayList<Object> values = new ArrayList<Object>();
		values.add(patVo.getID_Patient());
		values.add(pasEvent.getID_PASEvent());
		
		return PendingEmergencyAdmissionVoAssembler.createPendingEmergencyAdmissionVoCollectionFromPendingEmergencyAdmission(getDomainFactory().find(hql.toString(), labels, values));
	}
	//wdev-16657
	
	public InpatientEpisodeVo cancelDischarge(PatientShort patVo, DischargedEpisodeVo dischEpisVo, CareContextInterfaceVo careContextVo) throws ForeignKeyViolationException, StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		InpatientEpisode ipDo = getCurrentAdmission(patVo);
		if (ipDo != null)
		{
			//No need to do anything. Patient is still an inpatient.
			return InpatientEpisodeVoAssembler.create(ipDo);					
		}
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		DischargedEpisode disEpisBo = getCurrentDischargeRecord(factory, patVo, dischEpisVo);

		PASEvent peDo=null;
		LookupInstance vteStatus=null;
		VTERiskAssessment vteRiskAssessment = null;

		ipDo = new InpatientEpisode();
		if(disEpisBo!=null)
		{
			ipDo.getWardStays().addAll(disEpisBo.getWardStays());
			ipDo.getConsultantStays().addAll(disEpisBo.getConsultantStays());
		}
		
		if (disEpisBo != null)
		{			
			//Need to delete the Discharge record
			peDo = disEpisBo.getPasEvent();
			factory.initialize(peDo);
			
			ipDo.setAdmissionType(disEpisBo.getAdmissionType());//WDEV-16397
			
			vteStatus=disEpisBo.getVTEAssessmentStatus();
			vteRiskAssessment = disEpisBo.getVTERiskAssessment();
			
			try 
			{
				factory.delete(disEpisBo);
			}
			catch (StaleObjectStateException e)   //wdev-16427 
			{
				throw new StaleObjectException(null);
			}
		}
		
		// wdev-7261 - No PasEvent, so there was no discharge record for the patient
		if (peDo == null)
			throw new DomainRuntimeException("Discharge Record not found for this Patient");
		
		ipDo.setPasEvent(peDo);
		ipDo.setIsOnLeave(Boolean.FALSE);
		
		//WDEV-14993 - starts here
		AdmissionDetail addmissionDetails =null;
		if (ipDo!=null)
		{
			addmissionDetails = getCurrentAdmissionDetail(ipDo.getPasEvent());
			ipDo.setAdmissionDateTime(addmissionDetails.getAdmissionDateTime());
			// WDEV-16346 reset the ward in Admission Detail
			addmissionDetails.setWard(ipDo.getPasEvent().getLocation());
			
			//http://jira/browse/WDEV-15128 Added flag condition
			if(ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue()&&
					ipDo.getPasEvent()!=null && ipDo.getPasEvent().getLocation()!=null &&
					!Boolean.TRUE.equals(ipDo.getPasEvent().getLocation().isVTEAsessmentNotRequired()))
			{
				ipDo.setVTEAssessmentStatus(vteStatus);
				ipDo.setVTERiskAssessment(vteRiskAssessment);
			}
		}//WDEV-14993 - ends here
		
		try 
		{
			factory.save(ipDo);
			domPatient.setWard(ipDo.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Consultant for Patient record
			domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
			factory.save(domPatient);
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}
		
		// WDEV-12588 - If CareContext not null, save it as bed number and end datetime cleared
		if (careContextVo != null && (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() || ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()) || ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue() )		//wdev-16428
		{
			CareContext careContextDom=CareContextInterfaceVoAssembler.extractCareContext(factory, careContextVo);
			
			careContextDom.setCurrentStatus(new CareContextStatusHistory());
			careContextDom.getCurrentStatus().setStatusDateTime(new Date());
			careContextDom.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
			careContextDom.getStatusHistory().add(careContextDom.getCurrentStatus());
			
			factory.save(careContextDom);
			
			// Flag the summary as it exists, but the discharge was cancelled from PAS
			Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + careContextDom.getId());
			if (domSummary != null)
			{
				domSummary.setWasPatientDischargedThenUndone(true);
				factory.save(domSummary);
			}

			// It was agreed to leave the discharge details (as displayed on Ready to Leave) as is if the
			// discharge letter was generated – the customer will have to use the supplementary details to 
			// send any letters to GP to reflect any new discharge details.. We will only set these list of
			// fields that I listed on the Ready To Leave to NULL when no discharge letter was generated.
			if (domSummary != null && (domSummary.getDischargeDocuments()== null || domSummary.getDischargeDocuments().size() == 0))
			{
				// Documents found, so update ready to leave values
				ReadyToLeave domReadyToLeave = (ReadyToLeave) getDomainFactory().findFirst("from ReadyToLeave rl where rl.careContext.id = " + careContextDom.getId());
				if (domReadyToLeave != null)
				{
					domReadyToLeave.setIsComplete(false);
					domReadyToLeave.setCompletedOn(null);
					domReadyToLeave.setCompletedBy(null);
										
					domReadyToLeave.getDischargeDetails().setDischargingWard(null);
					domReadyToLeave.getDischargeDetails().setDischargeMethod(null);
					domReadyToLeave.getDischargeDetails().setDischargeDestination(null);
					domReadyToLeave.getDischargeDetails().setDischargingConsultant(null);
					domReadyToLeave.getDischargeDetails().setDischargingSpecialty(null);
					domReadyToLeave.getDischargeDetails().setMethodOfDischarge(null);
					domReadyToLeave.getDischargeDetails().setDateOfDischarge(null);
					factory.save(domReadyToLeave);
				}
				
				// No discharge letters generated, set summary back to inprogress
				SummaryDetail domSumm = domSummary.getSummaryDetailRecord(factory.getLookupInstance(EDischargeSummarySection.READY_TO_LEAVE.getID()));
				if (domSumm != null)
				{
					domSumm.setProgressStatus(factory.getLookupInstance(EDischargeSummarySectionStatus.IN_PROGRESS.getID()));
					factory.save(domSumm);
				}
			}
		}
		
		// WDEV-16240 Check if a dementia record is to be updated
		updateDementiaRecordForCancelDischarge(factory, addmissionDetails);
				
		return InpatientEpisodeVoAssembler.create(ipDo);
	}
	
	public void cancelAppointment(OutPatientAttendanceVo attendance, CareContextInterfaceVo voCareContext) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		
		OutpatientAttendance domAtt = OutPatientAttendanceVoAssembler.extractOutpatientAttendance(factory, attendance);
		
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue())
		{
			if(voCareContext != null)
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext));
		}
		
		// WDEV-13455
		// We may want to record this appointment within the Patient Diary
		if (ConfigFlag.DOM.RECORD_INTO_PATIENT_DIARY.getValue())
		{
			PatientApptDiary diary = createDiaryEntry(domAtt,attendance.getApptType(),attendance.getRecordingUser());
			factory.save(diary);
		}
		factory.save(domAtt);
	}

	public OutPatientAttendanceVo getOutpatientAppointment(PasEventVo pasEventVo)
	{
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from OutpatientAttendance o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return OutPatientAttendanceVoAssembler.create((OutpatientAttendance) lst.get(0));
		}
		
		return null;
	}
	
	public void updateInpatient(InpatientEpisodeVo inpatientEpisode, CareContextInterfaceVo voCareContext) throws StaleObjectException
	{
		if (!inpatientEpisode.isValidated())
		{
			throw new DomainRuntimeException("Episode VO has not been validated!");
		}
		DomainFactory factory = getDomainFactory();
		
		if(ConfigFlag.HL7.ADT_IN_UPDATE_PARTIAL_ADMISSION_ONLY.getValue()) //WDEV-17135
		{
			// Get and update the Partial Admission record
			if(inpatientEpisode!=null&&inpatientEpisode.getPasEvent()!=null&&inpatientEpisode.getPasEvent().getPasEpisodeId()!=null)
			{
				String partialAdmissionId=inpatientEpisode.getPasEvent().getPasEpisodeId();
				try
				{
					int id=Integer.parseInt(partialAdmissionId);
					EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
					if(inpatientEpisode!=null&&inpatientEpisode.getPasEvent()!=null&&inpatientEpisode.getPasEvent().getLocation()!=null)
					{
						LocationLiteVo wardVo=inpatientEpisode.getPasEvent().getLocation();
						Location ward=(Location)factory.getDomainObject(Location.class, wardVo.getID());
						partialAdmission.setAdmissionWard(ward);
					}
					if(inpatientEpisode!=null&&inpatientEpisode.getAdmissionDateTimeIsNotNull())
					{
						partialAdmission.setAdmissionDateTime(inpatientEpisode.getAdmissionDateTime().getJavaDate());
					}
					factory.save(partialAdmission);
					return;
				}
				catch (NumberFormatException e)
				{
					if(inpatientEpisode.getPasEvent()!=null)
					{
						throw new DomainRuntimeException("Failed to parse Partial Admission ID "+inpatientEpisode.getPasEvent().getPasEpisodeId());
					}else
					{
						throw new DomainRuntimeException("Failed to read Partial Admission ID.");
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
					throw new DomainRuntimeException(e.getMessage());
				}
			}
			else throw new DomainRuntimeException("Partial Admission ID not found in PV1-50");
		}

		
		InpatientEpisode domInpat = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, inpatientEpisode);
		Patient domPatient = (Patient) factory.getDomainObject(Patient.class, inpatientEpisode.getPasEvent().getPatient().getID_Patient());
//http://jira/browse/WDEV-16830		
//		if (domPatient.getWard() == null)
		if (domInpat.getPasEvent() != null
				&&domInpat.getPasEvent().getLocation()!=null
				&&domInpat.getPasEvent().getLocation().getType().equals(getDomLookup(LocationType.WARD)))
		{
			domPatient.setWard(domInpat.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Clinician in Patient record
			domPatient.setCurrentResponsibleConsultant(domInpat.getPasEvent().getConsultant());
			factory.save(domPatient);
		}
		factory.save(domInpat);
		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(domInpat,inpatientEpisode, null); //WDEV-10593
		//factory.save(ad);//WDEV-12825
		
		//WDEV-10231
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()||ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue())
		{
			if(voCareContext != null)
			{
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, voCareContext));
			
				// Further change - EDischargeSummary AdmissionDateTime to be updated
				Summary domSummary =  (Summary) getDomainFactory().findFirst("from Summary ss where ss.careContext.id = " + voCareContext.getID_CareContext());
				if (domSummary != null)
				{
					domSummary.setAdmissionDateTime(voCareContext.getStartDateTime().getJavaDate());
					factory.save(domSummary);
					
					//WDEV-12825
					if(DischargeLetterStatus.GENERATED.getID() != domSummary.getDischargeLetterStatus().getId())
					{
						ad.setAdmissionDateTime(voCareContext.getStartDateTime().getJavaDate());					
					}
				}
			}
		}
		
		factory.save(ad);//WDEV-12825
		
		// WDEV-16240 - check if a Dementia record is to be updated
		updateDementiaRecordForInpatient(factory, ad);
	}

	public void recordInpatientLeave(PatientRefVo patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		InpatientEpisode epis = getCurrentAdmission(factory, patient);
		if (epis != null)
		{
			epis.setIsOnLeave(Boolean.TRUE);
			factory.save(epis);
		}
	}

	public void cancelInpatientLeave(PatientShort patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();

		Patient domPatient = PatientShortAssembler.extractPatient(factory, patient);
		InpatientEpisode epis = getCurrentAdmission(factory, patient);
		if (epis != null)
		{
		PASEvent pasevent=epis.getPasEvent();
		Location loc=(Location)factory.getDomainObject(Location.class, domPatient.getWard().getId());
		pasevent.setLocation(loc);
		epis.setPasEvent(pasevent);
	
		epis.setIsOnLeave(Boolean.FALSE);
		factory.save(epis);
		}
	}

	private InpatientEpisode getCurrentAdmission(PatientRefVo patVo)
	{
		DomainFactory factory = getDomainFactory();
		return this.getCurrentAdmission(factory, patVo);
	}
	
	private AdmissionDetail populateAdmissionDetailfromInpatientEpisode(InpatientEpisode ie,InpatientEpisodeVo episVo, DateTime transactionDT)
	{
		if (ie==null)
			throw new DomainRuntimeException("InpatientEpisode must not be null");
		
		PASEvent pe = ie.getPasEvent();
		AdmissionDetail ad = getCurrentAdmissionDetail(pe);
		
		if (ad == null)
			ad = new AdmissionDetail();
		ad.setPasEvent(pe);
		if(pe!=null)
		{
			ad.setWard(pe.getLocation());
			ad.setConsultant(pe.getConsultant());
			ad.setSpecialty(pe.getSpecialty());
			ad.setAdmissionDateTime(pe.getEventDateTime());
		}
			
		if(episVo!=null)
		{
			ad.setWardType(getDomLookup(episVo.getWardType()));
			ad.setMethodOfAdmission(getDomLookup(episVo.getMethodOfAdmission()));
			ad.setSourceOfAdmission(getDomLookup(episVo.getSourceOfAdmission()));
			ad.setReasonForAdmission(episVo.getReasonForAdmission());
			ad.setIsChaplainRequired(episVo.getIsChaplainRequired());
			//WDEV-14833 
			if(episVo.getPatientStatusIsNotNull())
			{
				ad.setPatientStatus(getDomLookup(episVo.getPatientStatus()));
			}
			
			//WDEV-16397
			if (Boolean.TRUE.equals(ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue()) && episVo.getExtendedDetailsIsNotNull())
			{
				ad.setExtendedDetails(ExtendedAdmissionDetailVoAssembler.extractExtendedAdmissionDetail(getDomainFactory(), episVo.getExtendedDetails()));
			}
		}
		if(episVo.getEstDischargeDate()!=null)
		{
			ad.setEstDischargeDate(episVo.getEstDischargeDate().getDate());
		}
		
		//WDEV-10593
		if(ad.getAdmissionTransactionDateTime() == null && transactionDT != null)
			ad.setAdmissionTransactionDateTime(transactionDT.getJavaDate());
		
		return ad;
	}
	
	private AdmissionDetail getCurrentAdmissionDetail(PASEvent pasEvent)
	{
		DomainFactory factory = getDomainFactory();
		String hql = "from AdmissionDetail ad where ad.pasEvent=:pasEvent";
		List<?> l = factory.find(hql,new String[]{"pasEvent"},new Object[]{pasEvent});
		if (l != null && l.size() > 0)
		{
			return (AdmissionDetail)l.get(0);
		}
		return null;
	}
	
	private InpatientEpisode getCurrentAdmission(DomainFactory factory, PatientRefVo patVo) 
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		String hql = "from InpatientEpisode ip where ip.pasEvent.patient.id = :pat";
		List<?> l = factory.find(hql, new String[] {"pat"}, new Object[] {domPatient.getId()});		
		if (l != null && l.size() > 0)
		{
			return (InpatientEpisode)l.get(0);
		}
		return null;
	}

	private void performTransfer(InpatientEpisode ipDo, PatientRefVo patVo, HcpRefVo hcp, LocationRefVo ward,Integer stay,LocationRefVo fromWard, DateTime transferDateTime, DateTime transactionDT, LookupInstVo specialty)
	{
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		PASEvent peDo = ipDo.getPasEvent();	
		Medic medic = peDo.getConsultant();
		Location loc = peDo.getLocation();
		Medic newConsultant = null;
		
		if (hcp != null)
		{
			Hcp domHcp = (Hcp)factory.getDomainObject(Hcp.class, hcp.getID_Hcp());
			if (domHcp instanceof Medic)
				newConsultant = (Medic)domHcp;
		}
		if (ward != null)
		{
			loc = (Location)factory.getDomainObject(Location.class, ward.getID_Location());
		}
		if (stay!=null&&ipDo.getPasEvent()!=null
				&&null!=ipDo.getPasEvent().getEventDateTime()) // update the discharge date
		{
			try{
//			DateTime dt= new DateTime(ipDo.getAdmissionDateTime());
			DateTime  jAdmitDate= new DateTime(	ipDo.getPasEvent().getEventDateTime());
			jAdmitDate.addDays(stay);
			ipDo.setEstDischargeDate(jAdmitDate.getJavaDate());
			}catch (Exception e)
			{
				LOG.warn("Update to estimated discharge date failed.", e);
			}
			
		}
		
		//Transfer will only update the Consultant or the Location
		Location fromWardLoc=null;
		if(fromWard!=null)
		{
			fromWardLoc=(Location)factory.getDomainObject(Location.class,fromWard.getID_Location());
		}
		
		if(loc!=null)
		{
			if (fromWardLoc==null||!(fromWardLoc.getId().equals(loc.getId())))
			{
				WardStay wardStay = new WardStay();
				wardStay.setWard(fromWardLoc);
				if(transferDateTime!=null)
				{
					wardStay.setTransferDateTime(transferDateTime.getJavaDate());
				}
				ipDo.getWardStays().add(wardStay);
			}
		}
		if(newConsultant!=null)
		{
			if(!newConsultant.equals(medic))
			{
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(newConsultant);
				if(transferDateTime!=null)
				{
					cs.setTransferDateTime(transferDateTime.getJavaDate());
				}
				ipDo.getConsultantStays().add(cs);
			}
			
			medic=newConsultant;
		}
		peDo.setConsultant(medic);
		peDo.setLocation(loc);
		try 
		{
			factory.save(peDo);
			factory.save(ipDo);
			
			//WDEV-7990
			if (ward != null && hasWardChanged(loc,fromWardLoc))
				updateBed(factory, peDo);
			
			domPatient.setWard(ipDo.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Clinician for Patient record
			domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
			factory.save(domPatient);
			
			//WDEV-8315
			if(peDo != null)
			{
				// WDEV-12588 - set specialty if supplied
				if (specialty != null)
					peDo.setSpecialty(factory.getLookupInstance(specialty.getID()));
					
				List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
				if(admList != null && admList.size() > 0)
				{
					AdmissionDetail doAdmissionDetail =  (AdmissionDetail) admList.get(0);
					if(loc != null)
						doAdmissionDetail.setWard(loc);
					
					//WDEV-10421 - create a record in the history for the transfer performed on the PAS
					TransferHistory doTransferHistory = new TransferHistory();
					doTransferHistory.setTransferringFromWard(fromWardLoc);
					//WDEV-11882
					if(transferDateTime != null)
						doTransferHistory.setAcceptTransferDateTime(transferDateTime.getJavaDate());
					doTransferHistory.setAcceptingOrRejectingWard(loc);
					//WDEV-10593
					if(transactionDT != null)
						doTransferHistory.setMarkedForTransferOutDateTime(transactionDT.getJavaDate());
					
					doAdmissionDetail.getTransferHistory().add(doTransferHistory);
										
					
					doAdmissionDetail.setBed(null);
					factory.save(doAdmissionDetail);
				}
			}
			
			// WDEV-12588  - Update Associated CareContext if exist and functionality required
			if (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue() 
					|| ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()
					|| ConfigFlag.UI.MAXIMS_ADT_NO_INTERFACE.getValue())
			{
				CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
				if (doCareContext != null)
				{
					// WDEV-13901 - If specialty or consultant change, keep a history
					if ((doCareContext.getEpisodeOfCare().getResponsibleHCP() != null && doCareContext.getEpisodeOfCare().getResponsibleHCP().getId() != peDo.getConsultant().getId()) ||
							(doCareContext.getEpisodeOfCare().getSpecialty().getId() != peDo.getSpecialty().getId()))
					{
						// EpisodeOfCare history record
						EpisodeOfCareHistory episHis = new EpisodeOfCareHistory();
						episHis.setEndDate(doCareContext.getEpisodeOfCare().getEndDate());
						episHis.setRelationship(doCareContext.getEpisodeOfCare().getRelationship());
						episHis.setResponsibleHCP(doCareContext.getEpisodeOfCare().getResponsibleHCP());
						episHis.setSpecialty(doCareContext.getEpisodeOfCare().getSpecialty());
						episHis.setStartDate(doCareContext.getEpisodeOfCare().getStartDate());
						if (doCareContext.getEpisodeOfCare().getEpisodeOfCareHistory() == null)
							doCareContext.getEpisodeOfCare().setEpisodeOfCareHistory(new HashSet());
						doCareContext.getEpisodeOfCare().getEpisodeOfCareHistory().add(episHis);
					}
					// WDEV-13901 - CareContext history required on consultant change
					if (doCareContext.getResponsibleHCP() != null && doCareContext.getResponsibleHCP().getId() != peDo.getConsultant().getId())
					{
						CareContextHistory ccHis = new CareContextHistory();
						ccHis.setBedNumber(doCareContext.getBedNumber());
						ccHis.setContext(doCareContext.getContext());
						ccHis.setEndDateTime(doCareContext.getEndDateTime());
						ccHis.setLocationType(doCareContext.getLocationType());
						if (doCareContext.getPasEvent() != null)
							ccHis.setPasEventId(doCareContext.getPasEvent().getPasEventId());
						ccHis.setResponsibleHCP(doCareContext.getResponsibleHCP());
						ccHis.setStartDateTime(doCareContext.getStartDateTime());
						if (doCareContext.getCareContextHistory() == null)
							doCareContext.setCareContextHistory(new HashSet());
						doCareContext.getCareContextHistory().add(ccHis);
					}
							
					

					
					doCareContext.setResponsibleHCP(peDo.getConsultant());
					doCareContext.setEstimatedDischargeDate(ipDo.getEstDischargeDate());
					if (fromWardLoc == null || loc == null || (fromWardLoc != null && loc != null && !fromWardLoc.getId().equals(loc.getId())))
						doCareContext.setBedNumber(null);

					doCareContext.getEpisodeOfCare().setSpecialty(peDo.getSpecialty());
					doCareContext.getEpisodeOfCare().setResponsibleHCP(peDo.getConsultant());
					factory.save(doCareContext);
					
				}
			}
			
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}				
	}

	private boolean hasWardChanged(Location loc, Location ward)
	{
		if (loc == null)
			throw new CodingRuntimeException("loc cannot be null in method hasWardChanged");
		if (ward == null)
			return true;
		
		if(loc.equals(ward))
			return false;
		
		return true;
	}



	//WDEV-7717 - get the Bed if was populated and update its status to available and unlink it from the inpatient episode
	private void updateBed(DomainFactory factory, PASEvent peDo) throws StaleObjectException
	{	
		BedSpaceState doBedSpaceState = getBedSpaceStateByPasEvent(peDo);
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setPreviousBedStatus(doBedSpaceState.getCurrentBedStatus());
			doBedSpaceState.setCurrentBedStatus(new BedSpaceStateStatus());
			doBedSpaceState.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.AVAILABLE));
			doBedSpaceState.getCurrentBedStatus().setStatusDateTime(new DateTime().getJavaDate());
			doBedSpaceState.setInpatientEpisode(null);
			factory.save(doBedSpaceState);	
		}
		
		// WDEV-12588 If CareContext linked to this pasevent, update the bed number there too
		if (ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue())
		{
			CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + peDo.getId());
			if (doCareContext != null)
			{
				doCareContext.setBedNumber(null);
				factory.save(doCareContext);
			}
		}
	
	}

	public OutPatientAttendanceVo recordOPAttendance(PatientShort patVo, OutPatientAttendanceVo attVo, CareContextInterfaceVo ccVo) throws StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!attVo.isValidated())
		{
			throw new DomainRuntimeException("Attendance VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new DomainRuntimeException("Internal Patient ID must be valued.");
		}
		DomainFactory factory = getDomainFactory();				
		OutpatientAttendance attDo = OutPatientAttendanceVoAssembler.extractOutpatientAttendance(factory, attVo);
		
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue())
		{
			if(ccVo != null)
				factory.save(CareContextInterfaceVoAssembler.extractCareContext(factory, ccVo));
		}
		
		try 
		{
			factory.save(attDo);
			
			// WDEV-13455
			// We may want to record this appointment within the Patient Diary
			if (ConfigFlag.DOM.RECORD_INTO_PATIENT_DIARY.getValue())
			{
				PatientApptDiary diary = createDiaryEntry(attDo,attVo.getApptType(),attVo.getRecordingUser());
				factory.save(diary);
			}
			
		}
		catch (DomainException e) 
		{
			throw new DomainRuntimeException(e);
		}
		return OutPatientAttendanceVoAssembler.create(attDo);
	}

	/**
	 * WDEV-13455
	 * This method will setup the diary values if recording patient diary events
	 * @param attDo
	 * @return
	 */
	private static final String FIRST="F";
	private static final String SPECIAL_FIRST="S";
	private static final String REPEAT="R";
	private static final String SPECIAL_REPEAT="X";

	private PatientApptDiary createDiaryEntry(OutpatientAttendance attDo, String appointmentType, String recordingUser)
	{
		DomainFactory factory = getDomainFactory();	
		
		// First check if the patient diary exists - check via PasEvent
		List lst = PatientApptDiary.listPatientApptDiaryByPasEvent(factory, attDo.getPasEvent());
		
		PatientApptDiary diary=null;
		if (lst == null || lst.size() == 0)
		{
			diary = new PatientApptDiary();
			diary.setApptType("First");
		}
		else
		{
			diary = (PatientApptDiary)lst.get(0);
		}

		if (appointmentType != null)
		{
			if (appointmentType.equals(FIRST))
				diary.setApptType("First");
			else if (appointmentType.equals(SPECIAL_FIRST))
				diary.setApptType("Special First");
			else if (appointmentType.equals(REPEAT))
				diary.setApptType("Repeat");
			else if (appointmentType.equals(SPECIAL_REPEAT))
				diary.setApptType("Special Repeat");
		}
		
		diary.setPasEvent(attDo.getPasEvent());
		diary.setAppointmentId(attDo.getId());
		diary.setApptDate(attDo.getAppointmentDateTime());
		
		diary.setClinic(attDo.getClinic());
		if (attDo.getClinic() != null)
			diary.setClinicName(attDo.getClinic().getClinicName());
		diary.setBookedBy(recordingUser == null ? "PAS":recordingUser);
		diary.setBookedDate(attDo.getPasEvent().getEventDateTime());
		diary.setStartTime(new Time(attDo.getAppointmentDateTime()).toString());
		diary.setEndTime(diary.getStartTime());  // In Current thick client, End Time always equals Start Time
		diary.setPatient(attDo.getPasEvent().getPatient());
		diary.setPkey(null);
		diary.setStatusDate(new Date());
		
		// WDEV-15543  If the status is CLOSED - we want to record the text as 'Attended'
		if (attDo.getAppointmentStatus().getId() ==  Status_Reason.CLOSED.getID())
			diary.setStatus("Attended");
		else
			diary.setStatus(attDo.getAppointmentStatus().getText());
		diary.setSource("PAS");
		diary.setActive(true);
		

		// WDEV-13603
		// For PAS purposes, we need to retrieve the pkey to store too
		Patient domPatient = diary.getPatient();
		if (domPatient.getIdentifiers() != null && domPatient.getIdentifiers().size() > 0)
		{
			for (int i=0; i<domPatient.getIdentifiers().size(); i++)
			{
				PatientId domId = (PatientId) domPatient.getIdentifiers().get(i);
				if (domId.getType().getId() == PatIdType.PKEY.getID())
				{
					diary.setPkey(Integer.valueOf(domId.getValue()));
					break;
				}
			}
		}
		
		return diary;
	}
	
	public AneAttendanceVo recordAEAttendance(AneAttendanceVo attendance, PatientShort patient, Boolean bCancelDischarge) throws StaleObjectException, ForeignKeyViolationException
	{
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (!attendance.isValidated())
		{
			throw new DomainRuntimeException("Attendance VO has not been validated!");
		}
		if(patient.getID_Patient() == null)
		{
			throw new DomainRuntimeException("Internal Patient ID must have a value.");
		}
		DomainFactory factory = getDomainFactory();				

		PasEventVo pasEvent = attendance.getPasEvent();
		PendingEmergencyAdmission PEADomain=null;
		if(pasEvent!=null)
		{
			if (bCancelDischarge)
			{
				//wdev-16657
				//List all PEA's for patient and pasevent.
				PendingEmergencyAdmissionVoCollection voPEAs = listPendingEmergencyAdmissions(factory, patient, pasEvent);
				
				//if there are any iterate thru list and delete them.
				if ( voPEAs != null && voPEAs.size() > 0)
				{
					for (int i = 0 ; i < voPEAs.size() ; i++)
					{
						PendingEmergencyAdmission doPendingEmergency = (PendingEmergencyAdmission)factory.getDomainObject(voPEAs.get(i));
						if(doPendingEmergency != null)
							factory.delete(doPendingEmergency);
					}
				}
				//wdev-16657
			}
			else
			{
				PendingEmergencyAdmissionVo pendingEmergencyAdmissionVo = getPendingEmergencyAdmission(pasEvent);
				if (pendingEmergencyAdmissionVo==null)
				{
					pendingEmergencyAdmissionVo=new PendingEmergencyAdmissionVo();
					pendingEmergencyAdmissionVo.setPasEvent(pasEvent);
				}
				if(pendingEmergencyAdmissionVo.getAdmissionStatus()==null)
					pendingEmergencyAdmissionVo.setAdmissionStatus(EmergencyAdmissionStatus.DTA );
				pendingEmergencyAdmissionVo.setDTADateTime(attendance.getAdmitDateTime());
				pendingEmergencyAdmissionVo.setReasonForAdmission(attendance.getReasonForAdmission());
				PEADomain = PendingEmergencyAdmissionVoAssembler.extractPendingEmergencyAdmission(factory, pendingEmergencyAdmissionVo);
			}
		}
		AEAttendance attDo = AneAttendanceVoAssembler.extractAEAttendance(factory, attendance);
		factory.save(attDo.getPasEvent());

		if ( ! bCancelDischarge)
		{
				PEADomain.setCurrentLocation(attDo.getPasEvent().getLocation());
			if(null!=attendance.getANEconclusionDateTime())
			{
				PEADomain.setConclusionDate(attendance.getANEconclusionDateTime().getJavaDate());
			}
			if(attendance.getBedTypeRequestedIsNotNull())
			{
				PEADomain.setBedTypeRequested(getDomLookup(attendance.getBedTypeRequested()));
			}
			Location loc=null;
			if(attendance.getCurrentLocation()!=null&&attendance.getCurrentLocation().getID_Location()!=null)
			{
				loc = (Location)factory.getDomainObject(Location.class, attendance.getCurrentLocation().getID_Location());
			}
			PEADomain.setCurrentLocation(loc);
			
			PEADomain.setPasEvent(attDo.getPasEvent());
			factory.save(PEADomain);
		}
		factory.save(attDo);
		
		return AneAttendanceVoAssembler.create(attDo);
	}

	public InpatientEpisodeVo getCurrentAdmissionRecord(PatientRefVo patient)
	{
		return InpatientEpisodeVoAssembler.create(getCurrentAdmission(patient));
	}

	public PasEventVo getPasEventByUnqIdx(PatientRefVo voPatientRef, String pasEventId)
	{
		if (voPatientRef == null || voPatientRef.getID_Patient() == null)
			throw new CodingRuntimeException("Mandatory Argument: Patient");

		if (pasEventId == null)
			throw new CodingRuntimeException("Mandatory Argument: Pas Contact No");

		DomainFactory factory = getDomainFactory();
		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voPatientRef.getID_Patient().intValue());
		PASEvent domPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, pasEventId);
		
		return PasEventVoAssembler.create(domPas);
		
		
	}

	public PasEventVo getPasEvent(PASEventRefVo voPasEventRef) 
	{
		if (voPasEventRef == null)
			throw new CodingRuntimeException("Mandatory Argument: Pas Event");
		
		DomainFactory factory = getDomainFactory();
		PASEvent domPas = (PASEvent) factory.getDomainObject(PASEvent.class, voPasEventRef.getID_PASEvent());
		return PasEventVoAssembler.create(domPas);
		
	}

/**
 * 	Populates as many of the PasEvent fields as it can from the PasContact
 *  CareContext,IsVip,ReferringGP,SourceOfReferral are left as null 
 *  EventDateTime depends on whether we are listing inpatients or outpatients and
 *  is populated external to this method.
 */
	public PasEventVo createPasEvent(DateTime eventDateTime, PatientRefVo voRefPatient, PasContactVo voPasContact) throws StaleObjectException, UniqueKeyViolationException   
	{
		PasEventVo voPasEvent = new PasEventVo();

		voPasEvent.setEventDateTime(eventDateTime);
		
		if (voPasContact.getConsultant() != null)
		{
			MedicWithMappingsLiteVo medLite = new MedicWithMappingsLiteVo(voPasContact.getConsultant().getID_Hcp(), voPasContact.getConsultant().getVersion_Hcp());
			medLite.setMos(voPasContact.getConsultant().getMos());
			voPasEvent.setConsultant(medLite);			
		}
		voPasEvent.setLocation(voPasContact.getLocation());
		voPasEvent.setSpecialty(voPasContact.getSpecialty());
		voPasEvent.setPasEventId(voPasContact.getContactNumber());
		//		voPasEvent.setPatient(voPasContact.getPatient());
		GpLiteToPracticeLiteVo voGpLiteToPracList = synchronizeGPPracticeDetails(voPasContact.getGPCode());
		if (voGpLiteToPracList != null)
		{
			voPasEvent.setReferringGP(voGpLiteToPracList.getGp());
			if (voGpLiteToPracList.getPracticeIsNotNull() && voGpLiteToPracList.getPractice().getSurgeriesIsNotNull() && voGpLiteToPracList.getPractice().getSurgeries().size() > 0)
				voPasEvent.setReferringGpSurgery(voGpLiteToPracList.getPractice().getSurgeries().get(0));
		}
		
		if (voPasContact.getAppointmentDateTimeIsNotNull())
			voPasEvent.setEventType(PasEventType.OUTPATIENT);
		else if (voPasContact.getDischargeDateTimeIsNotNull())
			voPasEvent.setEventType(PasEventType.INPATIENT);

		DomainFactory factory = getDomainFactory();
		PASEvent domPasEvent = PasEventVoAssembler.extractPASEvent(factory, voPasEvent);

		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, voRefPatient.getID_Patient().intValue()); 
		domPasEvent.setPatient(domPatient);
		try 
		{
			factory.save(domPasEvent);
		}
		catch (UnqViolationUncheckedException e)
		{
			throw new UniqueKeyViolationException(e.getMessage());
		}
		
		return PasEventVoAssembler.create(domPasEvent);
	}
	
	public GpLiteToPracticeLiteVo synchronizeGPPracticeDetails(String strGPCode)  throws StaleObjectException, UniqueKeyViolationException
	{
		Demographics impl = (Demographics) getDomainImpl(DemographicsImpl.class);
		return impl.synchronizeGPPracticeDetails(strGPCode);
	}
	
	public AneAttendanceVo getAnEAttendance(PasEventVo pasEventVo)
	{
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from AEAttendance o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return AneAttendanceVoAssembler.create((AEAttendance) lst.get(0));
		}
		
		return null;
	}

	@SuppressWarnings("unchecked")
	public PendingEmergencyAdmissionVo getPendingEmergencyAdmission(
			PasEventVo pasEventVo) {
		DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from PendingEmergencyAdmission o where o.pasEvent.id = :pasEvent";
			List lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return PendingEmergencyAdmissionVoAssembler.create((PendingEmergencyAdmission) lst.get(0));
		}
		
		return null;
	}

	public PendingEmergencyAdmissionVo recordPendingEmergencyAdmission(
			PasEventVo pasEventVo,
			PendingEmergencyAdmissionVo pendingEmergencyAdmission) throws StaleObjectException{
		if (!pasEventVo.isValidated())
		{
			throw new DomainRuntimeException("Pas Event VO has not been validated!");
		}
//		pendingEmergencyAdmission.setAdmissionStatus(EmergencyAdmissionStatus.DTA );
		DomainFactory factory = getDomainFactory();				
		PendingEmergencyAdmission PEADomain = PendingEmergencyAdmissionVoAssembler.extractPendingEmergencyAdmission(factory, pendingEmergencyAdmission);
		PASEvent pasEventDomain=PasEventVoAssembler.extractPASEvent(factory, pasEventVo);
		factory.save(pasEventDomain);
		factory.save(PEADomain);
		return PendingEmergencyAdmissionVoAssembler.create(PEADomain);
	}

	
	public PendingElectiveAdmissionHl7Vo getPendingElectiveAdmission(
			PasEventVo pasEventVo) {
	DomainFactory factory = getDomainFactory();
		
		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
		if (domEvent != null)
		{
			String hql = " from PendingElectiveAdmission o where o.pasEvent.id = :pasEvent";
			List<?> lst = factory.find(hql, new String[]{"pasEvent"}, new Object[]{domEvent.getId()});
			if (lst != null && lst.size() == 1)
				return PendingElectiveAdmissionHl7VoAssembler.create((PendingElectiveAdmission) lst.get(0));
		}
		
		return null;
		}

//	public PendingElectiveAdmissionHl7Vo getPendingElectiveAdmission(
//			PasEventVo pasEventVo)
//	{
//		DomainFactory factory = getDomainFactory();
//		PASEvent domEvent = PASEvent.getPASEventFrompasevent_unq1(factory, (Patient)factory.getDomainObject(Patient.class, pasEventVo.getPatient().getID_Patient()), pasEventVo.getPasEventId());
//		if (domEvent != null)
//		{
//			PendingElectiveAdmission domPending = getDomPendingElectiveAdmission(domEvent);
//			if (domPending!=null)
//			{
//				return PendingElectiveAdmissionHl7VoAssembler.create(domPending);
//			}
//		}
//		return null;
//	}
	
	
	private PendingElectiveAdmission getDomPendingElectiveAdmission(Patient domPatient,
			PASEvent domEvent) 
	{
		if (domPatient==null||null==domEvent||null==domEvent.getPasEventId())
			return null;
		DomainFactory factory = getDomainFactory();
		if (domEvent!=null)
		{
			String hql = " from PendingElectiveAdmission o where o.pasEvent.patient = :pat and o.pasEvent.pasEventId = :pasEvent";
			
			List<?> lst = factory.find(hql, new String[]{"pat","pasEvent"}, new Object[]{domPatient,domEvent.getPasEventId()});
			if (lst != null && lst.size() == 1)
				return (PendingElectiveAdmission) lst.get(0);
		}
		return null;
	}

	public PendingElectiveAdmissionHl7Vo recordPendingElectiveAdmission(
			PasEventVo pasEventVo,
			PendingElectiveAdmissionHl7Vo pendingElectiveAdmissionVo)
			throws StaleObjectException {
		if(!pasEventVo.isValidated())
		{
			throw new DomainRuntimeException("Pas Event VO has not been validated!");
		}
		if (null ==pendingElectiveAdmissionVo)
		{
			throw new DomainRuntimeException("Pending Elective Admission cannot be null");
		}

		if (!pendingElectiveAdmissionVo.isValidated())
		{
			throw new DomainRuntimeException("Pending Elective Admission Admit VO has not been validated!");
		}
		DomainFactory factory = getDomainFactory();
		
		PendingElectiveAdmission peaDomain = PendingElectiveAdmissionHl7VoAssembler.extractPendingElectiveAdmission(factory, pendingElectiveAdmissionVo);
		if(null!=pendingElectiveAdmissionVo.getProcedures())
		{
			for (String procCode : pendingElectiveAdmissionVo.getProcedures()) 
			{
				Procedure proc = getProcedureFromTaxonomyMap(procCode,TaxonomyType.OPCS4);
				if(proc!=null)
					peaDomain.getProcedures().add(proc);
			}
		}
		
		factory.save(peaDomain);
		return PendingElectiveAdmissionHl7VoAssembler.create(peaDomain);
	}

	private Procedure getProcedureFromTaxonomyMap(String procedureCode,TaxonomyType type)
	{
	if(procedureCode==null || type==null)
		return null;
	DomainFactory factory = getDomainFactory();
	String hql = " from Procedure p join p.taxonomyMap t where t.taxonomyCode = :taxCode and t.taxonomyName = :type and p.isActive = TRUE";
	List<?> lst = factory.find(hql,new String[]{"taxCode","type"},new Object[]{procedureCode,getDomLookup(type)});
	if (lst!=null &&lst.size() ==1)
		return (Procedure)lst.get(0);
	else
		return null;
	}

	//WDEV-10231
	public CareContextInterfaceVo getCareContextByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getCareContextByPasEvent");
		
		CareContext doCareContext = (CareContext) getDomainFactory().findFirst("from CareContext cc where cc.pasEvent.id = " + pasEvent.getID_PASEvent());
		return CareContextInterfaceVoAssembler.create(doCareContext);
	}

	//	WDEV-13307
	public InpatientEpisodeVo readmitPatient(PatientShort patVo, InpatientEpisodeVo episVo) throws StaleObjectException 
	{
		if (!patVo.isValidated())
		{
			throw new CodingRuntimeException("Patient VO has not been validated!");
		}
		if (!episVo.isValidated())
		{
			throw new CodingRuntimeException("Episode VO has not been validated!");
		}
		if(patVo.getID_Patient() == null)
		{
			throw new CodingRuntimeException("Internal Patient ID must be valued.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		ims.core.patient.domain.objects.Patient domPatient =  (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());

		PASEvent domTCIPas=null;
		if (episVo!=null&&episVo.getPreAdmitNumber()!=null)
			domTCIPas = PASEvent.getPASEventFrompasevent_unq1(factory, domPatient, episVo.getPreAdmitNumber());
		
		PendingElectiveAdmission domPEA =  getDomPendingElectiveAdmission(domPatient,domTCIPas);
		if(null!=domPEA)
		{
			domPEA.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
			factory.save(domPEA);
		}
		
		InpatientEpisode ipDo = InpatientEpisodeVoAssembler.extractInpatientEpisode(factory, episVo);
		if (ipDo!=null)
		{
			WardStay ws = new WardStay();
			ws.setTransferDateTime(ipDo.getAdmissionDateTime());
			if (ipDo.getPasEvent()!=null)
				ws.setWard(ipDo.getPasEvent().getLocation());
			ws.setWardType(ipDo.getWardType());
		
			if(ipDo.getPasEvent()!=null&&ipDo.getPasEvent().getConsultant()!=null)
			{
				ConsultantStay cs = new ConsultantStay();
				cs.setConsultant(ipDo.getPasEvent().getConsultant());
				cs.setTransferDateTime(ipDo.getAdmissionDateTime());
				ipDo.getConsultantStays().add(cs);
			}
			
			ipDo.getWardStays().add(ws);
		}
		factory.save(ipDo);
		
		AdmissionDetail ad = populateAdmissionDetailfromInpatientEpisode(ipDo,episVo, null);
		factory.save(ad);
		
		domPatient.setWard(ipDo.getPasEvent().getLocation());
		// WDEV-17867 - Set Current Responsible Clinician to Patient record
		domPatient.setCurrentResponsibleConsultant(ipDo.getPasEvent().getConsultant());
		factory.save(domPatient);
		
		return InpatientEpisodeVoAssembler.create(ipDo);
	}
	
	
	/**
	 * WDEV-16240
	 * createDementiaRecordIfRequired - this method works through the business logic to determine whether a new dementia record is required.
	 * If one is needed, the createDementiaRecord method is called and a new record is created.
	 * for the current patient
	 * @param factory
	 * @param adt
	 * @param dementiaConfig
	 * @return void
	 * @throws StaleObjectException 
	 */
	private void createDementiaRecordIfRequired(DomainFactory factory, AdmissionDetail adt) throws StaleObjectException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;

		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		if (dementiaConfig == null)
			return;

		// If the method of admission is not in the configured list of those required, to not create the record
		if (adt.getMethodOfAdmission() == null || !dementiaConfig.isMethodOfAdmissionListed(adt.getMethodOfAdmission()))
		{
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.INFORMATION, "Method of Admission not supplied or not in the list of configured values (ADM:" + adt.getId() + ")"); 
			return;
		}
		
		boolean newRecordRequired=false;
		
		// 1. If patient age below threshold, do not proceed
		int patientAge = calculateAge(adt.getPasEvent().getPatient(), adt.getAdmissionDateTime());
		if (patientAge < dementiaConfig.getAge())
			newRecordRequired= false;
		
		// 2. Does a Dementia record exist for this patient - we will not include 'Excluded', STEP_ONE_FIND_OUTSTANDING or STEP_TWO_ASSESS_INVESTIGATE_OUTSTANDING dementia records
		String hql = " from Dementia d where d.patient = :patient and d.currentWorklistStatus.status.id not in (:excluded, :step1, :step2) and (d.isRIE is null or d.isRIE = false) order by d.dischargeDateTime desc";
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(adt.getPasEvent().getPatient());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.EXCLUDED.getID());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.STEP_ONE_FIND_OUTSTANDING.getID());
		values.add(ims.core.vo.lookups.DementiaWorklistStatus.STEP_TWO_ASSESS_INVESTIGATE_OUTSTANDING.getID());
		labels.add("patient");
		labels.add("excluded");
		labels.add("step1");
		labels.add("step2");
		List lst = factory.find(hql, labels, values);
		// If no records exist, we want to create a new one
		if ((lst == null || lst.size() == 0) && patientAge >= dementiaConfig.getAge())
			newRecordRequired= true;   
		
		// Take the first Dementia record returned in the list and use this to determine factors below
		Dementia prevDementia=null;
		if (lst.size() > 0)
		{
			prevDementia = (Dementia) lst.get(0);
		
			// If the difference between the last dischargeDateTime and this admissionDateTime is greater than excludeFairPeriod, we want a new record
			int days=0;
			if (prevDementia.getDischargeDateTime() != null)
				days = Days.daysBetween(new org.joda.time.DateTime(prevDementia.getDischargeDateTime()).toDateMidnight() , new org.joda.time.DateTime(adt.getAdmissionDateTime()).toDateMidnight()).getDays();
			else
			{
				// 	DischargeDateTime is null, so use admission details and log this
				days = Days.daysBetween(new org.joda.time.DateTime(prevDementia.getAdmissionDateTime()).toDateMidnight() , new org.joda.time.DateTime(adt.getAdmissionDateTime()).toDateMidnight()).getDays();
				createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DischargeDateTime is null for the previous dementia record, using AdmissionDateTime to calculate days since last fair process (" + prevDementia.getId() + ")");
			}
			if (days >= dementiaConfig.getExcludeFAIRPeriod())
				newRecordRequired= true;

			// If within the fair period, but the previous record has dementia confirmed or the AMTSThresholdScore is less than configured value
			if ((prevDementia.isDementiaConfirmed() != null && prevDementia.isDementiaConfirmed() == true) || (prevDementia.getAMTSScore() != null && prevDementia.getAMTSScore() < dementiaConfig.getAMTSThresholdScore()))
				newRecordRequired= true;

		}

		
		if (newRecordRequired)
			createDementiaRecord(factory, prevDementia, adt, patientAge, dementiaConfig.getStepOnePeriod());
		
	}


	private DementiaConfiguration getDementiaConfigRecord(DomainFactory factory) 
	{
		// Get the DementiaConfiguration record
		List cfgLst = factory.find(" from DementiaConfiguration dc where dc.isRIE is null or dc.isRIE = false");
		if (cfgLst == null || cfgLst.size() == 0)
		{
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Dementia Configuration record cannot be found - processing cannot continue");
			return null;
		}
		return (DementiaConfiguration) cfgLst.get(0);
	}
	
	/**
	 * WDEV-16240
	 * Create Dementia Record - creates the Dementia record based on values from AdmissionDetail and the previous dementia record for the patient
	 * @param factory
	 * @param lastDementiaRecord - previous dementia record for the patient
	 * @param adt - Admission Detail record to be associated with this new Dementia record
	 * @param age - Patients age
	 * @param breachHours - the number of hours following AdmissionDateTime in which this task would have breached
	 * @throws StaleObjectException 
	 */
	private void createDementiaRecord(DomainFactory factory, Dementia lastDementiaRecord, AdmissionDetail adt, int age, int breachHours) throws StaleObjectException
	{
		AuthoringInformation auth = new AuthoringInformation();
		auth.setAuthoringDateTime(new Date());

		Dementia domDem = new Dementia();
		DementiaWorklistStatus stat = new DementiaWorklistStatus();
		
		stat.setAuthoringInformation(auth);
		stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.STEP_ONE_FIND_OUTSTANDING));
		
		domDem.setAdmissionDateTime(adt.getAdmissionDateTime());
		domDem.setAdmissionDetail(adt);
		domDem.setAgeOnAdmission(age);
		domDem.setBreachDateTime(calculateBreachDate(adt.getAdmissionDateTime(), breachHours));
		domDem.setPatient(adt.getPasEvent().getPatient());
		domDem.setCurrentWorklistStatus(stat);
		domDem.getHistoricalWorklistStatus().add(stat);

		// If the previous Dementia Record as confirmedDementia, then this status needs to be set to complete
		if (lastDementiaRecord != null && lastDementiaRecord.isDementiaConfirmed()!= null && lastDementiaRecord.isDementiaConfirmed() == true)
		{
			stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.COMPLETED));
			domDem.setDementiaConfirmed(true);
			domDem.setBreachDateTime(null);
		}
		
		factory.save(domDem);
	}
	
	/**
	 * WDEV-16240
	 * updateDementiaRecordForDischarge - depending on values in the discharge details, the DementiaRecord may need to be updated
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 * @throws ForeignKeyViolationException 
	 */
	private void updateDementiaRecordForDischarge(DomainFactory factory, AdmissionDetail doAdmissionDetail, DischargedEpisode dischDo) throws StaleObjectException, ForeignKeyViolationException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// If AdmissionDetail is null, try to get it here
		if (doAdmissionDetail == null)
		{
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + dischDo.getPasEvent().getId());
			if(admList != null && admList.size() > 0)
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
		}
		
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission  and d.isRIE is null or d.isRIE = false", labels, values); 
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		// This could be an update message i.e. an A08, if it is we only want to continue if the dischargedatetime has been modified
		if (domDem.getDischargeDateTime() != null && domDem.getDischargeDateTime().equals(dischDo.getDischargeDateTime()))
			return;
		
		domDem.setDischargeDateTime(dischDo.getDischargeDateTime());
				
		// Get the Dementia Configuration record
		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		
		if (dementiaConfig == null)
			return;
		
		// We need to check if this is an early discharge.  If it is, we will set the status of this dementia record to excluded - as long as not already excluded!
		int hours = Hours.hoursBetween(new org.joda.time.DateTime(domDem.getAdmissionDateTime()) , new org.joda.time.DateTime(domDem.getDischargeDateTime())).getHours();
		if (hours < dementiaConfig.getStepOnePeriod() && (domDem.getCurrentWorklistStatus() == null || domDem.getCurrentWorklistStatus().getReasonForExclusion() == null ||
				(domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() != ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())))
		{
			DementiaWorklistStatus stat = new DementiaWorklistStatus();
			AuthoringInformation auth = new AuthoringInformation();
			auth.setAuthoringDateTime(new Date());
			stat.setAuthoringInformation(auth);
			stat.setStatus(getDomLookup(ims.core.vo.lookups.DementiaWorklistStatus.EXCLUDED));
			stat.setReasonForExclusion(getDomLookup(ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE));
			domDem.setCurrentWorklistStatus(stat);
			domDem.setIsExcludedFromWorklist(true);
			domDem.getHistoricalWorklistStatus().add(stat);
		
		}
		
		// If this is an update, and the current status indicates early discharge and now it is no longer an early discharge
		// we need to remove the excluded status from the list and revert back to the original status point
		if (hours >= dementiaConfig.getStepOnePeriod() && domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() == ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())
		{
			DementiaWorklistStatus stat = domDem.getCurrentWorklistStatus();
			domDem.getHistoricalWorklistStatus().remove(domDem.getHistoricalWorklistStatus().size()-1); // Remove the last record
			domDem.setCurrentWorklistStatus((DementiaWorklistStatus) domDem.getHistoricalWorklistStatus().get(domDem.getHistoricalWorklistStatus().size()-1));
			factory.delete(stat);
			domDem.setIsExcludedFromWorklist(false);
		}
		
		factory.save(domDem);

	}
	

	/**
	 * WDEV-16240
	 * updateDementiaRecordForCancelDischarge - As this is a cancel discharge, we have to clear out discharge date and possibly remove excluded status records
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 * @throws ForeignKeyViolationException 
	 */
	private void updateDementiaRecordForCancelDischarge(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException, ForeignKeyViolationException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission and (d.isRIE is null or d.isRIE = false) ", labels, values);
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		domDem.setDischargeDateTime(null);
		// If the current status is excluded, we want to remove this
		if (domDem.getCurrentWorklistStatus().getReasonForExclusion() != null && domDem.getCurrentWorklistStatus().getReasonForExclusion().getId() == ims.core.vo.lookups.DementiaReasonForExclusion.EARLY_DISCHARGE.getID())
		{
			DementiaWorklistStatus stat = domDem.getCurrentWorklistStatus();
			domDem.getHistoricalWorklistStatus().remove(domDem.getHistoricalWorklistStatus().size()-1); // Remove the last record
			domDem.setCurrentWorklistStatus((DementiaWorklistStatus) domDem.getHistoricalWorklistStatus().get(domDem.getHistoricalWorklistStatus().size()-1));
			factory.delete(stat);
			domDem.setIsExcludedFromWorklist(false);
		}
		
		factory.save(domDem);

	}

	/**
	 * WDEV-16240
	 * updateDementiaRecordForInpatient - update Dementia record if specific inpatient details modified
	 * @param factory
	 * @param doAdmissionDetail
	 * @throws StaleObjectException 
	 */
	private void updateDementiaRecordForInpatient(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		// Get the Dementia Record for this Admission record
		ArrayList<Object> values = new ArrayList<Object>();
		ArrayList<String> labels = new ArrayList<String>();
		values.add(doAdmissionDetail);
		labels.add("admission");
		List lst = factory.find(" from Dementia d where d.admissionDetail = :admission and (d.isRIE is null or d.isRIE = false) ", labels, values);
		if (lst == null || lst.size() == 0)
			return;
		
		Dementia domDem = (Dementia) lst.get(0);
		
		// We only want to update the Dementia record if the admission datetime has been modified
		if (domDem.getAdmissionDateTime() != null && domDem.getAdmissionDateTime().equals(doAdmissionDetail.getAdmissionDateTime()))
			return;

		// Get the Dementia Configuration record
		DementiaConfiguration dementiaConfig = getDementiaConfigRecord(factory);
		if (dementiaConfig == null)
			return;
		
		domDem.setAdmissionDateTime(doAdmissionDetail.getAdmissionDateTime());
		domDem.setBreachDateTime(calculateBreachDate(doAdmissionDetail.getAdmissionDateTime(), dementiaConfig.getStepOnePeriod()));
		domDem.setAgeOnAdmission(calculateAge(doAdmissionDetail.getPasEvent().getPatient(), doAdmissionDetail.getAdmissionDateTime()));

		factory.save(domDem);
	}

	/**
	 * WDEV-16240 rieDementiaRecords
	 * When we get a cancelAdmission message in, we need to RIE all Dementia records that have been instantiated for this admission
	 * as they are no longer relevant
	 * @param factory
	 * @param peDo
	 * @throws StaleObjectException 
	 */
	private void rieDementiaRecords(DomainFactory factory, PASEvent peDo) throws StaleObjectException
	{
		if (ConfigFlag.GEN.DEMENTIA_FUNCTIONALITY.getValue() == false)
			return;
		
		List demList = factory.find("from Dementia d where (d.isRIE is null or d.isRIE = false) and d.admissionDetail.pasEvent.id = " + peDo.getId());
		if (demList == null || demList.size() == 0)
			return;
		
		Dementia domDementia = (Dementia) demList.get(0);
	
		DementiaFind find = domDementia.getStepOneFind();
		if (find != null)
		{
			factory.markAsRie(DementiaFind.class,find.getId(), null, peDo.getPatient().getId(),null, null, "DementiaFind record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaFind record marked as RIE as Admission record cancelled via HL7 (" + find.getId() + ")");
		}

		DementiaAssessAndInvestigate ass = domDementia.getStepTwoAssess();
		if (ass != null)
		{
			factory.markAsRie(DementiaAssessAndInvestigate.class,ass.getId(), null, peDo.getPatient().getId(),null, null, "DementiaAssessAndInvestigate record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaAssessAndInvestigate record marked as RIE as Admission record cancelled via HL7 (" + ass.getId() + ")");
		}
		
		for (int i=0; i<domDementia.getFollowUpAssessments().size(); i++)
		{
			DementiaAssessAndInvestigate assFollowup = (DementiaAssessAndInvestigate) domDementia.getFollowUpAssessments().get(i);
			factory.markAsRie(DementiaAssessAndInvestigate.class, assFollowup.getId(), null, peDo.getPatient().getId(),null, null, "DementiaAssessAndInvestigateFollowup record marked as RIE as Admission record cancelled via HL7");
			createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "DementiaAssessAndInvestigateFollowup record marked as RIE as Admission record cancelled via HL7 (" + assFollowup.getId() + ")");
		}

		factory.markAsRie(Dementia.class,domDementia.getId(), null, peDo.getPatient().getId(),null, null, "Dementia record marked as RIE as Admission record cancelled via HL7");
		createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Dementia record marked as RIE as Admission record cancelled via HL7 (" + domDementia.getId() + ")");
				
	}
	
	/**
	 * WDEV-16240
	 * calculateBreachDate - add the breachHours to the admissionDateTime to get the breachDateTime
	 * @param admissionDateTime
	 * @param breachHours
	 * @return breachDateTime
	 */
	private Date calculateBreachDate(Date admissionDateTime, int breachHours) 
	{
		if (admissionDateTime == null)
			return null;
		
		 Calendar cal = Calendar.getInstance(); 
		 cal.setTime(admissionDateTime); 
		 cal.add(Calendar.HOUR_OF_DAY, breachHours); 
		 return cal.getTime(); // returns new date object
	}


	public Integer calculateAge(Patient domPatient, Date toDate)
	{
		if (domPatient != null && domPatient.getDob() != null && toDate != null)
		{		
			int patAge = new ims.framework.utils.Age(new PartialDate(domPatient.getDob()), new ims.framework.utils.Date(toDate)).getYears();
			return patAge;
		}
		// Exception null patient or no dob
		super.createSystemLogEntry(SystemLogType.DEMENTIA_PROCESSING, SystemLogLevel.WARNING, "Patient Age cannot be calculated due to null date of birth or Admission DateTime");
		return -1;
	}

// new methods for WDEV-17133
	public ifEDAttendanceVo getEDAttendanceDetails(EmergencyAttendanceRefVo attendanceRef)
	{
		DomainFactory factory = getDomainFactory();
		EmergencyAttendance attendance =  (EmergencyAttendance)factory.getDomainObject(EmergencyAttendance.class, attendanceRef.getBoId());
		return ifEDAttendanceVoAssembler.create(attendance);
	}


	public PrivateInsuranceCompanyVo getPrivateInsuranceCompany(String extId,TaxonomyType taxonomyType)
	{
		if (extId == null || taxonomyType == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String hql = " from PrivateInsuranceCompany company " +
		" join company.codeMappings as cm" +
		" where cm.taxonomyName = :taxType " + 
		" and cm.taxonomyCode = :extId ";

		List<?> companyList = factory.find(hql,new String[]{"taxType", "extId"}, new Object[]{getDomLookup(taxonomyType),extId});

		if (companyList != null && companyList.size() > 0)
		{
			PrivateInsuranceCompany company = (PrivateInsuranceCompany)companyList.get(0);
			return PrivateInsuranceCompanyVoAssembler.create(company);
		}
		return null;
		}


	//http://jira/browse/WDEV-17135
	public ifInpatientADTVo getPartialAdmissionDetails(InPatientADTMessageQueueRefVo queueItem)
	{
		DomainFactory factory = getDomainFactory();
		InPatientADTMessageQueue queueItemDom = (InPatientADTMessageQueue)factory.getDomainObject(InPatientADTMessageQueue.class,queueItem.getBoId());
		return ifInpatientADTVoAssembler.create(queueItemDom);
	}


	public void cancelPartialAdmission(String partialAdmissionId)throws DomainInterfaceException, StaleObjectException //WDEV-17135
	{
		if (partialAdmissionId==null)
			throw new DomainInterfaceException("Partial Admission ID not found in PV1-50");
		DomainFactory factory = getDomainFactory();
		try
		{
			int id=Integer.parseInt(partialAdmissionId);
			EDPartialAdmission partialAdmission = (EDPartialAdmission) factory.getDomainObject(EDPartialAdmission.class, id);
					
			partialAdmission.setAdmissionWard(null);
			partialAdmission.setAdmissionDateTime(null);
			factory.save(partialAdmission);
			return;
		}
		catch (NumberFormatException e)
		{
			if(partialAdmissionId!=null)
			{
				throw new DomainInterfaceException("Failed to parse Partial Admission ID "+partialAdmissionId);
			}
			else
			{
				throw new DomainInterfaceException("Failed to read Partial Admission ID.");
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
			throw new DomainInterfaceException(e.getMessage());
		}
	}
	
}
