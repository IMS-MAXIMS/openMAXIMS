//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by John MacEnri using IMS Development Environment (version 1.17 build 40517.1100)
// Copyright (C) 1995-2004 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl; 

import ims.admin.domain.GPAdmin;
import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.GPAdminImpl;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.ElectiveListStatus;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.RefMan.vo.lookups.ElectiveListStatusReason;
import ims.RefMan.vo.lookups.ReferralApptStatus;
import ims.RefMan.vo.lookups.TCIStatusChangeReason;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.EmergencyAttendance;
import ims.core.clinical.domain.objects.DeathDetails;
import ims.core.clinical.domain.objects.PatientAlertCategories;
import ims.core.clinical.domain.objects.PatientMedicalInsurance;
import ims.core.clinical.domain.objects.PatientNoAlertInfo;
import ims.core.domain.Alerts;
import ims.core.domain.PatientCaseNotes;
import ims.core.helper.DTOHelper;
import ims.core.helper.IEndOfCareCatsReferralHelper;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.resource.place.vo.OrganisationRefVo;
import ims.core.vo.CaseNoteFolderVo;
import ims.core.vo.CommChannelVoCollection;
import ims.core.vo.DeathDetailsVo;
import ims.core.vo.DeathDetailsVoCollection;
import ims.core.vo.DemographicControlsConfigVoCollection;
import ims.core.vo.GP;
import ims.core.vo.GpLiteToPracticeLiteVo;
import ims.core.vo.GpPracticeLiteVo;
import ims.core.vo.GpShortVo;
import ims.core.vo.GpToPracticesVo;
import ims.core.vo.GpToPracticesVoCollection;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocSiteShortVoCollection;
import ims.core.vo.LocSiteVo;
import ims.core.vo.LocSiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.NationalHealthCoverVo;
import ims.core.vo.NextOfKin;
import ims.core.vo.OrganisationVo;
import ims.core.vo.OrganisationWithSitesVo;
import ims.core.vo.Patient;
import ims.core.vo.PatientAlertCategoriesVo;
import ims.core.vo.PatientCaseNoteRequestLiteVoCollection;
import ims.core.vo.PatientId;
import ims.core.vo.PatientIdCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.PatientShort;
import ims.core.vo.PersonAddress;
import ims.core.vo.PersonAddressCollection;
import ims.core.vo.PersonName;
import ims.core.vo.TaxonomyMap;
import ims.core.vo.TaxonomyMapCollection;
import ims.core.vo.domain.DeathDetailsVoAssembler;
import ims.core.vo.domain.DemographicControlsConfigVoAssembler;
import ims.core.vo.domain.GPAssembler;
import ims.core.vo.domain.LocSiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.OrganisationWithSitesVoAssembler;
import ims.core.vo.domain.PatientAlertCategoriesVoAssembler;
import ims.core.vo.domain.PatientAssembler;
import ims.core.vo.domain.PatientCaseNoteRequestLiteVoAssembler;
import ims.core.vo.domain.PatientIdAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.lookups.AddressType;
import ims.core.vo.lookups.AlertType;
import ims.core.vo.lookups.AlertTypeCollection;
import ims.core.vo.lookups.CaseNoteRequestCancellationReason;
import ims.core.vo.lookups.CaseNoteRequestStatus;
import ims.core.vo.lookups.ChannelType;
import ims.core.vo.lookups.EthnicOrigin;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MRNStatus;
import ims.core.vo.lookups.MaritalStatus;
import ims.core.vo.lookups.NameType;
import ims.core.vo.lookups.Occupation;
import ims.core.vo.lookups.OrganisationType;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PatientAlertStatus;
import ims.core.vo.lookups.PersonHealthActCategory;
import ims.core.vo.lookups.PersonRelationship;
import ims.core.vo.lookups.PersonTitle;
import ims.core.vo.lookups.Religion;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.DomainSession;
import ims.domain.SessionData;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;
import ims.domain.lookups.LookupInstance;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.ResultException;
import ims.dto.client.Alias;
import ims.dto.client.Alias.AliasRecord;
import ims.dto.client.Demographics;
import ims.dto.client.Demographics.DemographicsRecord;
import ims.dto.client.Gp_practice;
import ims.dto.client.Gp_practice.Gp_practiceRecord;
import ims.dto.client.Hadd;
import ims.dto.client.Hadd.HaddRecord;
import ims.dto.client.Sd_appt;
import ims.dto.client.Sd_appt.Sd_apptAppt_idRecord;
import ims.dto.client.Sd_appt.Sd_apptRecord;
import ims.emergency.domain.objects.AttendanceRequiringContracting;
import ims.framework.SessionConstants;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.framework.utils.DateFormat;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.PartialDate;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PatientJourneyStatus;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.JourneyStatus;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.PendingEmergencyTheatre;
import ims.scheduling.vo.Appointment_StatusVo;
import ims.scheduling.vo.Appointment_StatusVoCollection;
import ims.scheduling.vo.BookingAppointmentLiteVo;
import ims.scheduling.vo.BookingAppointmentLiteVoCollection;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.PendingEmergencyTheatreVo;
import ims.scheduling.vo.PendingEmergencyTheatreVoCollection;
import ims.scheduling.vo.domain.BookingAppointmentLiteVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.PendingEmergencyTheatreVoAssembler;
import ims.scheduling.vo.lookups.PendingEmergencyTheatreRemovalReason;
import ims.scheduling.vo.lookups.PendingEmergencyTheatreStatus;
import ims.scheduling.vo.lookups.Status_Reason;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

public class DemographicsImpl extends DTODomainImplementation implements ims.core.domain.Demographics, ims.domain.impl.Transactional
{
	private static final long	serialVersionUID	= 1L;
	private static final int RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE = 36;

	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}

	/**
	 * Get's a specific Patient
	 * @throws  
	 * @throws UniqueKeyViolationException 
	 */
	public ims.core.vo.Patient getPatient(PatientShort patient) throws StaleObjectException
	{
		if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("LOCAL"))
			return getLocalPatient(patient);
		else if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("DTO"))
		{
			try
			{
				return getDTOPatient(patient);
			}
			catch (UniqueKeyViolationException e)
			{
				throw new DomainRuntimeException(e);
			}
		}

		return null;
	}

	private Patient getDTOPatient(PatientShort patient) throws StaleObjectException, UniqueKeyViolationException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();
		
		Demographics patRec = (Demographics) getDTOInstance(Demographics.class);
		patRec.Filter.clear();
		PatientId intfId = patient.getInterfaceId();
		if (intfId == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid interface identifier");
		}

		//WDEV-10116
		if (intfId.getType().equals(PatIdType.PKEY))
		{
			patRec.Filter.Pkey = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.HOSPNUM))
		{
			patRec.Filter.Hospnum = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.NHSN))
		{
			patRec.Filter.Nhsn = intfId.getIdValue();
		}
		else if (intfId.getType().equals(PatIdType.CHARTNUM))
		{
			patRec.Filter.Chartnum = intfId.getIdValue();
		}
		else
		{
			throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
		}

		Result result = patRec.get();
		if (result != null)
		{
			String errMsg = intfId.getType().getText();
			
			if(errMsg != null)
				errMsg = "Error getting patient details for patient (" + errMsg + "=" + intfId.getValue() + ")." + "\nError - " + result.getMessage();
			else
				errMsg = "Error -" + result.getMessage();
			
			throw new DomainRuntimeException(errMsg);
		}

		DemographicsRecord dtop = patRec.DataCollection.get(0);
		// Check if this patient is in the local database
		// this will setup all the required ids
		ims.core.vo.Patient voPatient = new Patient();
		voPatient.setIdentifiers(new PatientIdCollection());
		voPatient.getIdentifiers().add(intfId);
		voPatient = getLocalPatient(voPatient);

		if (voPatient == null)
		{
			voPatient = new ims.core.vo.Patient();
		}
		if (voPatient.getIdentifiers() == null)
		{
			voPatient.setIdentifiers(new PatientIdCollection());
		}
		// wdev-8564 - set NHSN to verified if CSTA has a value of 1
		if (dtop.Csta != null && dtop.Csta.equals("1"))
			voPatient.addId(PatIdType.NHSN, dtop.Nhsn, true);
		else
			voPatient.addId(PatIdType.NHSN, dtop.Nhsn);
		voPatient.addId(PatIdType.PKEY, dtop.Pkey);
		voPatient.addId(PatIdType.HOSPNUM, dtop.Hospnum);
		voPatient.addId(PatIdType.PPSN, dtop.Ppsn);
		voPatient.addId(PatIdType.CHARTNUM, dtop.Chartnum);

		voPatient.setName(dtop.Snm, dtop.Fnm1, dtop.Fnm2);
		
		// wdev-12961 - Not sure why this line was in code since early 2009 and before.....removed. 
		//voPatient.setName(dtop.Snm, dtop.Fnm1, null);
		
		// Set Maiden Name
		if (dtop.Snmb != null && dtop.Snmb.length() >= 1)
			voPatient.setMaidenName(dtop.Snmb, dtop.Fnm1);
		else
			voPatient.setMaidenName(null);

		// sex
		voPatient.setSex((Sex) getLookupService().getLocalLookup(Sex.class, Sex.TYPE_ID, extSystem, dtop.Sex));

		// dob dod
		try
		{
			if (dtop.Dob != null && dtop.Dob.length() >= 4)
			{
				voPatient.setDob(new PartialDate(dtop.Dob));
			}
			if (dtop.Dod != null && dtop.Dod.length() == 8)
				voPatient.setDod(new Date(dtop.Dod, DateFormat.ISO));
			else
				voPatient.setDod(null);
		}
		catch (ParseException pe)
		{
		}

		// age
		voPatient.calculateAge();

		// address
		PersonAddress pa = voPatient.getAddress();
		if (pa == null)
			pa = new PersonAddress();
		pa.setLine1(dtop.Adr1);
		pa.setLine2(dtop.Adr2);
		pa.setLine3(dtop.Adr3);
		pa.setLine4(dtop.Adr4);
		pa.setLine5(null);
		pa.setPhone(dtop.Ntel);
		pa.setPostCode(dtop.Post);
		pa.setAddressType(AddressType.PERMANENT);
		
		voPatient.setAddress(pa);

		// Communication Channels - Work Phone
		if (voPatient.getCommChannels() == null)
		{
			voPatient.setCommChannels(new CommChannelVoCollection());
		}
		voPatient.addCommunicationChannel(ChannelType.WORK_PHONE, dtop.Dtel);		
		
		// Ward
		OrganisationAndLocation locImpl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		voPatient.setWard(locImpl.getLocationByLocalCode(dtop.Ploc, LocationType.WARD));
		
		// WDEV-17867 - Copy Current Responsible Consultant from Patient parameter record
		if (patient != null)
		{
			voPatient.setCurrentResponsibleConsultant(patient.getCurrentResponsibleConsultant());
		}

		// title
		if (dtop.Titl == null || dtop.Titl.length() <= 0)
		{
			// Used for Irish Pas - Title is not a coded item - PAS outputs the text for patient's Title
			dtop.Titl = dtop.Titltxt;
		}
		voPatient.getName().setTitle((PersonTitle) getLookupService().getLocalLookup(PersonTitle.class, PersonTitle.TYPE_ID, extSystem, dtop.Titl));

		// Marital Status
		voPatient.setMaritalStatus((MaritalStatus) getLookupService().getLocalLookup(MaritalStatus.class, MaritalStatus.TYPE_ID, extSystem, dtop.Mart));

		// Occupation
		voPatient.setOccupation((Occupation) getLookupService().getLocalLookup(Occupation.class, Occupation.TYPE_ID, extSystem, dtop.Poccdesc));

		// Religion
		voPatient.setReligion((Religion) getLookupService().getLocalLookup(Religion.class, Religion.TYPE_ID, extSystem, dtop.Relg));

		// EthnicOrigin
		voPatient.setEthnicOrigin((EthnicOrigin) getLookupService().getLocalLookup(EthnicOrigin.class, EthnicOrigin.TYPE_ID, extSystem, dtop.Ethc));

		// NOK
		NextOfKin nok = voPatient.getNok();
		//WDEV-12974 Name no longer mandatory so if any nok field has a value proceed
		if ((dtop.Name != null && dtop.Name.length() > 0) || (dtop.Nadr1 != null && dtop.Nadr1.length() > 0)
				|| (dtop.Nadr2 != null && dtop.Nadr2.length() > 0) || (dtop.Nadr3 != null && dtop.Nadr3.length() > 0)
				|| (dtop.Nadr4 != null && dtop.Nadr4.length() > 0) || (dtop.Nntel != null && dtop.Nntel.length() > 0)
				|| (dtop.Nkmobile != null && dtop.Nkmobile.length() > 0))
		{
			if (nok == null)
				nok = new NextOfKin();
			// name
			PersonName name = nok.getName();
			if (name == null)
			{
				name = new PersonName();
				nok.setName(name);
			}

			name.setSurname(dtop.Name);		
			// Address
			PersonAddress noka = nok.getAddress();
			if (noka == null)
			{
				noka = new PersonAddress();
				nok.setAddress(noka);
			}
			noka.setLine1(dtop.Nadr1);
			noka.setLine2(dtop.Nadr2);
			noka.setLine3(dtop.Nadr3);
			noka.setLine4(dtop.Nadr4);
			noka.setPhone(dtop.Nntel);
			
			noka.setAddressType(AddressType.NOKHOME);

			
			// Communication Channels - Work Phone and Mobile
			if (nok.getCommChannels() == null)
			{
				nok.setCommChannels(new CommChannelVoCollection());
			}
			nok.addCommunicationChannel(ChannelType.WORK_PHONE, dtop.Ndtel);		
			nok.addCommunicationChannel(ChannelType.MOBILE, dtop.Nkmobile);
		

			// Relationship
			if (dtop.Rel == null || dtop.Rel.length() <= 0)
			{
				// Used for Irish Pas - Relationship not a coded item - PAS outputs the text for NOK Relationship
				dtop.Rel = dtop.Kinreldesc;
			}
			nok.setRelationship((PersonRelationship) getLookupService().getLocalLookup(PersonRelationship.class, PersonRelationship.TYPE_ID, extSystem, dtop.Rel));
			voPatient.setNok(nok);
		}
		else
			voPatient.setNok(null);

		NationalHealthCoverVo insurance;
		if ((insurance = voPatient.getNationalHealthCover()) == null)
		{
			insurance = new NationalHealthCoverVo();
			voPatient.setNationalHealthCover(insurance);
		}
		insurance.setHealthActCategory((PersonHealthActCategory) getLookupService().getLocalLookup(PersonHealthActCategory.class, PersonHealthActCategory.TYPE_ID, extSystem, dtop.Healthcat));
		insurance.setMedicalCardNo(dtop.Medcardno);
		// wdev-7328 - null values in insurance are causing unnecessary patient updates
		// check value now, and if not set, clear the insurance for the patient
		if (insurance.getHealthActCategory() == null && (insurance.getMedicalCardNo() == null || insurance.getMedicalCardNo().equals("")))
			voPatient.setNationalHealthCover(null);

		if ((dtop.Gpcd!= null) && (dtop.Gpcd.length() > 0 &&  !dtop.Gpcd.equals("0")))
		{
			GPAdmin gpAdmin = (GPAdmin) getDomainImpl(GPAdminImpl.class);
			GP gp = gpAdmin.getGPByTaxonomyType(dtop.Gpcd, TaxonomyType.PAS);
			voPatient.setGp(gp);
			
			if (gp != null &&
					gp.getPracticesIsNotNull() && gp.getPractices().size() > 0)
			{
				if (gp.getPractices().get(0) != null)
				{
					OrganisationWithSitesVo gpPracticeVo = gp.getPractices().get(0).getPractice();
					if (gpPracticeVo != null && gpPracticeVo.getLocationSitesIsNotNull() && gpPracticeVo.getLocationSites().size() > 0)
					{
						LocSiteVo locSiteVo = gpPracticeVo.getLocationSites().get(0);
						LocSiteShortVo surgeryVo = new LocSiteShortVo(locSiteVo.getBoId(), locSiteVo.getBoVersion());
						surgeryVo.setAddress(locSiteVo.getAddress());
						surgeryVo.setAllSecureAccommodation(locSiteVo.getAllSecureAccommodation());
						surgeryVo.setCodeMappings(locSiteVo.getCodeMappings());
						surgeryVo.setIsActive(locSiteVo.getIsActive());
						surgeryVo.setIsVirtual(locSiteVo.getIsVirtual());
						surgeryVo.setIsRIE(locSiteVo.getIsRIE());
						surgeryVo.setName(locSiteVo.getName());
						surgeryVo.setReferringHospital(locSiteVo.getReferringHospital());
						surgeryVo.setSecureAccommodation(locSiteVo.getSecureAccommodation());
						surgeryVo.setTreatingHosp(locSiteVo.getTreatingHosp());
						surgeryVo.setType(locSiteVo.getType());
						voPatient.setGpSurgery(surgeryVo);
						
					}
					
				}
			}
		}
		
		// Convert the Value object to a business object and save to the local database
		try
		{
			voPatient = replicatePatient(voPatient);
		}
		catch (DomainInterfaceException e)
		{
			throw new DomainRuntimeException("replicate Patient failed " + e.getMessage());
		}
		
		// Set Allergies & Allerts
		voPatient.setHasAlerts(hasAlerts(voPatient.getID_Patient()));
		
		//Set PatientAlertsCategory
		PatientAlertCategoriesVo alertCategories = hasAlertsCategories(voPatient);		
		voPatient.setHasAlertCategory1(alertCategories.getHasAlertCategory1() != null ? alertCategories.getHasAlertCategory1() : false);
		voPatient.setHasAlertCategory2(alertCategories.getHasAlertCategory2() != null ? alertCategories.getHasAlertCategory2() : false);
		voPatient.setHasAlertCategory3(alertCategories.getHasAlertCategory3() != null ? alertCategories.getHasAlertCategory3() : false);
		voPatient.setHasAlertCategory4(alertCategories.getHasAlertCategory4() != null ? alertCategories.getHasAlertCategory4() : false);
		voPatient.setHasAlertCategoryOther(alertCategories.getHasAlertCategoryOther() != null ? alertCategories.getHasAlertCategoryOther() : false);
		
		voPatient.setHasAllergies(hasAllergy(voPatient.getID_Patient()));

		if (voPatient.getIdentifiers() != null)
			voPatient.getIdentifiers().sort();
		if (voPatient.getCommChannels() != null)
			voPatient.getCommChannels().sort();
		
		return (voPatient);
	}
	
	//http://jira/browse/WDEV-12850
	private ims.core.patient.domain.objects.Patient getDomPatient(PatientShort patVo)
	{
		return getDomPatient(patVo,true);
	}
	
	private ims.core.patient.domain.objects.Patient getDomPatient(PatientShort patVo,boolean includeVerified)	
	{
		DomainFactory factory = getDomainFactory();

		if (patVo.getID_PatientIsNotNull())
		{
			return (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		}

		if (patVo.getIdentifiers() == null || patVo.getIdentifiers().size() == 0 || (patVo.getIdentifiers().get(0)) == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid identifier");
		}	
		ims.core.patient.domain.objects.Patient domPatient=null;
		int i=0;
		PatientId intfId = null;
	
		while (domPatient == null)
		{
			intfId = patVo.getIdentifiers().get(i);

			if (intfId.getIdValue() != null)
			{
				String idVal = intfId.getIdValue().trim();
				Integer nhsDup = intfId.getDuplicateNHSNum();
				
				if(nhsDup == null)
					nhsDup = 0;
				
				//wdev-9584 add verified as a field to check 
				//http://jira/browse/WDEV-12850
				String hql = "";

				if(includeVerified)
				{
					Boolean isVerified = intfId.getVerified()==null?Boolean.valueOf(false):intfId.getVerified();
					//if isVerified value being supplied to query is false - return false and null records
					if(!isVerified)
						hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue and ( ids.verified = False or ids.verified is null) and (ids.duplicateNHSNum is null or ids.duplicateNHSNum = :dupNHS) ";		
					else
						//return only records with true
						hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue and ids.verified = True and (ids.duplicateNHSNum is null or ids.duplicateNHSNum = :dupNHS) ";
				}
				else
				{
					hql = " from Patient p join p.identifiers as ids where ids.type = :idType and ids.value = :idValue and (ids.duplicateNHSNum is null or ids.duplicateNHSNum = :dupNHS) ";
				}
				java.util.List patientList = factory.find(hql, new String[]{"idValue", "idType", "dupNHS"}, new Object[]{idVal, getDomLookup(intfId.getType()), nhsDup});
				if (patientList != null && !patientList.isEmpty())
				{
					// 	Patient Should be unique per id value and type
					if (patientList.size() > 1)
					{
						throw new DomainRuntimeException("More than one patient found with identifier type = " + intfId.getType() + " and value = " + idVal);
					}
					domPatient = (ims.core.patient.domain.objects.Patient) patientList.get(0);
					if(domPatient!=null)//http://jira/browse/WDEV-18798
					{
						domPatient.setPrimaryIdValueUsed(idVal);
					}
				}
			}
			i++;
			if (i >= patVo.getIdentifiers().size())
				break;
		}
		
		return domPatient;
	}

	public Patient getPatient(PatientRefVo patRef)
	{
		if (patRef != null && patRef.getID_PatientIsNotNull())
		{
			DomainFactory factory = getDomainFactory();
			ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patRef.getID_Patient().intValue());
			if (patBo == null) 
				return null;
			
			return getLocalPatient(patBo);
		}
		return null;
	}
	
	public Patient getLocalPatient(PatientShort patient)
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient);
		return getLocalPatient(domPatient);
	}

	protected Patient getLocalPatient(ims.core.patient.domain.objects.Patient domPatient)
	{
		if (domPatient == null) 
			return null;

		//recurse to get master patient if this patient was merged
		ims.core.patient.domain.objects.Patient foundPatient = domPatient;
		boolean isMergedPatient = false;
		while(domPatient.getAssociatedPatient() != null)
		{
			domPatient = domPatient.getAssociatedPatient();
			isMergedPatient = true;
		}
		//WDEV-22567 
		if (isMergedPatient)
		{	
			triggerMergeAlertMessage(domPatient, foundPatient);
		}
		//WDEV-22567
		
		Patient voPatient = PatientAssembler.create(domPatient);
		if (voPatient != null && voPatient.getAge() == null)   //wdev-14325
			voPatient.calculateAge();
		
		if (voPatient != null && voPatient.getCommChannels() != null)	//wdev-14325
			voPatient.getCommChannels().sort();
		
		// Set Allergies & Allerts
		if(voPatient != null) //wdev-14325
		{
			voPatient.setHasAlerts(hasAlerts(domPatient.getId()));
			
			PatientAlertCategoriesVo alertCategories = hasAlertsCategories(voPatient);
			voPatient.setHasAlertCategory1(alertCategories.getHasAlertCategory1() != null ? alertCategories.getHasAlertCategory1() : false);
			voPatient.setHasAlertCategory2(alertCategories.getHasAlertCategory2() != null ? alertCategories.getHasAlertCategory2() : false);
			voPatient.setHasAlertCategory3(alertCategories.getHasAlertCategory3() != null ? alertCategories.getHasAlertCategory3() : false);
			voPatient.setHasAlertCategory4(alertCategories.getHasAlertCategory4() != null ? alertCategories.getHasAlertCategory4() : false);
			voPatient.setHasAlertCategoryOther(alertCategories.getHasAlertCategoryOther() != null ? alertCategories.getHasAlertCategoryOther() : voPatient.getHasAlerts());
			
			voPatient.setHasAllergies(hasAllergy(domPatient.getId()));
		}

		
		return voPatient;
	}
	
	//WDEV-22567
	private void triggerMergeAlertMessage(ims.core.patient.domain.objects.Patient domPatient,ims.core.patient.domain.objects.Patient foundPatient)
	{
		DomainSession session = getSession();
		boolean bShowDomainMessage = true;
		SessionData sessData = (SessionData)session.getAttribute(SessionConstants.SESSION_DATA);
		String mergedDomainMessage = domPatient.getMergedMessage(foundPatient);
		if (sessData != null)
		{	
			ArrayList<String> messages = sessData.domainMessageBox.get();
			if (messages != null && messages.contains(mergedDomainMessage))
				bShowDomainMessage = false;			
		}
		if (bShowDomainMessage)
		{			
			raiseAlert(mergedDomainMessage);
		}
	}

	private ims.core.vo.Patient replicatePatient(ims.core.vo.Patient voPatient) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		voPatient.getName().setUppers();
		if (voPatient.getIsActive() == null)
			voPatient.setIsActive(Boolean.TRUE);

		voPatient.getName().setUppers();
		if (voPatient.getOtherNames() != null)
		{
			for (int i = 0; i < voPatient.getOtherNames().size(); i++)
			{
				voPatient.getOtherNames().get(i).setUppers();
			}
		}
		if (voPatient.getIdentifiers() != null)
		{
			for (int i = 0; i < voPatient.getIdentifiers().size(); i++)
			{
				PatientId patId = voPatient.getIdentifiers().get(i);
				//WDEV-10116
				String val = patId.getIdValue().trim();
				if(!ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
				{
					val = val.toUpperCase();
				}
				patId.setValue(val);
			}			
		}
		if (voPatient.getIsActive() == null)
			voPatient.setIsActive(Boolean.TRUE);

		// WDEV-6633 - call this method as it handles duplicate NHS numbers
		return savePatientRecord(getDomainFactory(), voPatient, 0, false, true);
	}

	public Boolean hasAlerts(Integer patientID)
	{
		if (patientID == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory(); 
		//WDEV-3160  - filter lists if the patient has any alerts, active or inactive, but not if recorded in error.
		//WDEV-11040 is now superceding above WDEV-3160 and including active in teh search criteria
		String filter = "select count (alert.id) from PatientAlert as alert where ( alert.isRIE = false or alert.isRIE is null ) and alert.isCurrentlyActiveAlert = true and alert.patient.id = :idPatient"; 
		List alerts = factory.find(filter, new String[]{"idPatient"}, new Object[]{patientID}); 
		int count = 0;
		if(alerts.size() > 0)
		{
			if(alerts.get(0) instanceof Integer)
				count = ((Integer)alerts.get(0)).intValue();
			else
				count = ((Long)alerts.get(0)).intValue();
		}
		
		return Boolean.valueOf(count > 0);
	}

	public PatientAlertCategoriesVo hasAlertsCategories(Patient patient)
	{
		if(patient == null)
			throw new CodingRuntimeException("Can not get PatientAlertCategories on null Patient.");
		
		DomainFactory factory = getDomainFactory();
		List<?> alertCategories = factory.find("from PatientAlertCategories as alert where alert.patient.id = :idPatient", new String[] {"idPatient"}, new Object[] {patient.getID_Patient()});
		
		if(alertCategories == null || alertCategories.size() == 0)
		{
			PatientAlertCategoriesVo result = new PatientAlertCategoriesVo();
			result.setPatient(patient);
			result.setHasAlertCategory1(false);
			result.setHasAlertCategory2(false);
			result.setHasAlertCategory3(false);
			result.setHasAlertCategory4(false);
			result.setHasAlertCategoryOther(patient.getHasAlerts() != null ? patient.getHasAlerts() : false);
			return result;
		}
		
		return PatientAlertCategoriesVoAssembler.create((PatientAlertCategories) alertCategories.get(0));
	}
	
	public Boolean hasAllergy(Integer patientID)
	{
		if (patientID == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory();

		String filter = "select count (allergy.id) from PatientAllergy as allergy where ( allergy.isRIE = false or allergy.isRIE is null ) and allergy.isCurrentlyActiveAllergy = true and allergy.patient.id = :idPatient";
		List allergys = factory.find(filter, new String[]{"idPatient"}, new Object[]{patientID});
		int count = 0;
		if(allergys.size() > 0)
		{
			if(allergys.get(0) instanceof Integer)
				count = ((Integer)allergys.get(0)).intValue();
			else
				count = ((Long)allergys.get(0)).intValue();
		}
		
		return Boolean.valueOf(count > 0);
	}
	
	public GP getPatientGp(GpShortVo gp)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.resource.people.domain.objects.Gp doGp = (ims.core.resource.people.domain.objects.Gp) factory.getDomainObject(ims.core.resource.people.domain.objects.Gp.class, gp.getID_Gp());
		return GPAssembler.create(doGp);
	}

	public String createPatientNumber(Integer patNum) //WDEV-20260
	{
		if(patNum==null)
			return null;
		if (!ConfigFlag.DOM.USE_PATIENT_NUMBER.getValue())
		{
			return null;
		}
		else
		{
			try
			{
				String preFixFlagValue = ConfigFlag.DOM.PATIENT_NUMBER_PREFIX.getValue().trim();
				if("NONE".equalsIgnoreCase(preFixFlagValue)) //http://jira/browse/WDEV-21512
				{
					return patNum.toString();
				}
				else
				{
					String patNumPrefix=preFixFlagValue.substring(0,2);
					DecimalFormat numFormatter = new DecimalFormat("00000000");
					return patNumPrefix+numFormatter.format(patNum);
				}

			} catch (IndexOutOfBoundsException ioobe)
			{
				throw new CodingRuntimeException ("PATIENT_NUMBER_PREFIX must be 2 characters");
			}
		}
		
	}

	//WDEV-19715 - overide savePatient() if no death details entered pass null and do not update RTT
	public Patient savePatient(Patient patient, Boolean fromInterface) throws UniqueKeyViolationException, StaleObjectException, DomainInterfaceException, IndexOutOfBoundsException
	{
		return savePatient(patient, fromInterface, null);
	}
	
	private Patient savePatient(Patient patient, Boolean fromInterface, Boolean patientDodSaved) throws UniqueKeyViolationException, StaleObjectException, DomainInterfaceException, IndexOutOfBoundsException
	{
		DomainFactory factory = getDomainFactory();
		factory.setDirtyCheck(true);
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		patient.getName().setUppers();
		if (patient.getOtherNames() != null)
		{
			for (int i = 0; i < patient.getOtherNames().size(); i++)
			{
				patient.getOtherNames().get(i).setUppers();
			}
		}
		return this.savePatientRecord(factory, patient, 1, fromInterface, patientDodSaved);
	}	
	//WDEV-19715 --- end
	
	// wdev-7328 - default is not from dtoCall
	private Patient savePatientRecord(DomainFactory factory, Patient patient, int duplicateCount, boolean fromInterface, Boolean patientDodSaved) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		return savePatientRecord(factory, patient, duplicateCount, fromInterface, false,  patientDodSaved);
	}
	private Patient savePatientRecord(DomainFactory factory, Patient patient, int duplicateCount, boolean fromInterface, boolean fromDtoReplicate, Boolean patientDodSaved) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException
	{
		//WDEV-18245		
		ims.core.patient.domain.objects.Patient preSavedPatient = null;
		String savedPatientPostcode = "";
		LocSite savedSurgery = null;
			
		if (ConfigFlag.UI.USE_HEARTS_CONTRACTING.getValue())
		{			 
			if (patient.getID_PatientIsNotNull())
			{
				preSavedPatient = getDomPatient(patient);
				if (preSavedPatient != null)
				{
					savedPatientPostcode = preSavedPatient.getAddress()!=null?preSavedPatient.getAddress().getPostCode():"";
					savedSurgery = preSavedPatient.getGpSurgery();
				}
			}
		}
		
		//WDEV-18245
		if (patient.getIdentifiers() != null && !ConfigFlag.DOM.CASE_SENSITIVE_PATID.getValue())
		{
			for (int i = 0; i < patient.getIdentifiers().size(); i++)
			{
				PatientId patId = patient.getIdentifiers().get(i);
				String val = patId.getIdValue().trim();
				patId.setValue(val.toUpperCase());
			}			
		}
		if (patient.getIsActive() == null)
			patient.setIsActive(Boolean.TRUE);

		// WDEV-14130 For NOK Address, we need to enforce the address type as NOKHOME
		if (patient.getNokIsNotNull() && patient.getNok().getAddressIsNotNull())
			patient.getNok().getAddress().setAddressType(AddressType.NOKHOME);

		boolean bBlankTempAddress = false;
		if(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue() == true && !fromInterface)
		{
			
			if(patient.getAddressesIsNotNull())
			{
				if(patient.getAddresses().size() > 0)
				{
					for (int i = 0 ; i< patient.getAddresses().size() ; i++)
					{
						PersonAddress voTempAddress = patient.getAddresses().get(i);
						
						if (voTempAddress != null //To save a blanked / deleted address need to have an empty object to save in DTO / PAS. Cater for it here.
							&& voTempAddress.getAddressType() == null 
							&& voTempAddress.getLine1() == "")
						{
							bBlankTempAddress = true;
							patient.getAddresses().remove(i);
							break;
						}
					}
				}
			}
		}

		ims.core.patient.domain.objects.Patient domPatient = PatientAssembler.extractPatient(factory, patient);	
		
		try
		{
			boolean newPatient = false;
			// wdev-9585
			// set the newPatient flag to true if the id is null
			if (domPatient.getId() == null)
			{
				domPatient.setIsNewPatient(true);
				newPatient = true;
			}
			else
			{
				domPatient.setIsNewPatient(false);
				newPatient = false;
			}

			
			// wdev-2034 To force a deletion of re-insertion of identifiers
			// it is necessary to clear the collection and re-set the values.
			
			// wdev-7328 - If the number of items are the same? then don't clear?  don't want
			// constant updates from dto
			if (!fromDtoReplicate || (domPatient.getIdentifiers().size() != patient.getIdentifiers().size()))
			{
				// Check all verified values, if null, default to false
				for (int i=0; i<patient.getIdentifiers().size(); i++)
				{
					PatientId curId = patient.getIdentifiers().get(i);
					if (curId != null && curId.getType().equals(PatIdType.NHSN) && !curId.getVerifiedIsNotNull())
					{
						curId.setVerified(false);
					}
				}
				domPatient.getIdentifiers().clear();
				List lst = PatientIdAssembler.extractPatientIdList(factory, patient.getIdentifiers());
				domPatient.setIdentifiers(lst);
			}


			// Keep medical insurance for a new patient as this is a two step save process
			// but these saves must be performed after the patient was saved to DTO (HEARTS, etc.)
			PatientMedicalInsurance doPatientMedicalInsurance = null;
			if (newPatient)
			{
				doPatientMedicalInsurance = domPatient.getCurrentMedicalInsurance();
				domPatient.setCurrentMedicalInsurance(null);	//wdev-19528
			}

			// Replicate patient into DTO (HEARTS)
			// This will save the patient to database
			domPatient = savePatientToDto(factory, domPatient, patient, fromInterface, fromDtoReplicate, bBlankTempAddress);
			//WDEV-19571
			if (patient != null)
			{
				boolean cancleAppts = patient.getCancelSD_APPTSIsNotNull()?patient.getCancelSD_APPTS():false;
				String  alias = patient.getSaveAlias() != null ? patient.getSaveAlias() : ""; //WDEV-20259
				
				patient = PatientAssembler.create(domPatient);
				
				patient.setCancelSD_APPTS(cancleAppts);
				patient.setSaveAlias(alias.length() > 0 ? alias : null);
			}
			
			// If Patient Medical Insurance was retain, then this is a new patient and needs to have
			// the PatientMedicalInsurance added back to the domain object 
			if( doPatientMedicalInsurance != null)
			{
				domPatient.setCurrentMedicalInsurance(null);
				doPatientMedicalInsurance.setPatient(domPatient);
				domPatient.setCurrentMedicalInsurance(doPatientMedicalInsurance);
			}

			if (ConfigFlag.DOM.USE_PATIENT_NUMBER.getValue())
			{
				if ( domPatient.isIsNewPatient()!=null &&  domPatient.isIsNewPatient().booleanValue()==true &&
						domPatient.getId()!=null && !PatIdType.NHSN.equals(PatIdType.getNegativeInstance(ConfigFlag.GEN.GENERATE_PATID_TYPE.getValue())))   //wdev-15754 WDEV-19224, wdev-18684
				{	
					String patNum=createPatientNumber(domPatient.getId());
					ims.core.patient.domain.objects.PatientId patNumberId= new ims.core.patient.domain.objects.PatientId();
					patNumberId.setValue(patNum);
					//patNumberId.setType(getDomLookup ( PatIdType.PATNUM));
					patNumberId.setType(getDomLookup ( PatIdType.getNegativeInstance(ConfigFlag.GEN.GENERATE_PATID_TYPE.getValue()))); //wdev-15754
					domPatient.getIdentifiers().add(patNumberId);

					//wdev-19170
					if( ConfigFlag.GEN.MRN_PROVIDED_BY_EXTERNAL_PAS.getValue() == true )
					{
						domPatient.setMRNStatus(getDomLookup(MRNStatus.WAITING));
					}
					//-------------
				}
			}
			//19682
			boolean cancelFutureAppts = ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
					&& Boolean.TRUE.equals(patient.getCancelSD_APPTS());
			
			if (patientDodSaved != null)
			updatePatientDeceasedData(patient, null, cancelFutureAppts , patientDodSaved);
						
			domPatient.setSaveComplete(true); // wdev-9585  at last save now

			if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue()
				&& ! ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue()
				&& patient.getSaveAliasIsNotNull())
			{
				boolean bFound = false;
				//save the alias in other names 
				List othNames = domPatient.getOtherNames();
				for (int i = 0 ; i < othNames.size() ; i++)
				{
					ims.core.generic.domain.objects.PersonName doPN = (ims.core.generic.domain.objects.PersonName)othNames.get(i);
					if (doPN.getNameType()!= null && doPN.getNameType().getId() == NameType.ALIAS.getID()) // Wdev-18404
					{
						doPN.setSurname(patient.getSaveAlias());
						doPN.setUpperSurname(patient.getSaveAlias().toUpperCase()); //wdev-18307
						domPatient.getOtherNames().set(i, doPN);
						bFound = true;
					}
				}
				if ( !bFound)
				{
					ims.core.generic.domain.objects.PersonName doPN =  new ims.core.generic.domain.objects.PersonName();
					doPN.setSurname(patient.getSaveAlias());
					doPN.setUpperSurname(patient.getSaveAlias().toUpperCase()); //wdev-18307
					doPN.setNameType(getDomLookup ( NameType.ALIAS));
					domPatient.getOtherNames().add(doPN);
				}
			}
			
			factory.save(domPatient);
			
			//Alert Categories		
			PatientAlertCategoriesVo alertCategories = hasAlertsCategories(patient);
			PatientAlertCategories alertCategoriesDomainObject = PatientAlertCategoriesVoAssembler.extractPatientAlertCategories(factory, alertCategories);
			factory.save(alertCategoriesDomainObject);
			

			if (ConfigFlag.DOM.USE_ALIAS_SURNAME_FUNCTIONALITY.getValue()
				&& ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue()
				&& patient.getSaveAliasIsNotNull())
			{
				if (patient.getHospnum() == null)
				{
					Patient savedPatient = PatientAssembler.create(domPatient); // patient is being created in CCO and the hospnum needs to be reteieved, so get patient.
					savedPatient.setSaveAlias(patient.getSaveAlias());
					saveAlias(savedPatient);
				}
				else
					saveAlias(patient);
			}

			//WDEV-18245
			if (ConfigFlag.UI.USE_HEARTS_CONTRACTING.getValue() && !fromInterface)
			{
				//check if there is a closed emergency attendance record
				//check postcode of address
				boolean attendenceRecode = false;
				if (preSavedPatient != null)
				{
					//compare postcodes WDEV-19684 WDEV-22871
					attendenceRecode = (savedPatientPostcode != null && patient.getAddress() != null) ? !savedPatientPostcode.equals(patient.getAddress().getPostCode()):(patient.getAddressIsNotNull() ? patient.getAddress().getPostCodeIsNotNull() : false);					
					
					if (!attendenceRecode)
						//compare gp surgery selection
						attendenceRecode = savedSurgery!=null?!savedSurgery.equals(patient.getGpSurgery()):(savedSurgery==null?patient.getGpSurgeryIsNotNull():false);
				}
				
				if (attendenceRecode)
				{
					// get closed emergency attendance with a date between now and RECODE_ATTENDANCE_UPON_GP_OR_ADDRESS_CHANGE days previous
					String hsql = "select ea from EmergencyAttendance as ea " +
							"where (ea.id not in (select arc.attendance.id  from AttendanceRequiringContracting as arc where arc.status is null)) " +
							"and ea.patient.id = :patientId " +
							"and  ea.dischargeDateTime is not null " +
							"and  ea.dischargeDateTime >= :fromDate";
					DateTime toDate = new DateTime();
					DateTime fromDate = new DateTime();
					
					int minusDAys = ConfigFlag.DOM.RECODE_ATTENDANCE_UPON_GP_OR_ADDRESS_CHANGE.getValue()>0?ConfigFlag.DOM.RECODE_ATTENDANCE_UPON_GP_OR_ADDRESS_CHANGE.getValue()*-1:ConfigFlag.DOM.RECODE_ATTENDANCE_UPON_GP_OR_ADDRESS_CHANGE.getValue();
					fromDate.addDays(minusDAys);
					List emergencyAttendance=factory.find(hsql, new String[] {"patientId","fromDate"}, new Object[] {patient.getID_Patient(),fromDate.getJavaDate(),toDate.getJavaDate()});
					if (emergencyAttendance!=null && emergencyAttendance.size()>0)
					{
						for (int i=0;i<emergencyAttendance.size();i++)
						{
							createAttendanceRequiringCodingRecord((EmergencyAttendance)emergencyAttendance.get(i),factory);
						}
					}
					
				}					
			}		
			//WDEV-18245			
			
		}
		catch (UnqViolationUncheckedException e)
		{
			// now we need to figure out which type and id caused the exception
			// go through the collection of identifiers for the patient and try a getpatient for each one
			// for the one that is successful this is then the one that caused the unique constraint violation			
			PatientId voPatId = null;
			for (int i = 0; i < patient.getIdentifiers().size(); i++)
			{
				voPatId = patient.getIdentifiers().get(i);
				PatientIdCollection voCollIds = new PatientIdCollection();
				voCollIds.add(voPatId);
				ims.core.vo.Patient voPatFilter = new ims.core.vo.Patient();
				voPatFilter.setIdentifiers(voCollIds);
				
				// WDEV-11121
				// Catch the DomainRuntimeException thrown by getDomPatient() called by getLocalPatient()
				// At this point we already expect an exception and we want to display a message to the user
				// not crash the application
				try
				{
					if((voPatFilter = getLocalPatient(voPatFilter)) != null)  // wdev-6383
					{	 
						if(!voPatFilter.getID_Patient().equals(domPatient.getId()))  
						{
							// wdev-1276
							// If a flag is set to allow duplicate NHS Numbers, and the
							// duplicity is on the NHS number, then we can go ahead and
							// create one, otherwise, throw back the error
							if (ConfigFlag.GEN.ALLOW_DUPLICATE_NHS_NUMBERS.getValue() && voPatId.getType().equals(PatIdType.NHSN))
							{
								/**
								 * We want to clear the ID for new records as otherwise,
								 * hibernate attempts to do a get using the given id, and
								 * the record may not be there.
								 */
								//if (newPatientClinical)
								//	patient.setID_Patient(null);//WDEV-1015
								/*String nhsValue = voPatId.getIdValue().trim();

								int pos = nhsValue.indexOf(" (DUP");
								if (pos > 0)
									nhsValue = nhsValue.substring(0, pos);
								voPatId.setValue(nhsValue + " (DUP" + duplicateCount + ")");*/
								
								Boolean isTheSameNHS = Boolean.FALSE;
								Integer dup = getDuplicateNumber(factory, voPatId, patient.getID_Patient(), isTheSameNHS);
								voPatId.setDuplicateNHSNum(++ dup);
								
								// Try the save again
								return (savePatientRecord(factory, patient, ++duplicateCount, fromInterface, patientDodSaved));
							}


							throw new UniqueKeyViolationException("A Patient with this " + voPatId.getType().getText() + " already exists", e);
						}
						//wdev-4188 Removed this and it sorted the problem	-> patient.setID_Patient(null); //WDEV-1015

					}
				}
				catch (DomainRuntimeException exception)
				{
					throw new UniqueKeyViolationException(exception.getMessage());
				}
			}
			throw new UniqueKeyViolationException("A Unique Constraint Violation Exception has occurred. Another Patient has this Identifier already.", e);			
		}
		//http://jira/browse/WDEV-17262
		if(patient.getPatientAlertsIsNotNull()&&patient.getPatientAlerts().size()!=0)
		{
			updatePatientNoAlertInfo(patient);
		}

		Patient voPatient = PatientAssembler.create(domPatient);

		//WDEV-23085
		if (voPatient.getID_PatientIsNotNull())
		{
			boolean isCurrentlyInED = isCurrentlyInED(voPatient);
			if (isCurrentlyInED)
			{	
				EmergencyAttendance currentEDAttendance = updateCurrentEDAttendance(voPatient);
				factory.save(currentEDAttendance);
			}
		}

		return voPatient;
	}
	////WDEV-23085
	private boolean isCurrentlyInED(Patient patientVo)
	{
		if (patientVo == null || patientVo.getID_Patient() == null)
			return false;
		
		Object ob  = getCurrentAttendance(patientVo, true);
		if (ob != null && ob instanceof Boolean)
			return ((Boolean) ob).booleanValue();
		return false;
	}

	private EmergencyAttendance updateCurrentEDAttendance(Patient voPatient)
	{		
		if (voPatient == null || voPatient.getID_Patient() == null)
			return null;
		
		Object ob  = getCurrentAttendance(voPatient, false);
		EmergencyAttendance domAttendance = null;
		if (ob != null && ob instanceof EmergencyAttendance)
		{
			domAttendance = (EmergencyAttendance) ob;
			domAttendance.setAgeAtAttendance(voPatient.getDobIsNotNull() ? calculateAgeAtAttendance(voPatient, domAttendance.getArrivalDateTime()) : null);			
		}
		return domAttendance;		
	}
	private Integer calculateAgeAtAttendance(Patient voPatient, java.util.Date arrivalDate)
	{
		PartialDate dob = voPatient.getDob();
		Date dod = voPatient.getDod();
		int patAge = 0;
		
		if (dob != null)
		{
			if (dod != null)
			{
				patAge = dod.yearDiff(dob);
			}
			else
			{
				patAge = arrivalDate != null ?  new ims.framework.utils.Age(dob, new Date(arrivalDate)).getYears() :  new ims.framework.utils.Age(dob, new Date()).getYears();
			}
			return new Integer(patAge);
		}			
		return null;	
	}

	private Object getCurrentAttendance(Patient voPatient, boolean returnAsCount)
	{
		StringBuilder sb = new StringBuilder();
		
		sb.append(returnAsCount ? "select count(ed.id)" : "select ed" );
		sb.append(" from EmergencyAttendance as ed left join ed.patient as pat where (ed.isRIE is null or ed.isRIE = false) and ed.dischargeDateTime is null and pat.id = :ID"); 
		sb.append(returnAsCount ?  "" :	" order by ed.registrationDateTime desc");
		
		DomainFactory domainFactory = getDomainFactory();
		String finalQuery = sb.toString();
		String[] paramNames = new String[]{"ID"};
		Object[] paramValues = new Object[] {voPatient.getID_Patient()};
		if (returnAsCount)
		{			
			long count = domainFactory.countWithHQL(finalQuery, paramNames, paramValues);
			return new Boolean(count > 0);			
		}		
			
		EmergencyAttendance domAttendance = (EmergencyAttendance) domainFactory.findFirst(finalQuery, paramNames, paramValues);
		return domAttendance;
	}
	////WDEV-23085 --end
	private Integer getDuplicateNumber(DomainFactory factory, PatientId voPatId, Integer patientId, Boolean isTheSameNHS)
	{
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		if(patientId != null)
		{
			String query = "select iden.value, iden.duplicateNHSNum from Patient as pat left join pat.identifiers as iden left join iden.type as idenType where iden.value = :NHSNumber and idenType.id = -9 and pat.id = :PatientId";
			paramNames.add("NHSNumber");
			paramValues.add(voPatId.getIdValue().trim());
			
			paramNames.add("PatientId");
			paramValues.add(patientId);
			
			List<?> listDupNHSNumber = factory.find(query, paramNames, paramValues);
			
			if(listDupNHSNumber != null && listDupNHSNumber.size() > 0)
			{
				Object[] items = (Object[]) listDupNHSNumber.get(0);
				
				if(items[1] instanceof Integer)
				{
					isTheSameNHS = Boolean.TRUE;
					return ((Integer) items[1]) - 1;
				}
			}
		}
		
		String query = "select iden.value, iden.duplicateNHSNum from Patient as pat left join pat.identifiers as iden left join iden.type as idenType where iden.value = :NHSNumber and idenType.id = -9 ";
		paramNames.add("NHSNumber");
		paramValues.add(voPatId.getIdValue().trim());
		
		if(patientId != null)
		{
			query += " and pat.id = :PatientId";
			paramNames.add("PatientId");
			paramValues.add(patientId);
		}
		
		List<?> listDupNHSNumber = factory.find(query, paramNames, paramValues);
		
		Integer dup = 0;
		
		if(listDupNHSNumber != null)
		{
			for(int x=0; x<listDupNHSNumber.size(); x++)
			{
				Object[] items = (Object[]) listDupNHSNumber.get(x);
				if(items[1] instanceof Integer && ((Integer) items[1]) >= dup)
				{
					dup = (Integer) items[1];
				}
			}
		}
		
		return dup;
	}
	
	//WDEV-18245
	private void createAttendanceRequiringCodingRecord(EmergencyAttendance emergencyAttendance,DomainFactory domainfactory) throws StaleObjectException
	{	
		if (emergencyAttendance == null )
		{
			return;
		}
		
		AttendanceRequiringContracting doAttendanceRequiringContracting=new AttendanceRequiringContracting();
		doAttendanceRequiringContracting.setPatient(emergencyAttendance.getPatient());
		doAttendanceRequiringContracting.setAttendance(emergencyAttendance);
		
		domainfactory.save(doAttendanceRequiringContracting);			
		
	}
	//WDEV-18245
	
	//WDEV-18413
	private void revertRTTStatus(Patient patient) throws StaleObjectException
	{
		List <?> listofReferralsDO = getCatsReferralsToRevert(patient);
		
		if (listofReferralsDO == null || listofReferralsDO.size() == 0)
		{
			return;
		}
		
		for (int i=0; i<listofReferralsDO.size();i++)
		{
			if (listofReferralsDO.get(i) instanceof CatsReferral)
			{
				revertRTTforCatsReferral((CatsReferral) listofReferralsDO.get(i));
			}	
		}
		
	}
	
	private  List<?> getCatsReferralsToRevert(Patient patient)
	{
		String hql = "select ref from CatsReferral as ref left join ref.patient as pat left join ref.journey as journ left join journ.currentClock as currClock where currClock is not null and pat.id = :patientID";

		DomainFactory factory = getDomainFactory();

		List<?> results = factory.find(hql, new String[]{"patientID"}, new Object[] {patient.getID_Patient()});

		if (results != null && results.size() > 0)
		{
			return results;
		}
		
		return null;
	}

	private void revertRTTforCatsReferral(CatsReferral catsReferral) throws StaleObjectException
	{
		int nationalCode = RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE;

		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue() || Boolean.FALSE.equals(catsReferral.isRTTClockImpact()))
			return;	

		if (catsReferral == null || (catsReferral != null && catsReferral.getCurrentRTTStatus() != null && catsReferral.getCurrentRTTStatus().getRTTStatus() != null &&  nationalCode != catsReferral.getCurrentRTTStatus().getRTTStatus().getNationalCode().intValue()))
			return;
		
		DomainFactory factory = getDomainFactory();
		
		if (catsReferral.getJourney() != null && catsReferral.getJourney().getCurrentClock() != null)
		{
			
			PathwayClock currentClock = catsReferral.getJourney().getCurrentClock();
			
			int statusHistorySize = currentClock.getRTTStatusHistory().size();
			
			if (statusHistorySize >= 2)
			{
				//current Status will be the second to last from the status history
				PathwayRTTStatus currentRTTStatus = ((PathwayRTTStatus)currentClock.getRTTStatusHistory().get(statusHistorySize - 2));
				
				currentClock.setCurrentRTTStatus(currentRTTStatus);
				catsReferral.setCurrentRTTStatus(currentRTTStatus);
				
				currentClock.getRTTStatusHistory().remove(statusHistorySize - 1);
			}
			
			factory.save(catsReferral);
		}
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private void saveRTTStatusForPatientRIP(Patient patient, java.util.Date eventDateTime) throws StaleObjectException, DomainInterfaceException  //WDEV-18326
	{
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		List <?> listofReferralsDO = getCatsReferralsforPatient(patient);

		if (listofReferralsDO == null || listofReferralsDO.size() == 0)
		{
			return;
		}
		DomainFactory factory = getDomainFactory();
		Object mosUser = getMosUser();
		for (int i=0; i<listofReferralsDO.size();i++)
		{
			if (listofReferralsDO.get(i) instanceof CatsReferral)
			{
				CatsReferral catsRefDO = (CatsReferral) listofReferralsDO.get(i); 
				updateRTTStatusAndJourney(catsRefDO, eventDateTime); //WDEV-20060
				catsRefDO = endOfCareReferral(factory, catsRefDO, mosUser);
				
				factory.save(catsRefDO);	
			}	
		}
	}

	private CatsReferral endOfCareReferral(DomainFactory factory, CatsReferral catsRefDO, Object mosUser)
	{
		if (catsRefDO == null)
			return null;
					
		MemberOfStaff domainMOS = null;
		
		if (mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
		}
		
		try
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.AdminEventImpl");
			IEndOfCareCatsReferralHelper adminEventImpl = (IEndOfCareCatsReferralHelper) getDomainImpl(implClass);
			catsRefDO = adminEventImpl.endOfCareReferralAndUpdateConsultationAppointment(factory, catsRefDO, catsRefDO.getPatient().getDod(), domainMOS);
		}
		catch (ClassNotFoundException e)
		{
			//Log the exception in system, should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}
		catch (StaleObjectException ex)
		{
			
		}
		catch (DomainInterfaceException e)
		{
			
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return catsRefDO;
	}

	//WDEV-20060
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private void updateRTTStatusAndJourney(CatsReferral catsRefDO, java.util.Date eventDateTime) throws StaleObjectException, DomainInterfaceException //WDEV-18326 
	{
		int nationalCode = RTT_PATIENT_DIED_BEFORE_TREATMENT_NAT_CODE;

		if (catsRefDO == null ||  !Boolean.TRUE.equals(catsRefDO.isRTTClockImpact()) || (catsRefDO.getCurrentRTTStatus() != null && catsRefDO.getCurrentRTTStatus().getRTTStatus() != null && nationalCode == catsRefDO.getCurrentRTTStatus().getRTTStatus().getNationalCode()))
			return;

		PatientPathwayJourney journeyDO = catsRefDO.getJourney();
		PathwayRTTStatus rttSTatusDO = createPathwRTTStatus(nationalCode,isInpatient(catsRefDO.getPatient()), eventDateTime);//WDEV-23292
				
		if (journeyDO != null)
		{			
			journeyDO = updateJourneyStatus(journeyDO, catsRefDO.getPatient().getDod());

			if (journeyDO.getCurrentClock() != null)
			{				
				//WDEV-18446
				journeyDO.getCurrentClock().setStopDate(catsRefDO.getPatient().getDod());

				journeyDO.getCurrentClock().setCurrentRTTStatus(rttSTatusDO);

				List<PathwayRTTStatus> ptwClockHistory = journeyDO.getCurrentClock().getRTTStatusHistory();

				if (ptwClockHistory == null)
				{
					ptwClockHistory = new java.util.ArrayList();
				}
				ptwClockHistory.add(rttSTatusDO);

				instantiatePatientEvent(catsRefDO, rttSTatusDO);	
			}	
		}
		catsRefDO.setCurrentRTTStatus(rttSTatusDO);
	}
	
	private PatientPathwayJourney updateJourneyStatus(PatientPathwayJourney journeyDO, java.util.Date dateOfDeath)
	{
		if (journeyDO == null)
			return null;
		
		PatientJourneyStatus journeyStatus = new PatientJourneyStatus();
		journeyStatus.setDateTime(dateOfDeath);
		journeyStatus.setStatus(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY));
		
		if (journeyDO.getStatusHistory() == null)
		{
			journeyDO.setStatusHistory(new HashSet());
		}		
	
		journeyDO.setEndedOnDate(dateOfDeath);
		journeyDO.setCurrentStatus(journeyStatus);
		journeyDO.getStatusHistory().add(journeyStatus);
		
		return journeyDO;
	}
	
	
	//WDEV-20060 --- ends here
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwRTTStatus(int nationalCode,boolean isInpatient, java.util.Date eventDateTime) ///WDEV-23292 throws StaleObjectException //WDEV-18326
	{
		PathwayRTTStatus rttSTatusDO = new PathwayRTTStatus();

		RTTStatusPoint rttStatusPoint = getRTTStatusPointFromConfig(nationalCode);

		rttSTatusDO.setRTTStatus(rttStatusPoint);
		if(isInpatient)						//WDEV-23292
			rttSTatusDO.setSetting("I");	//WDEV-23292


		Object mos = getMosUser();
		MemberOfStaff doMos = null;

		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}

		rttSTatusDO.setStatusBy(doMos);
		rttSTatusDO.setStatusDateTime(eventDateTime);

		return rttSTatusDO;
	}
	
	private boolean isInpatient(ims.core.patient.domain.objects.Patient patient) ///WDEV-23292
	{
		if(patient!=null&& patient.getWard()!=null)
			return true;
		return false;
	}

	private  List<?> getCatsReferralsforPatient(Patient patient) //now get all referrals not EOC  -WDEV-20060
	{
		//WDEV-18497 removed from query "and cclock.stopDate is null"
		String hql = "select ref from CatsReferral as ref left join ref.currentStatus as cstatus left join ref.patient as pat where (ref.isRIE is null or ref.isRIE = 0) AND pat.id = :patientID AND cstatus.referralStatus.id <> :EOC";

		DomainFactory factory = getDomainFactory();

		List<?> results = factory.find(hql, new String[]{"patientID", "EOC"}, new Object[] {patient.getID_Patient(), ReferralApptStatus.END_OF_CARE.getID()});

		if (results != null && results.size() > 0)
		{
			return results;
		}
		return null;
	}

	private void instantiatePatientEvent(CatsReferral doCats, PathwayRTTStatus pathRTTStatDO) throws StaleObjectException, DomainInterfaceException //WDEV-18325
	{
		
		if (!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return;
		
		RTTStatusEventMapVo  rttEventMap = null;

		if (pathRTTStatDO != null)
		{
			rttEventMap = getRTTStatusEventMap(pathRTTStatDO.getRTTStatus());
		}
		if (rttEventMap == null || rttEventMap.getEvent() == null)
			return;

		PatientEventVo patEvent = new PatientEventVo();
		patEvent.setPatient((PatientRefVo) PatientListVoAssembler.create(doCats.getJourney().getPatient()));
		patEvent.setEvent(rttEventMap.getEvent());
		patEvent.setEventDateTime(new DateTime());
		patEvent.setEventStatus(EventStatus.ACTIVE);
		patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));
		
		try 
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
			ims.core.helper.IPathwayPatientEventHelper pathwayImp = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);
			pathwayImp.instantiatePatientEvent(patEvent);
		} 
		catch (ClassNotFoundException e) 
		{
			// You'll have to manage this -log the exception in system log please - but it should be fine
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
		}

	}

	private RTTStatusPoint getRTTStatusPointFromConfig(int nationalCode) //WDEV-18326
	{	
		String hql = "from RTTStatusPoint as rttpoint where rttpoint.nationalCode = :natCode";
		DomainFactory fact = getDomainFactory();

		List<?> results = fact.find(hql, new String[]{"natCode"}, new Object[] {nationalCode});
		if (results != null && results.size() != 0 && results.get(0) instanceof RTTStatusPoint)
		{	
			return (RTTStatusPoint) results.get(0);

		}
		return null;
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint) //WDEV-18326
	{
		if (rttStatusPoint == null || rttStatusPoint.getId() == null)	
			return null;

		String hql = "select event from RTTStatusEventMap as event left join event.currentRTTStatus as rttstat where event.active = 1 and rttstat.nationalCode = :natCode and event.encounterType is null ";

		DomainFactory factory = getDomainFactory();

		List<?> events = factory.find(hql, new String[]{"natCode"}, new Object[] {rttStatusPoint.getNationalCode()});

		if (events != null && events.size() != 0 && events.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) events.get(0));
		}
		return null;		
	}
	

	private void cancelFutureAppointments(Patient patient) throws StaleObjectException
	{
		if (patient == null || patient.getID_Patient() == null)
			return;
		
		// Get future appointments
		String query = "SELECT appt FROM Booking_Appointment AS appt LEFT JOIN appt.patient AS pat LEFT JOIN appt.apptStatus AS apptStat WHERE pat.id = :PAT_ID AND apptStat.id = :BOOKED_STATUS AND appt.appointmentDate >= :TODAY";
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("PAT_ID");			paramValues.add(patient.getID_Patient());
		paramNames.add("BOOKED_STATUS");	paramValues.add(Status_Reason.BOOKED.getID());
		paramNames.add("TODAY");			paramValues.add(new java.util.Date());
		
		BookingAppointmentLiteVoCollection bookedAppointments = BookingAppointmentLiteVoAssembler.createBookingAppointmentLiteVoCollectionFromBooking_Appointment(getDomainFactory().find(query, paramNames, paramValues));
		
		// Cancel future appointments
		if (bookedAppointments != null)
		{
			try
			{
				Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
				ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
				
				for (BookingAppointmentLiteVo appt : bookedAppointments)
				{
					Booking_AppointmentVo appointment = Booking_AppointmentVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(Booking_Appointment.class, appt.getID_Booking_Appointment()));
					appointment.setApptStatus(Status_Reason.CANCELLED);

					Appointment_StatusVo appointmentStatus = new Appointment_StatusVo();
					appointmentStatus.setStatus(Status_Reason.CANCELLED);
					appointmentStatus.setStatusReason(Status_Reason.SLOTOPENED);
					appointmentStatus.setStatusChangeDateTime(new DateTime());
					appointmentStatus.setSession(appointment.getSessionIsNotNull() ? appointment.getSession() : null); //WDEV-23185
					
					appointment.setCurrentStatusRecord(appointmentStatus);

					if (appointment.getApptStatusHistory() == null)
						appointment.setApptStatusHistory(new Appointment_StatusVoCollection());
					appointment.getApptStatusHistory().add(appointmentStatus);

					if (appointment.getSessionSlot() != null)
						appointment.getSessionSlot().setStatus(appointment.getSession().getAppropiateSessionSlotStatus()); //WDEV-18940

					sessionAdminImp.cancelAppt(appointment, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested when Patient was marked as DOD.");
				}
			}
			catch (ClassNotFoundException e)
			{
				// log the exception in system log - but it should be fine
				createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Not Found exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
			}
			catch (DomainInterfaceException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
	
	
	private void cancelSD_APPTS(Patient patient) throws DomainInterfaceException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return;

		Sd_appt apptRec = (Sd_appt)getDTOInstance(Sd_appt.class);
		apptRec.DataCollection.add();
		Sd_apptRecord rec = apptRec.DataCollection.get(0);

//		ret = put_text("*SERVICE", "SD_APPT");
//		ret = put_text("PKEY", pDoc->m_Patient.Demographics.pid);
//		ret = put_text("APPT_DT",DOD);
//		ret = put_text("ACTION", "CANCEL");
//		ret = Message(message,error);
		
		rec.Appt_idCollection.add();
		Sd_apptAppt_idRecord apptColl = rec.Appt_idCollection.get(0);
//		apptColl.Appt_dt = DTOHelper.convertToDtoDate(patient.getDod().getDate());
		apptColl.Appt_dt = ">" + DTOHelper.convertToDtoDate(patient.getDod().getDate());
		
		//rec.Hospnum = patient.getHospnum().getValue();
		rec.Pkey = patient.getPkey().getValue().toString();
		
		Result res = apptRec.executeAction("CANCEL");
		
		if (res != null 
			&& res.getId() < 0 
			&& res.getId() != -2
			&& res.getId() != -3)
			throw new DomainInterfaceException("Error occurred Cancelling Patient Appointments - " + res.getMessage());
	}

	private void saveAlias(Patient patient) throws DomainInterfaceException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return;

		if (patient.getHospnum() == null)
			throw new DomainInterfaceException("Attempting to save an Alias Failed - no hospital number supplied");
			
		Alias aliasRec = null;
		try
		{
			aliasRec  = (Alias) getDTOInstance(Alias.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		aliasRec.Filter.clear();
		aliasRec.DataCollection.add();
		AliasRecord dtoAlias = aliasRec.DataCollection.get(0);
	
		dtoAlias.Hospnum = patient.getHospnum().getIdValue();
		dtoAlias.Snm = patient.getSaveAlias();
		
		if (dtoAlias.Snm != "")
		{
			Result result = aliasRec.insert();
			if(result != null && result.getId() < 0)
				throw new DomainInterfaceException("Attempt to save Alias to Pas failed " + result.getMessage());
		}
	}

	private ims.core.patient.domain.objects.Patient savePatientToDto(DomainFactory factory, ims.core.patient.domain.objects.Patient domPatient, Patient voPatient, Boolean fromInterface, boolean fromDtoReplicate, boolean bBlankTempAddress) throws DomainInterfaceException, StaleObjectException
	{
		factory.save(domPatient);
		
		if (factory.isDirty(domPatient) || voPatient.getID_Patient() == null)
		{
			//WDEV- 6964 - update the pas and if new use the pasa generated hospnum for the local patient
			if(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue() == true && !fromInterface)
			{
				String[] newIds = updateOrInsertDTOPatient(voPatient, fromDtoReplicate, bBlankTempAddress);	


				if(newIds != null)
				{	
					ArrayList<String> paramNames = new ArrayList<String>();
					ArrayList<Object> paramValues = new ArrayList<Object>();

					// Perform a get on the patient by HOSPNUM to see if there was a save already
					String query = "SELECT pat FROM Patient AS pat LEFT JOIN pat.identifiers AS iden LEFT JOIN iden.type AS type WHERE iden.value = :ID_VAL AND type.id = :HOSP_TYPE";

					paramNames.add("ID_VAL");		paramValues.add(newIds[0]);
					paramNames.add("HOSP_TYPE");	paramValues.add(PatIdType.HOSPNUM.getId());

					DomainObject patientFromDTO = factory.findFirst(query, paramNames, paramValues);

					if (patientFromDTO instanceof ims.core.patient.domain.objects.Patient)
					{
						domPatient = (ims.core.patient.domain.objects.Patient) patientFromDTO;
					}

					ims.core.patient.domain.objects.PatientId patHospnumId = new ims.core.patient.domain.objects.PatientId();
					patHospnumId.setType(getDomLookup(PatIdType.HOSPNUM));
					patHospnumId.setValue(newIds[0]);
					domPatient.getIdentifiers().add(patHospnumId);

					ims.core.patient.domain.objects.PatientId patPkeyId = new ims.core.patient.domain.objects.PatientId();
					patPkeyId.setType(getDomLookup(PatIdType.PKEY));
					patPkeyId.setValue(newIds[1]);
					domPatient.getIdentifiers().add(patPkeyId);
				}
			}
		}

		factory.save(domPatient);
		factory.setDirtyCheck(false);

		return domPatient;
	}

	/**
	 * this method will try a get from DTO
	 * if a record is found it will be updated else an insert will occur
	 * @param fromDtoReplicate 
	 * @param patient
	 * @return
	 */
	private String[] updateOrInsertDTOPatient(Patient voPatient, boolean fromDtoReplicate, boolean bBlankTempAddressFields) throws DomainInterfaceException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		boolean isNew = false;
		
		//try a get
		DemographicsRecord dtoPatient = null;
		
		Demographics patRec = null;
		try
		{
			patRec = (Demographics) getDTOInstance(Demographics.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		patRec.Filter.clear();
		PatientId intfId = voPatient.getInterfaceId();
		Result result = null;
		if (intfId != null)
		{
			if (intfId.getType().equals(PatIdType.PKEY))
			{
				patRec.Filter.Pkey = intfId.getIdValue();
			}
			else if (intfId.getType().equals(PatIdType.HOSPNUM))
			{
				patRec.Filter.Hospnum = intfId.getIdValue();
			}
			else if (intfId.getType().equals(PatIdType.NHSN))
			{
				String strNHSN = intfId.getIdValue().replace(" ","");
				patRec.Filter.Nhsn =  strNHSN.length() > 10 ? strNHSN.substring(0, 10) : strNHSN;//wdev-18119
			}
			else if (intfId.getType().equals(PatIdType.CHARTNUM))
			{
				patRec.Filter.Chartnum = intfId.getIdValue();
			}
			else
			{
				throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
			}
			
			result = patRec.get();
			if (result != null)
				throw new DomainInterfaceException("Attempt to get from Pas failed " + result.getMessage());
				
			dtoPatient = patRec.DataCollection.get(0);
		}
		else
		{
			patRec.DataCollection.add();
			dtoPatient = patRec.DataCollection.get(0);
			isNew = true;
		}

		/////////////////////////////////////////////////
		
		if(voPatient.getNhsn() != null)
		{
			String strNHSN = voPatient.getNhsn().getValue().replace(" ","");
			dtoPatient.Nhsn =  strNHSN.length() > 10 ? strNHSN.substring(0, 10) : strNHSN;//wdev-18119
		}
		else
			dtoPatient.Nhsn = "";
		
		if(voPatient.getPkey() != null)
			dtoPatient.Pkey = voPatient.getPkey().getValue();
		else
			dtoPatient.Pkey = "";
		
		if(voPatient.getHospnum() != null)
			dtoPatient.Hospnum = voPatient.getHospnum().getValue();
		else
			dtoPatient.Hospnum = "";
		
		if(voPatient.getPpsn() != null)
			dtoPatient.Ppsn = voPatient.getPpsn().getValue();
		else
			dtoPatient.Ppsn = "";
		
		if(voPatient.getChartnum() != null)
			dtoPatient.Chartnum = voPatient.getChartnum().getValue();
		else
			dtoPatient.Chartnum = "";
		
		if(voPatient.getNameIsNotNull())
		{
			dtoPatient.Snm = voPatient.getName().getSurname();
			dtoPatient.Fnm1 = voPatient.getName().getForename();
			dtoPatient.Fnm2 = voPatient.getName().getMiddleName();
			
			if(voPatient.getName().getTitleIsNotNull())
				dtoPatient.Titl = DTOHelper.getPasMapping(getDomLookup(voPatient.getName().getTitle())); 
			else
				dtoPatient.Titl = "";
		}
		
		if(voPatient.getMaidenName() != null)
			dtoPatient.Snmb = voPatient.getMaidenName().getSurname();
		
		dtoPatient.Sex = DTOHelper.getPasMapping(getDomLookup(voPatient.getSex()));
		dtoPatient.Dob = DTOHelper.convertToDtoDate(voPatient.getDob());
		
		if(voPatient.getDodIsNotNull())
		{
			dtoPatient.Dod = DTOHelper.convertToDtoDate(voPatient.getDod().getDate());
			
			// WDEV-14378 - PAS will cancel appts, and the treatment plan actions
			if (ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
					&& voPatient.getCancelSD_APPTSIsNotNull()
					&& voPatient.getCancelSD_APPTS().booleanValue() )
				dtoPatient.Delpatact="Y";

			
		}
		else
			dtoPatient.Dod = "";

		if(voPatient.getAddressIsNotNull())
		{
			PersonAddress voPatAddress = voPatient.getAddress();
			dtoPatient.Adr1 = voPatAddress.getLine1();
			dtoPatient.Adr2 = voPatAddress.getLine2();
			dtoPatient.Adr3 = voPatAddress.getLine3();
			dtoPatient.Adr4 = voPatAddress.getLine4();
			dtoPatient.Post = voPatAddress.getPostCode();
		}
	
		if (voPatient.getHARCCodeIsNotNull())
			dtoPatient.Harc = voPatient.getHARCCode();

		//wdev-13498
		if((dtoPatient.Post == null || dtoPatient.Post.equals(""))
			&& (dtoPatient.Harc == null || dtoPatient.Harc.equals("")))
			dtoPatient.Harc = "X98";
		
		//WDEV-16975
		if (voPatient.getHARCCodeIsNotNull() && voPatient.getHARCCode().equals(""))
			dtoPatient.Harc = "";
			

		if(voPatient.getCommChannelsIsNotNull() && voPatient.getCommChannels().size() > 0)
		{
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE) != null)
				dtoPatient.Dtel  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE).getCommValue();
			else
				dtoPatient.Dtel = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.HOME_PHONE) != null)
				dtoPatient.Ntel  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.HOME_PHONE).getCommValue();
			else
				dtoPatient.Ntel = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.MOBILE) != null)
				dtoPatient.Mobile  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.MOBILE).getCommValue();		
			else
				dtoPatient.Mobile = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.FAX) != null)
				dtoPatient.Fax  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.FAX).getCommValue();		
			else
				dtoPatient.Fax = "";
			if(voPatient.getCommChannels().getCommunicationChannel(ChannelType.EMAIL) != null)
				dtoPatient.Email  = voPatient.getCommChannels().getCommunicationChannel(ChannelType.EMAIL).getCommValue();		
			else
				dtoPatient.Email = "";
		}
		else
		{
			dtoPatient.Dtel = "";
			dtoPatient.Ntel = "";
			dtoPatient.Mobile = "";
			dtoPatient.Fax = "";
			dtoPatient.Email = "";
		}

		dtoPatient.Mart = DTOHelper.getPasMapping(getDomLookup(voPatient.getMaritalStatus()));
		dtoPatient.Relg = DTOHelper.getPasMapping(getDomLookup(voPatient.getReligion()));

		String strEthc = DTOHelper.getPasMapping(getDomLookup(voPatient.getEthnicOrigin()));
		
		if (Boolean.TRUE.equals(ConfigFlag.UI.PAS_PATIENT_ETHNIC_ORIGIN_MANDATORY.getValue()) && "".equals(strEthc))
		{
			dtoPatient.Ethc = "Z";
		}
		else
		{
			dtoPatient.Ethc = strEthc;
		}

		if(voPatient.getNokIsNotNull())
		{
			if(voPatient.getNok().getNameIsNotNull())
			{
				dtoPatient.Name = voPatient.getNok().getName().getSurname();
				if(voPatient.getNok().getName().getTitleIsNotNull())
					dtoPatient.Ntitl = DTOHelper.getPasMapping(getDomLookup(voPatient.getNok().getName().getTitle())); 
				else 
					dtoPatient.Ntitl = "";
			} 
			
			if(voPatient.getNok().getAddressIsNotNull())
			{
				dtoPatient.Nadr1 = voPatient.getNok().getAddress().getLine1();
				dtoPatient.Nadr2 = voPatient.getNok().getAddress().getLine2();
				dtoPatient.Nadr3 = voPatient.getNok().getAddress().getLine3();
				dtoPatient.Nadr4 = voPatient.getNok().getAddress().getLine4();
				dtoPatient.Npost = voPatient.getNok().getAddress().getPostCode();
				dtoPatient.Nntel = voPatient.getNok().getAddress().getPhone();
			}
			
			if(voPatient.getNok().getCommChannelsIsNotNull())
			{
				if(voPatient.getNok().getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE) != null)
					dtoPatient.Ndtel = voPatient.getNok().getCommChannels().getCommunicationChannel(ChannelType.WORK_PHONE).getCommValue();
				else
					dtoPatient.Ndtel = "";
			}
			
			dtoPatient.Rel = DTOHelper.getPasMapping(getDomLookup(voPatient.getNok().getRelationship()));
		}
		//WDEV-12974 clear dto fields wher nok is null
		else{
			dtoPatient.Name = "";
			dtoPatient.Ntitl = "";
			dtoPatient.Nadr1 = "";
			dtoPatient.Nadr2 = "";
			dtoPatient.Nadr3 = "";
			dtoPatient.Nadr4 = "";
			dtoPatient.Npost = "";
			dtoPatient.Nntel = "";
			dtoPatient.Rel = "";
		}
				
		if(voPatient.getAddressesIsNotNull())
		{
			if(voPatient.getAddresses().size() > 0)
			{
				for (int i = 0 ; i< voPatient.getAddresses().size() ; i++)
				{
					PersonAddress voTempAddress = voPatient.getAddresses().get(i);
					
					if ((voTempAddress != null 
						&& voTempAddress.getAddressTypeIsNotNull() 
						&& DTOHelper.getPasMapping(getDomLookup(voTempAddress.getAddressType())) != null //WDEV-14510
						&& DTOHelper.getPasMapping(getDomLookup(voTempAddress.getAddressType())).equals("C")) )
					{
						dtoPatient.Tadr1 = voTempAddress.getLine1();
						dtoPatient.Tadr2 = voTempAddress.getLine2();
						dtoPatient.Tadr3 = voTempAddress.getLine3();
						dtoPatient.Tadr4 = voTempAddress.getLine4();
						dtoPatient.Tpost = voTempAddress.getPostCode();
						dtoPatient.Tdtel = voTempAddress.getOtherphone();
						dtoPatient.Tntel = voTempAddress.getPhone();
					}
				}
			}
			if (bBlankTempAddressFields)
			{
				dtoPatient.Tadr1 = "";
				dtoPatient.Tadr2 = "";
				dtoPatient.Tadr3 = "";
				dtoPatient.Tadr4 = "";
				dtoPatient.Tpost = "";
				dtoPatient.Tdtel = "";
				dtoPatient.Tntel = "";
			}
		}
		
		if(voPatient.getGpIsNotNull())
		{
			dtoPatient.Gmcnum = voPatient.getGp().getNationalCode();
			String gpCode=getGpMappingFromSurgery(voPatient.getGpSurgery()); //http://jira/browse/WDEV-18787
			if (gpCode==null||gpCode.equals(""))
				gpCode=getMappingForGp(voPatient.getGp());
			dtoPatient.Gpcd = gpCode;
			dtoPatient.Prcd = getMappingForGpSurgery(voPatient.getGpSurgery());
		}
		else
		{
			dtoPatient.Gmcnum = "";
			dtoPatient.Gpcd = "";
			dtoPatient.Prcd = "";
		}
		
		//wdev-12963
		if (ConfigFlag.GEN.CANCEL_APPOINTMENTS_WHEN_DOD_ENTERED.getValue()
			&& voPatient.getCancelSD_APPTSIsNotNull()
			&& voPatient.getCancelSD_APPTS().booleanValue() )
			dtoPatient.Delpatact = "Y"; 

		if(dtoPatient.Cnt == null || dtoPatient.Cnt.equals("")) 
			dtoPatient.Cnt = ConfigFlag.UI.PATIENT_REGISTRATION_DEFAULT_CASEFOLDER_LOCATION.getValue();//wdev-14659

		if (fromDtoReplicate)
			dtoPatient.Webadt = "Y";
		
		if(isNew)	
			result = patRec.insert();
		else
			result = patRec.update();
		
		if(result != null && result.getId() < 0)
			throw new DomainInterfaceException("Attempt to save to Pas failed " + result.getMessage());
		
		//return an array containing Hospnum and Pkey values generated by Pas
		if(isNew)	
			return new String[] {patRec.getLastResultData().getValue("HOSPNUM"), patRec.getLastResultData().getValue("PKEY")};
		
		return null;
	}
	
	//http://jira/browse/WDEV-18787
	private String getGpMappingFromSurgery(LocSiteShortVo locSiteShortVo)
	{
		String gpCode="";
		if(locSiteShortVo != null && locSiteShortVo.getCodeMappingsIsNotNull())
		{
			String surgeryCode=locSiteShortVo.getCodeMappings().getMappingValue(TaxonomyType.PAS);
			if(surgeryCode!=null)
			{
				int idx=surgeryCode.lastIndexOf('_');
				gpCode=surgeryCode.substring(idx+1);
			}
		}
		return gpCode;
	}
	
	private String getMappingForGpSurgery(LocSiteShortVo locSiteShortVo)
	{
		if(locSiteShortVo != null && locSiteShortVo.getCodeMappingsIsNotNull())
			return locSiteShortVo.getCodeMappings().getMappingValue(TaxonomyType.PAS);

		return "";
	}

	private String getMappingForGp(GpShortVo gp)
	{
		if(gp != null && gp.getCodeMappingsIsNotNull())
			return gp.getCodeMappings().getMappingValue(TaxonomyType.PAS);

		return "";
	}

	public Boolean deletePatient(Patient patient) throws StaleObjectException
	{
		if (!patient.isValidated())
		{
			throw new DomainRuntimeException("Patient VO has not been validated!");
		}
		if (patient.getID_Patient() == null)
			return Boolean.FALSE;

		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient().intValue());
		if (patBo == null)
			return Boolean.FALSE;

		// Check if patient is already inactive.
		if (patBo.isIsActive() != null && patBo.isIsActive().booleanValue() == false)
			return Boolean.TRUE;

		patBo.setIsActive(Boolean.FALSE);
		factory.save(patBo);
		return Boolean.TRUE;
	}

	public PatientShort getPatientShort(PatientRefVo patRefVo)
	{
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient patBo = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patRefVo.getID_Patient().intValue());
		return PatientShortAssembler.create(patBo);
	}
	
	public GpLiteToPracticeLiteVo synchronizeGPPracticeDetails(String strGPCode)  throws StaleObjectException, UniqueKeyViolationException
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;
	
		Gp_practice gpPracticeRecord = (Gp_practice) getDTOInstance(Gp_practice.class);
		gpPracticeRecord.Filter.Gp_code = strGPCode;
		GP voGP = null;
		
		Result gpPracticeGetResult = gpPracticeRecord.get();
		if (gpPracticeGetResult != null)
			return null;
		
		Gp_practiceRecord gp_practice_record = gpPracticeRecord.DataCollection.get(0);
		OrganisationVo voSavedPractice = null;
		if (gpPracticeGetResult == null && gp_practice_record != null) 
		{
			// Extract the organisation which is in effect the practice and the location site
			// which is in effect the surgery and synchronise them withthe current date.			
			
			// If the Practice is in csp, get it and populate from dto, otherwise just populate from dto.
			try
			{
				voSavedPractice = saveOrganisation(populatePracticeFromDTORecord(gp_practice_record));
			}
			catch (UniqueKeyViolationException e)
			{
				// DARA TODO Comm Channels
			}
							
			voGP =  saveGP(populateGpFromDTORecord(gp_practice_record, voSavedPractice));
			
			GpLiteToPracticeLiteVo voGpLiteToPracticeLite = new GpLiteToPracticeLiteVo();
			// Just need a get here to see if you already have a gppracticeslite record.
			
			GpPracticeLiteVo voGpPracticeLite = new GpPracticeLiteVo();
			voGpPracticeLite.setAddress(voSavedPractice.getAddress());
			voGpPracticeLite.setID_Organisation(voSavedPractice.getID_Organisation());
			voGpPracticeLite.setIsActive(voSavedPractice.getIsActive());
			voGpPracticeLite.setName(voSavedPractice.getName());
			voGpPracticeLite.setType(OrganisationType.GPP);
			
			LocSiteShortVo voLocSiteShort = getLocSiteShortByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
			LocSiteShortVoCollection voCollLocations = new LocSiteShortVoCollection();
			voCollLocations.add(voLocSiteShort);
			voGpPracticeLite.setSurgeries(voCollLocations);
			
			voGpLiteToPracticeLite.setGp(voGP == null ? null : voGP);
			voGpLiteToPracticeLite.setPractice(voGpPracticeLite);
			return voGpLiteToPracticeLite;
			
		}
		
		return null;
		
		
	}

	private LocSiteVo populateLocSiteFromDTORecord(Gp_practiceRecord gp_practice_record)
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		LocSiteVo voLocSite = getLocSiteByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
		if (voLocSite == null) 
		{
			voLocSite = new LocSiteVo();
			voLocSite.setCodeMappings(newTaxonomyMapFromDTORecord(gp_practice_record));
			voLocSite.setType(LocationType.SURGERY);
			voLocSite.setIsActive(Boolean.TRUE);
			voLocSite.setIsVirtual(Boolean.FALSE);
		}

		// Phone,fax,address1,2,3,4,5
		PersonAddress voPracticeAddress = extractPracticeAddressFromDTOPracticeRecord(gp_practice_record);
		if (voLocSite != null)
			voLocSite.setAddress(voPracticeAddress);

		voLocSite.setName(gp_practice_record.Practice_name);
		return voLocSite;
	}

	private OrganisationVo populatePracticeFromDTORecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		OrganisationVo voPractice = getOrganisationByTaxonomyType(gp_practice_record.Gp_practice_id, TaxonomyType.PAS);
		if (voPractice == null) 
		{
			voPractice = new OrganisationVo();
			voPractice.setCodeMappings(newTaxonomyMapFromDTORecord(gp_practice_record));
			voPractice.setType(OrganisationType.GPP);
			voPractice.setIsActive(Boolean.TRUE);	
		}

		// Phone,fax,address1,2,3,4,5
		PersonAddress voPracticeAddress = extractPracticeAddressFromDTOPracticeRecord(gp_practice_record);
		if (voPracticeAddress != null)
			voPractice.setAddress(voPracticeAddress);

		voPractice.setName(gp_practice_record.Practice_name);		
		LocSiteVo voSurgery  = populateLocSiteFromDTORecord(gp_practice_record);

		if (voPractice.getLocationSites() != null && voPractice.getLocationSites().size() == 1)
			voPractice.getLocationSites().set(0, voSurgery);				
		else if (voPractice.getLocationSitesIsNotNull())
			voPractice.getLocationSites().add(voSurgery);
		else
		{
			LocSiteVoCollection locCollVo = new LocSiteVoCollection();
			locCollVo.add(voSurgery);
			voPractice.setLocationSites(locCollVo);
		}
		
		
		return voPractice;
	}

	private TaxonomyMapCollection newTaxonomyMapFromDTORecord(Gp_practiceRecord gp_practice_record )
	{
		TaxonomyMap voTaxonomy = new TaxonomyMap();
		voTaxonomy.setTaxonomyName(TaxonomyType.PAS);
		voTaxonomy.setTaxonomyCode(gp_practice_record.Gp_practice_id);
		voTaxonomy.setDescription("DTO GP Practice");
		TaxonomyMapCollection voCollTaxonomyMap = new TaxonomyMapCollection();
		voCollTaxonomyMap.add(voTaxonomy);
		return voCollTaxonomyMap;
	}

	private GP populateGpFromDTORecord(Gp_practiceRecord gp_practice_record, OrganisationVo voGPPractice) 
	{
		if (gp_practice_record.Gp_id == null)
			return null;

		GP voGP = getGpByPasId(gp_practice_record.Gp_id);

		if (voGP == null) 
		{
			voGP = new GP();
			TaxonomyMap voTaxonomy = new TaxonomyMap();
			voTaxonomy.setTaxonomyName(TaxonomyType.PAS);
			voTaxonomy.setTaxonomyCode(gp_practice_record.Gp_id);
			voTaxonomy.setDescription("DTO GP");
			TaxonomyMapCollection voCollTaxonomyMap = new TaxonomyMapCollection();
			voCollTaxonomyMap.add(voTaxonomy);
			voGP.setCodeMappings(voCollTaxonomyMap);
		}

		voGP.setName(extractPersonNameFromGPPracticeRecord(gp_practice_record));
		voGP.setMobile(gp_practice_record.Gp_mobile_no == null ? null: gp_practice_record.Gp_mobile_no);
		voGP.setEmailAddress(gp_practice_record.Gp_email == null ? null: gp_practice_record.Gp_email);
						
		
		if (voGP.getID_Gp() == null)
		{			
			voGP.setPractices(newGpToPracticesCollectionFromDTORecord(gp_practice_record, voGP));
		}
		else
		{
			boolean bFound = false;
			int i=0;
			GpToPracticesVo voGpToPractice = new GpToPracticesVo();
			// gptopractice exists - find and update it
			for (i=0; i < voGP.getPractices().size(); i++)
			{
				voGP.getPractices().get(i).setIsPrimaryPractice(Boolean.FALSE);
				if ((voGP.getPractices().get(i).getPracticeIsNotNull()) && (voGP.getPractices().get(i).getPractice().getID_Organisation().equals(voGPPractice.getID_Organisation())))
				{
					voGpToPractice = voGP.getPractices().get(i); 
					bFound = true;
					break;
				} 
			}
			
			voGpToPractice.setGp(voGP);
			voGpToPractice.setPractice(voGPPractice);	
			voGpToPractice.setIsPrimaryPractice(Boolean.TRUE);

			if (bFound == false)
				voGP.getPractices().add(voGpToPractice);
			else
				voGP.getPractices().set(i, voGpToPractice);				
		}				

		voGP.setCommChannels(new CommChannelVoCollection());
		return voGP;		
	}
		
	private GpToPracticesVoCollection newGpToPracticesCollectionFromDTORecord(Gp_practiceRecord gp_practice_record, GpShortVo voGP )
	{
		GpToPracticesVo voGpToPractice = new GpToPracticesVo();
		voGpToPractice.setGp(voGP);
		voGpToPractice.setGpCode(gp_practice_record.Gp_code);
		// TODO voGpToPractice.setPractice(voGPPractice);
		voGpToPractice.setIsPrimaryPractice(Boolean.TRUE);
		GpToPracticesVoCollection voCollGpToPractices = new GpToPracticesVoCollection();
		voCollGpToPractices.add(voGpToPractice);
		return voCollGpToPractices;
	}

	private PersonAddress extractPracticeAddressFromDTOPracticeRecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record == null)
			return null;

		PersonAddress voPracticeAddress = new PersonAddress();

		voPracticeAddress.setPhone(gp_practice_record.Practice_phone_no == null ? null : gp_practice_record.Practice_phone_no);
		voPracticeAddress.setFax(gp_practice_record.Practice_fax_no == null ? null: gp_practice_record.Practice_fax_no);
		voPracticeAddress.setLine1(gp_practice_record.Address_line1 == null ? null: gp_practice_record.Address_line1);
		voPracticeAddress.setLine2(gp_practice_record.Address_line2 == null ? null: gp_practice_record.Address_line2);
		voPracticeAddress.setLine3(gp_practice_record.Address_line3 == null ? null: gp_practice_record.Address_line3);
		voPracticeAddress.setLine4(gp_practice_record.Address_line4 == null ? null: gp_practice_record.Address_line4);
		voPracticeAddress.setLine5(gp_practice_record.Address_line5 == null ? null: gp_practice_record.Address_line5);
		// TODO ask leader voPracticeAddress.setCounty()
		return voPracticeAddress;
	}

	private PersonName extractPersonNameFromGPPracticeRecord(Gp_practiceRecord gp_practice_record) 
	{
		if (gp_practice_record == null || gp_practice_record.Gp_surname == null	|| gp_practice_record.Gp_first_name == null)
			return null;

		PersonName voPersonName = new PersonName();
		PersonTitle voPersonTitle = new PersonTitle();
		voPersonTitle.setText(gp_practice_record.Gp_title == null ? null: gp_practice_record.Gp_title);
		voPersonName.setTitle(voPersonTitle);
		voPersonName.setForename(gp_practice_record.Gp_first_name);
		voPersonName.setSurname(gp_practice_record.Gp_surname);
		voPersonName.setUppers();
		return voPersonName;
	}
	
	private OrganisationVo saveOrganisation(OrganisationVo voOrganisation) throws StaleObjectException, UniqueKeyViolationException 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.saveOrganisation(voOrganisation);		
	}
	
	private GP getGpByPasId(String pasId) 
	{
		GPAdmin impl = (GPAdmin) getDomainImpl(GPAdminImpl.class);
		return impl.getGPByTaxonomyType(pasId, TaxonomyType.PAS);
	}

	public OrganisationVo getOrganisationByTaxonomyType(String extId,TaxonomyType taxonomyType) 
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getOrganisationByTaxonomyType(extId, taxonomyType);
	}
	
	private LocSiteVo getLocSiteByTaxonomyType(String extId,TaxonomyType taxonomyType)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getLocSiteByTaxonomyType(extId, taxonomyType);
	}

	private LocSiteShortVo getLocSiteShortByTaxonomyType(String extId,TaxonomyType taxonomyType)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getLocSiteShortByTaxonomyType(extId, taxonomyType);
	}
	
	private GP saveGP(GP voGP) throws StaleObjectException, UniqueKeyViolationException 
	{
		String[] arrErrors = null;
		if (voGP != null)
			arrErrors = voGP.validate();

		if (arrErrors != null)
			return null;
		
		GPAdmin impl = (GPAdmin) getDomainImpl(GPAdminImpl.class);
		return impl.saveGp(voGP);
		
	}

	/** 
	 * getPatientList
	 * This method will return an active patient, either the patient matching
	 * the search criteria provided, or it's equivalent new merged patient
	 * Used by HL7engine.
	 */
	public PatientLiteVo getPatientLite(PatientShort patVo)
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patVo);
		if (domPatient != null)
		{
			// Check associated value if not null, then get this patient
			while(domPatient.getAssociatedPatient() != null)
			{
				domPatient = domPatient.getAssociatedPatient();
			}
		}
		
		return PatientLiteVoAssembler.create(domPatient);
	}

	public DeathDetailsVo saveDeathDetails(DeathDetailsVo deathDetails) throws StaleObjectException 
	{
		// Ensure the value object has been validated
		if (!deathDetails.isValidated())
			throw new DomainRuntimeException("Death details has not been validated");
		
		DomainFactory factory = getDomainFactory();
		DeathDetails doDD = DeathDetailsVoAssembler.extractDeathDetails(factory, deathDetails);
		
		if (deathDetails.getIsRIE() != null)
			doDD.setIsRIE(deathDetails.getIsRIE());
		
		factory.save(doDD);
		
		return DeathDetailsVoAssembler.create(doDD);
	}
	
	//WDEV-18259
	private void updatePatientElectiveListsForDOD(PatientShort patientShort) throws StaleObjectException
	{
		if (!ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
			return;

		DomainFactory factory = getDomainFactory();

		String patientElectiveListQuery = "select electiveList from PatientElectiveList as electiveList left join electiveList.electiveListStatus as elStatus left join elStatus.electiveListStatus as stat left join electiveList.patient as pat where pat.id = :patId and stat.id <> :statusId";
		List<?> electiveList = factory.find(patientElectiveListQuery, new String[] { "patId", "statusId" }, new Object[] { patientShort.getID_Patient(), WaitingListStatus.REMOVED.getID() });

		if (electiveList == null || electiveList.size() == 0)
			return;

		// update patientElectiveLists for current Patient
		PatientElectiveList doPatientElectiveList = null;

		MemberOfStaff domainMOS = null;
		Object mosUser = getMosUser();

		if (mosUser instanceof MemberOfStaffShortVo)
		{
			domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
		}

		Date currentDate = new Date();

		for (int i = 0; i < electiveList.size(); i++)
		{
			doPatientElectiveList = (PatientElectiveList) electiveList.get(i);

			if (doPatientElectiveList != null)
			{
				// create new Elective List Status
				ElectiveListStatus status = new ElectiveListStatus();
				status.setElectiveListStatus(getDomLookup(WaitingListStatus.REMOVED));
				status.setRemovalReason(getDomLookup(ElectiveListStatusReason.PATIENT_DIED));
				status.setAuthoringUser(domainMOS);
				status.setStatusDateTime(new java.util.Date());

				doPatientElectiveList.setElectiveListStatus(status);

				// add this status to the Status History
				if (doPatientElectiveList.getElectiveListStatusHistory() == null)
					doPatientElectiveList.setElectiveListStatusHistory(new ArrayList());

				doPatientElectiveList.getElectiveListStatusHistory().add(status);

				// update the future TCIs
				TCIForPatientElectiveList doTCIDetails = doPatientElectiveList.getTCIDetails();

				//WDEV-19489 Cancel the Open Case Note Requests for the TCI
				if (doTCIDetails != null)
					cancelCaseNoteRequests(doTCIDetails.getId());
				
				if (doTCIDetails != null && doTCIDetails.isIsActive() && doTCIDetails.getTCIDate() != null && currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) <= 0)
				{
					
					// create a new Outcome
					TCIOutcomeForPatientElectiveList newOutcome = new TCIOutcomeForPatientElectiveList();

					if (currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) < 0)
					{
						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_BEFORE_6));
					}
					else if (currentDate.getDate().compareTo(doTCIDetails.getTCIDate()) == 0)
					{
						newOutcome.setOutcome(getDomLookup(AdmissionOfferOutcome.ADMISSION_CANCELLED_BY_HOSPITAL_ON_DAY_7));
					}

					newOutcome.setChangeBy(domainMOS);
					newOutcome.setStatusDateTime(new java.util.Date());
					newOutcome.setOutcomeReason(getDomLookup(TCIStatusChangeReason.CANCELLEDBYREMOVALOFELECTIVELISTRECORD));

					doTCIDetails.setCurrentOutcome(newOutcome);
					doTCIDetails.setIsActive(false);

					// add new outcome to Outcome History
					if (doTCIDetails.getOutcomeHistory() == null)
						doTCIDetails.setOutcomeHistory(new ArrayList());

					doTCIDetails.getOutcomeHistory().add(newOutcome);

				}
			}

			// Stop the current clock
			if (doPatientElectiveList.getReferral() != null && doPatientElectiveList.getReferral().getJourney() != null)
			{
				PatientPathwayJourney doJourney = doPatientElectiveList.getReferral().getJourney();

				if (doJourney != null && doJourney.getCurrentStatus() != null && !doJourney.getCurrentStatus().getStatus().equals(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY)))
				{

					PatientJourneyStatus journeyStatus = new PatientJourneyStatus();
					journeyStatus.setDateTime(new java.util.Date());
					journeyStatus.setStatus(getDomLookup(JourneyStatus.ENDPATHWAYJOURNEY));

					if (doJourney.getStatusHistory() == null)
					{
						doJourney.setStatusHistory(new HashSet());
					}

					if (doJourney.getCurrentClock() != null && doJourney.getCurrentClock().getStopDate() == null)
					{
						doJourney.getCurrentClock().setStopDate(patientShort.getDod().getDate());
					}

					doJourney.setEndedOnDate(patientShort.getDod().getDate());
					doJourney.setCurrentStatus(journeyStatus);
					doJourney.getStatusHistory().add(journeyStatus);

				}
			}

			factory.save(doPatientElectiveList);
		}
	}

	private void cancelCaseNoteRequests(Integer tciId) throws StaleObjectException
	{
		PatientCaseNoteRequestLiteVoCollection requestsForCancellation = getLinkedCaseNoteOpenRequests(tciId);
		
		if (requestsForCancellation == null || requestsForCancellation.size() == 0)
			return;
		
		Object mos = getMosUser();
		
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		
		for (int i = 0; i < requestsForCancellation.size(); i++)
		{
			impl.cancelRequest(requestsForCancellation.get(i), (MemberOfStaffRefVo) mos, CaseNoteRequestCancellationReason.TCI_CANCELLED); //WDEV-20989
		}
	}

	private PatientCaseNoteRequestLiteVoCollection getLinkedCaseNoteOpenRequests(Integer tciId)
	{
		if(tciId == null)
			   return null;
		
		List<?> list = getDomainFactory().find("select req from PatientCaseNoteRequest as req left join req.tCIDetail as tci left join req.requestStatus as status " +
				"where (tci.id = :tciID and status.id = :requestStatusID)", new String[] {"tciID", "requestStatusID"}, new Object[] {tciId, CaseNoteRequestStatus.OPEN.getID()});
		
		return PatientCaseNoteRequestLiteVoAssembler.createPatientCaseNoteRequestLiteVoCollectionFromPatientCaseNoteRequest(list);
	}

	public ims.core.vo.Patient getMergedPatient(PatientShort patient) 
	{
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient);
		// The id sent down for the patient could be the main one, we may need
		// to check whether this patient id is used as an associated patient anywhere!
		if (domPatient != null && domPatient.getAssociatedPatient() == null)
		{
			DomainFactory factory = getDomainFactory();
			List lst = factory.find("from Patient p where p.associatedPatient.id = :assoc", new String[]{"assoc"}, new Object[]{domPatient.getId()});
			if (lst != null && lst.size() > 0)
				return PatientAssembler.create((ims.core.patient.domain.objects.Patient) lst.get(0));
		}
		return PatientAssembler.create(domPatient);
	}

	public Patient saveDemographics(Patient patient, DeathDetailsVo deathDetails) throws StaleObjectException, UniqueKeyViolationException, DomainInterfaceException, IndexOutOfBoundsException
	{
		//WDEV-19715 start
		ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient);
		Boolean wasPatientDodSavedPreviously = domPatient != null && domPatient.getDod() != null;
		Boolean wasPatientDodSavedNow = false;
		
		saveDeathDetails(deathDetails);
				
		wasPatientDodSavedNow =  (deathDetails == null || (wasPatientDodSavedPreviously && patient.getDod() != null)) ? null :  domPatient != null && patient.getDod() != null && domPatient.getDod() == null;
		
		if(patient != null)
			return savePatient(patient, false, wasPatientDodSavedNow);
		
		//WDEV-19715 --- ends here
		return null;
	
	}

	public DeathDetailsVo getDeathDetails(PatientShort value)
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer(" from DeathDetails dd"); 
	
		ArrayList markers = new ArrayList();
		ArrayList values = new ArrayList();
	
		hql.append(" where dd.patient.id = :pId");
		
		markers.add("pId");
		values.add(value.getID_Patient());

		hql.append(" and dd.isRIE is null");


		List listNotes = factory.find(hql.toString(), markers,values);
		if(listNotes != null && listNotes.size() > 0)
		{ 
			DeathDetailsVoCollection voColl = DeathDetailsVoAssembler.createDeathDetailsVoCollectionFromDeathDetails(listNotes);
			if(voColl != null && voColl.size() > 0)
				return voColl.get(0);
		}
		return null;
		
	}

	/* New method
	 * http://jira/browse/WDEV-11792
	 * @see ims.core.domain.Demographics#validatePatient(ims.core.vo.Patient, ims.core.patient.vo.PatientRefVo)
	 */
	public String validatePatient(Patient patientVOFromMsg, PatientRefVo patientRefFromOrder) //http://jira/browse/WDEV-18798
	{
		
		if (!ConfigFlag.HL7.VALIDATE_MSG_PATIENT_WITH_ORDER_PATIENT.getValue())
		{
			// If the flag is not set always true i.e. the patient is always valid
			return "";
		}
		// Get the patient from the message
		ims.core.patient.domain.objects.Patient domPatientFromMsg = getDomPatient(patientVOFromMsg,false);
		if (domPatientFromMsg == null) 
			return null;

		//recurse to get master patient if this patient was merged
		while(domPatientFromMsg.getAssociatedPatient() != null)
		{
			domPatientFromMsg = domPatientFromMsg.getAssociatedPatient();
		}
		
		//get the patient from the order
		DomainFactory factory = getDomainFactory();
		ims.core.patient.domain.objects.Patient domPatientFromOrder = (ims.core.patient.domain.objects.Patient) factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patientRefFromOrder.getID_Patient().intValue());
		
		while(domPatientFromOrder.getAssociatedPatient() != null)
		{
			domPatientFromOrder = domPatientFromOrder.getAssociatedPatient();
		}
		
		if(domPatientFromOrder!=null&&domPatientFromMsg!=null&&
				domPatientFromOrder.getId()!=null&&
				domPatientFromOrder.getId().equals(domPatientFromMsg.getId()))
		{
			return domPatientFromMsg.getPrimaryIdValueUsed();
		}
		else 
		{
			return null;
		}

	}

	public CaseNoteFolderVo getCaseNoteFolderLocation(String strHospNum) 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		ims.dto.client.Patient patRec = (ims.dto.client.Patient) getDTOInstance(ims.dto.client.Patient.class);

		patRec.Filter.clear();
		if (strHospNum == null)
		{
			throw new DomainRuntimeException("CaseNote Get call must contain valid interface identifier");
		}

		patRec.Filter.Hospnum = strHospNum;

		Result result = patRec.get();
		if (result != null)
		{
			return null;//WDEV-14481
		//	throw new DomainRuntimeException("Error getting Case Note details for patient " + strHospNum + "\nError - " + result.getMessage());
		}

		ims.core.vo.CaseNoteFolderVo voCaseNote = new CaseNoteFolderVo();
		voCaseNote.setLocation(patRec.DataCollection.get(0).Cflname);
		voCaseNote.setComments(patRec.DataCollection.get(0).Cflcomm);

		return (voCaseNote);
	}

	//------------------wdev-8696----------------
	/*public AppImageVo getAppImage(Integer imageId) 
	{
		DomainFactory factory = getDomainFactory();
		return AppImageVoAssembler.create((AppImage)factory.getDomainObject(AppImage.class, imageId));
	}*/
	//----------------------------------------------

	//
	public void insertDTOHistoricAddress(PersonAddress previousAddress, String pkey) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return;

		HaddRecord dtoHistoricAddress = null;
		Hadd historicAddressRec = null;
		
		try
		{
			historicAddressRec = (Hadd) getDTOInstance(Hadd.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		historicAddressRec.Filter.clear();
		
		historicAddressRec.DataCollection.add();
		dtoHistoricAddress = historicAddressRec.DataCollection.get(0);
		
		dtoHistoricAddress.Hospnum = pkey;
		dtoHistoricAddress.Adr1 = previousAddress.getLine1();
		dtoHistoricAddress.Adr2 = previousAddress.getLine2();
		dtoHistoricAddress.Adr3 = previousAddress.getLine3();
		dtoHistoricAddress.Adr4 = previousAddress.getLine4();
		dtoHistoricAddress.Post = previousAddress.getPostCode();
		if(previousAddress.getNotificationDateIsNotNull())
			dtoHistoricAddress.Datefrom = DTOHelper.convertToDtoDate(previousAddress.getNotificationDate().getDate());
		//if(dtoPatient.Post == null || dtoPatient.Post.equals(""))
		//	dtoHistoricAddress.Harc = "X98";
			
		Result result = historicAddressRec.insert();
		
		//WDEV-13440 
		if(result != null && result.getId() == -5)
			throw new DomainInterfaceException("Attempt to save Historic Address to Pas failed, " + "Address already exists for this date.");
		if(result != null && result.getId() < 0)
			throw new DomainInterfaceException("Attempt to save Historic Address to Pas failed " + result.getMessage());
		
	}

	public String getCCOAlias(String szHospnum) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		Alias aliasRec = null;
		try
		{
			aliasRec  = (Alias) getDTOInstance(Alias.class);	
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		aliasRec.Filter.clear();
		aliasRec.Filter.Hospnum = szHospnum;
		
		Result result = aliasRec.list();
		
		//wdev-15845
		if( result != null && result.getId() == -7 )
			throw new DomainInterfaceException("Demographics details cannot be edited - Please contact the system administrator with the details for this patient");
		//-------------
		
		if(result != null 
			&& result.getId() < 0
			&& result.getId() != -2
			&& result.getId() != -3)
			throw new DomainInterfaceException("Attempt to list Alias from Pas failed - " + result.getMessage());
		
		if (result != null
			&& result.getId() == -2
			&& result.getId() == -3)
			return null;
		else
		{
			if (aliasRec.DataCollection.count() > 0)
				return aliasRec.DataCollection.get(0).Snm;
			else
				return null;
		}
	}

	public PersonAddressCollection getDTOHistoricAddresses(String hospnum) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;
		
		Hadd historicAddressRec = null;
		try
		{
			historicAddressRec  = (Hadd) getDTOInstance(Hadd.class);		
		}
		catch(ResultException e)
		{
			throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
		}
		
		PersonAddressCollection collPersonAddress = new PersonAddressCollection();
		
		historicAddressRec.Filter.clear();
		historicAddressRec.Filter.Hospnum = hospnum;
		
		Result result = historicAddressRec.list();
		
		if(result != null 
			&& result.getId() < 0
			&& result.getId() != -2
			&& result.getId() != -3)
			throw new DomainInterfaceException("Attempt to list Historic Addresses from Pas failed - " + result.getMessage());
		
		if (result != null
			&& result.getId() == -2
			&& result.getId() == -3)
			return null;
		else
		{
			for (int i = 0; i < historicAddressRec.DataCollection.count(); i++)
			{
				PersonAddress voPersonAddress = new PersonAddress();
			
				voPersonAddress.setLine1(historicAddressRec.DataCollection.get(i).Adr1);
				voPersonAddress.setLine2(historicAddressRec.DataCollection.get(i).Adr2);
				voPersonAddress.setLine3(historicAddressRec.DataCollection.get(i).Adr3);
				voPersonAddress.setLine4(historicAddressRec.DataCollection.get(i).Adr4);
				voPersonAddress.setAddressPostCode(historicAddressRec.DataCollection.get(i).Post);
				try {
					voPersonAddress.setNotificationDate(new Date(historicAddressRec.DataCollection.get(i).Datefrom, DateFormat.ISO));
				} catch (ParseException e) {
					e.printStackTrace();
				}
				voPersonAddress.setAddressType(AddressType.HISTORICAL);
				
				collPersonAddress.add(voPersonAddress);
			}
		}
		
		return collPersonAddress;
	}

	public ims.dto.client.Patient getCCODTOPatient(String pkey) throws DomainInterfaceException 
	{
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		if(pkey == null)
			throw new DomainRuntimeException("Cannot get Patient for null pkey");
		
		ims.dto.client.Patient patient = (ims.dto.client.Patient)getDTOInstance(ims.dto.client.Patient.class);
		patient.Filter.clear();
		patient.Filter.Pkey = pkey;
		
		Result result = patient.get();
		if (result != null)
		{
			if(result.getId() == -2)
				throw new DomainInterfaceException("Error Getting Patient Details for pkey = " + pkey);

			throw new DomainInterfaceException(result.getMessage());
		}

		if (patient.DataCollection.count()!= 1)
			throw new DomainInterfaceException("Failed to get patient record.");
		
		return patient;
	}
	//wdev-12889
	public LocSiteVo getLocationSite(LocationRefVo locSiteId) 
	{
		if(locSiteId == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		ims.core.resource.place.domain.objects.LocSite locSiteDO = (ims.core.resource.place.domain.objects.LocSite) factory.getDomainObject(ims.core.resource.place.domain.objects.LocSite.class, locSiteId.getID_Location());
		return LocSiteVoAssembler.create(locSiteDO);

	}

	//WDEV-16051
	public OrganisationWithSitesVo getGPPractice(OrganisationRefVo organisationRef)
	{
		if(organisationRef == null)
			throw new CodingRuntimeException("Cannot get Organisation on null Id.");
		
		return OrganisationWithSitesVoAssembler.create((Organisation) getDomainFactory().getDomainObject(Organisation.class, organisationRef.getID_Organisation()));
	}

	public String[] listPatientAlertsTextByTaxonomy(PatientRefVo patient,Boolean active, TaxonomyType type)
	{
		Alerts alerts = (Alerts) getDomainImpl(AlertsImpl.class);
		return alerts.listPatientAlertsTextByTaxonomy(patient, active, type);
	}

	//http://jira/browse/WDEV-17262
	private void updatePatientNoAlertInfo(PatientRefVo patient) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		String hql = new String("from PatientNoAlertInfo alertInfo where alertInfo.patient.id = :patient");
		List<?> list = factory.find(hql,new String[]{ "patient"},new Object[]{patient.getBoId()});
		if (list!=null||list.isEmpty())
		{
			for (Object object : list)
			{
				PatientNoAlertInfo alertInfo =(PatientNoAlertInfo)object;
				if(alertInfo.getAlertStatus()==null
						||alertInfo.getAlertStatus().equals(getDomLookup(PatientAlertStatus.NOKNOWNALERTS)))
				{
					alertInfo.setAlertStatus(getDomLookup(PatientAlertStatus.HASALERTS));
					factory.save(alertInfo);
				}
			}
		}	
	}

	//wdev-17883 - FWUI-1818
	public Patient getPatient(PatientShort patient, Boolean verify) throws StaleObjectException
	{
		if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("LOCAL"))
            return getLocalPatient(patient, verify.booleanValue());
        else if (ConfigFlag.DOM.PATIENT_SEARCH_TYPE.getValue().equals("DTO"))
        {
            try
            {
                 return getDTOPatient(patient);
            }
            catch (UniqueKeyViolationException e)
            {
                 throw new DomainRuntimeException(e);
            }
        }

		return null;

	}

	//wdev-17883- FWUI-1818
	public Patient getLocalPatient(PatientShort patient, Boolean includeVerifiedInSearch)
	{
        ims.core.patient.domain.objects.Patient domPatient = getDomPatient(patient,includeVerifiedInSearch);;
        return getLocalPatient(domPatient);

	}

	//wdev-19528
	public DemographicControlsConfigVoCollection getDemographicControlsConfig()
	{
		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("from DemographicControlsConfig");
		List<?> list = factory.find(hql.toString());
		if( list != null && list.size() > 0 )
			return DemographicControlsConfigVoAssembler.createDemographicControlsConfigVoCollectionFromDemographicControlsConfig(list);
				
		return null;
	}
	//WDEV-19682 //WDEV-19715
	public void updatePatientDeceasedData(Patient patient, DeathDetailsVo deathDetails, Boolean cancelFutureAppointments, Boolean wasPatientAlreadySavedAsDeceased) throws DomainInterfaceException, StaleObjectException
	{		
		if (deathDetails != null && !Boolean.TRUE.equals(wasPatientAlreadySavedAsDeceased))
		{	
			saveDeathDetails(deathDetails);			
		}		
		
		ims.core.patient.domain.objects.Patient patientDO = (ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient());
		
		if (patientDO != null && !Boolean.TRUE.equals(patientDO.isIsNewPatient()))
		{
			if ((Boolean.TRUE.equals(patient.getCancelSD_APPTS()) || Boolean.TRUE.equals(cancelFutureAppointments)) && (!wasPatientAlreadySavedAsDeceased || (wasPatientAlreadySavedAsDeceased && patient.getVersion_Patient() == patientDO.getVersion())))
			{
				if (Boolean.TRUE.equals(ConfigFlag.DOM.HEARTS_REPLICATE_PATIENTS.getValue()) && ConfigFlag.UI.BED_INFO_UI_TYPE.equals("CCO")) 
					cancelSD_APPTS(patient);
				else
					cancelFutureAppointments(patient);
			}		
			//WDEV-18326
			if (ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			{
				if (patient.getDod() != null && (!wasPatientAlreadySavedAsDeceased || (wasPatientAlreadySavedAsDeceased && patient.getVersion_Patient() == patientDO.getVersion())))
				{
					// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
					// When a Patient is marked as deceased, referrals that do get terminated by this operation must have the RTT Status set Date of Death
					java.util.Date eventDeathDetails = new DateTime(patient.getDod()).getJavaDate();
					saveRTTStatusForPatientRIP(patient, eventDeathDetails);
				}
				else  if (!wasPatientAlreadySavedAsDeceased && patient.getDod() == null)
					revertRTTStatus(patient);
			}			
			//WDEV-18259
			if (patient.getDod() != null && (!wasPatientAlreadySavedAsDeceased || (wasPatientAlreadySavedAsDeceased && patient.getVersion_Patient() == patientDO.getVersion())))
				updatePatientElectiveListsForDOD(patient);
			
			//WDEV-20371
			cancelPendingEmergencyTheatreRecords(patient);
			
		}	
	}

	private void cancelPendingEmergencyTheatreRecords(Patient patient) throws StaleObjectException
	{
		if (patient == null)
			return;
		
		DomainFactory factory = getDomainFactory();

		String hql = " select PET from PendingEmergencyTheatre as PET left join PET.patient as pat left join PET.catsReferral as referral left join PET.currentStatus as status " +
				     "where pat.id = :patID and status.id <> :removedStatusID and status.id <> :admittedStatusID";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();
		
		markers.add("patID");
		values.add(patient.getID_Patient());
		
		markers.add("removedStatusID");
		values.add(PendingEmergencyTheatreStatus.REMOVED.getID());
				
		markers.add("admittedStatusID");
		values.add(PendingEmergencyTheatreStatus.ADMITTED.getID());
		
		PendingEmergencyTheatreVoCollection pendingEmergencyTheatreRecords = PendingEmergencyTheatreVoAssembler.createPendingEmergencyTheatreVoCollectionFromPendingEmergencyTheatre(factory.find(hql, markers, values));
		
		if (pendingEmergencyTheatreRecords == null || pendingEmergencyTheatreRecords.size() == 0)
			return;
		
		for (int i = 0; i < pendingEmergencyTheatreRecords.size(); i++)
		{
			PendingEmergencyTheatreVo pendingEmergencyTheatre = pendingEmergencyTheatreRecords.get(i);

			pendingEmergencyTheatre.setCurrentStatus(PendingEmergencyTheatreStatus.REMOVED);
			pendingEmergencyTheatre.setRemovalDateTime(new DateTime());
			pendingEmergencyTheatre.setRemovalReason(PendingEmergencyTheatreRemovalReason.PATIENT_DIED);
			
			Object mosUser = getMosUser();
			
			if (mosUser instanceof MemberOfStaffShortVo)
			{
				pendingEmergencyTheatre.setRemovedBy((MemberOfStaffShortVo) mosUser);
			}

			PendingEmergencyTheatre domainPendingEmergencyTheatre = PendingEmergencyTheatreVoAssembler.extractPendingEmergencyTheatre(factory, pendingEmergencyTheatre);

			factory.save(domainPendingEmergencyTheatre);

		}
		
	}

	public Boolean hasAlertsForViewOrEdit(PatientRefVo patient, AlertTypeCollection alertsType)
	{
		if (patient == null || alertsType == null || alertsType.size() == 0)
			return false;

		DomainFactory factory = getDomainFactory(); 
		String alertCategoryIds = getAlertCategoryIds(alertsType);
		
		String filter = "select count (alert.id) from PatientAlert as alert left join alert.alertType as alertType where (alert.isRIE = false or alert.isRIE is null) and alert.isCurrentlyActiveAlert = true and alert.patient.id = :idPatient";
		
		if(alertCategoryIds != null)
		{
			filter += " and alertType.parent is not null and alertType.parent.id in (" + alertCategoryIds + ")";
		}
		
		List alerts = factory.find(filter, new String[]{"idPatient"}, new Object[]{patient.getID_Patient()});
		
		int count = 0;
		if(alerts.size() > 0)
		{
			if(alerts.get(0) instanceof Integer)
				count = ((Integer)alerts.get(0)).intValue();
			else
				count = ((Long)alerts.get(0)).intValue();
		}
		
		return Boolean.valueOf(count > 0);
	}

	private String getAlertCategoryIds(AlertTypeCollection alertsType)
	{
		if(alertsType == null)
			return null;
		
		String ids = "";
		for(int i=0; i<alertsType.size(); i++)
		{
			AlertType alertCat = alertsType.get(i);
			
			if(alertCat == null)
				continue;
			
			ids += (ids.length() > 0 ? "," : "") + alertCat.getID();
		}
		
		return ids.length() > 0 ? ids : null;
	}

	@Override
	//http://jira/browse/WDEV-22545
	public PatientIdCollection getPatientIdentifiers(PatientRefVo patient)
	{
		if(patient!=null)
		{
			String hql ="select ids.type,ids.value,ids.verified from Patient as pat left join pat.identifiers as ids  where (pat.id = :PATID) ";
			List<?> list  = getDomainFactory().find(hql, new String[]{"PATID"},new Object[] {patient.getID_Patient()});
			
			if(list!=null && list.size()>0)
			{
				PatientIdCollection patientIdCollection = new PatientIdCollection();
				for (Object object : list)
				{
					Object[] values = (Object[])object;
					PatientId patientId = new PatientId();
					
					LookupInstance  instance = (LookupInstance)values[0];
					if ( null != instance )
					{
						ims.framework.utils.ImagePath img = null;
						ims.framework.utils.Color color = null;		
						img = null;
						if (instance.getImage() != null) 
						{
							img = new ims.framework.utils.ImagePath(instance.getImage().getImageId(), instance.getImage().getImagePath());
						}
						color = instance.getColor();
						if (color != null) 
							color.getValue();
					
						ims.core.vo.lookups.PatIdType voLookup1 = new ims.core.vo.lookups.PatIdType(instance.getId(),instance.getText(), instance.isActive(), null, img, color);
					
						patientId.setType(voLookup1);
						patientId.setValue((String)values[1]);
						patientId.setVerified((Boolean)values[2]);
						patientIdCollection.add(patientId);
					}
				}
				return patientIdCollection;
			}
		}
		return null;
	}
	
	
	//WDEV-20593 - Delete patient record 
//	public void triggerDeletePatientEvent(ims.core.patient.domain.objects.Patient patient) throws StaleObjectException
//	{
//		triggerDemographicEvent(patient, MsgEventType.A29);	
//	}
//
//	
//	//WDEV-20593 - Added method for future functionality that might need to write different message event types to demographics queue
//	public void triggerDemographicEvent(ims.core.patient.domain.objects.Patient patient, LookupInstVo messageEventType) throws StaleObjectException
//	{
//		DomainFactory factory = getDomainFactory();
//		String hql = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i"
//				+ " where(i.id = "+QueueType.DEMOGRAPHICFEED.getId()+")";
//
//		java.util.List<ProviderSystem> list = factory.find(hql);
//
//		for (int i=0; i<list.size(); i++)
//		{
//		
//			ProviderSystem provider = (ProviderSystem) list.get(i);
//
//			DemographicsMessageQueue queue = new DemographicsMessageQueue();
//			
//			queue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
//			queue.setMsgType(getDomLookup(messageEventType));
//			queue.setQueueType(getDomLookup(QueueType.DEMOGRAPHICFEED));
//			queue.setPatient(patient);
//			queue.setProviderSystem(provider);
//
//			factory.save(queue);
//		}
//	}

}	
