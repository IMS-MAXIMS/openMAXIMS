//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.66 build 3271.26979)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.CATSReferral_ClockImpactVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.domain.CATSReferral_ClockImpactVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.RefMan.vo.lookups.AdmissionOfferOutcome;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.clinical.vo.InpatientEpisodeForVTERiskAsessmentVo;
import ims.clinical.vo.VTERiskAssessmentShortVo;
import ims.clinical.vo.VTERiskAssessmentShortVoCollection;
import ims.clinical.vo.domain.InpatientEpisodeForVTERiskAsessmentVoAssembler;
import ims.clinical.vo.domain.VTERiskAssessmentShortVoAssembler;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.BedSpaceStateStatus;
import ims.core.admin.pas.domain.objects.ConsultantStay;
import ims.core.admin.pas.domain.objects.DischargedEpisode;
import ims.core.admin.pas.domain.objects.HomeLeave;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.domain.objects.PendingTransfers;
import ims.core.admin.pas.domain.objects.TransferHistory;
import ims.core.admin.pas.domain.objects.WardBayConfig;
import ims.core.admin.pas.domain.objects.WardMixedSexBreach;
import ims.core.admin.pas.domain.objects.WardStay;
import ims.core.admin.pas.vo.BedSpaceStateRefVo;
import ims.core.admin.pas.vo.BedSpaceStateStatusRefVo;
import ims.core.admin.pas.vo.DischargedEpisodeRefVo;
import ims.core.admin.pas.vo.InpatientEpisodeRefVo;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.domain.objects.VTERiskAssessment;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.clinical.vo.VTERiskAssessmentRefVo;
import ims.core.configuration.domain.objects.AppUser;
import ims.core.configuration.vo.AppUserRefVo;
import ims.core.domain.ADT;
import ims.core.domain.AdmitToWard;
import ims.core.domain.Alerts;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.BedInfoDialog;
import ims.core.domain.CaseNoteTransfer;
import ims.core.domain.Demographics;
import ims.core.domain.InpatientEpisodeMaintenance;
import ims.core.domain.PDSDemographics;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.WardDataView;
import ims.core.domain.WardView;
import ims.core.domain.objects.PatientTransportRequirements;
import ims.core.helper.DTOHelper;
import ims.core.helper.IPathwayPatientEventHelper;
import ims.core.layout.domain.objects.BayConfig;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.AdmissionDetailForADTUpdateAdmissionVo;
import ims.core.vo.AdmissionDetailVo;
import ims.core.vo.AdmissionReasonVo;
import ims.core.vo.BayConfigLiteVo;
import ims.core.vo.BayTimesAdmissionBreachedVo;
import ims.core.vo.BedSpaceStateLiteVo;
import ims.core.vo.BedSpaceStateStatusLiteVo;
import ims.core.vo.BedSpaceStateStatusVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.ConsultantStayMinVo;
import ims.core.vo.DeathDetailsVo;
import ims.core.vo.DischargedEpisodeADTVo;
import ims.core.vo.DischargedEpisodeADTVoCollection;
import ims.core.vo.DischargedEpisodeForVTERiskAssessmentWorklistVo;
import ims.core.vo.DischargedEpisodeVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HealthyLodgerVo;
import ims.core.vo.HomeLeaveVo;
import ims.core.vo.InPatientEpisodeADTVo;
import ims.core.vo.InpatConsultantTransferVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.InpatientEpisodeLiteVoCollection;
import ims.core.vo.InpatientEpisodeTrackingMoveVo;
import ims.core.vo.InpatientEpisodeVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffShortVo;
import ims.core.vo.PasEventADTVo;
import ims.core.vo.PatientCaseNoteRequestLiteVoCollection;
import ims.core.vo.PatientCaseNoteTransferVoCollection;
import ims.core.vo.PatientCaseNoteVoCollection;
import ims.core.vo.PatientLite_IdentifiersVo;
import ims.core.vo.PatientShort;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.PatientTransportRequirementsVo;
import ims.core.vo.PendingTransfersLiteVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.TransferCancellationReasonDetailsVo;
import ims.core.vo.WardConfigLiteVo;
import ims.core.vo.WardMixedSexBreachVo;
import ims.core.vo.WardStayLiteVo;
import ims.core.vo.WardStayVo;
import ims.core.vo.WardStayVoCollection;
import ims.core.vo.domain.AdmissionDetailVoAssembler;
import ims.core.vo.domain.BayConfigLiteVoAssembler;
import ims.core.vo.domain.BedSpaceStateBayOnlyVoAssembler;
import ims.core.vo.domain.BedSpaceStateLiteVoAssembler;
import ims.core.vo.domain.BedSpaceStateStatusVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.ConsultantStayMinVoAssembler;
import ims.core.vo.domain.DischargedEpisodeADTVoAssembler;
import ims.core.vo.domain.DischargedEpisodeForVTERiskAssessmentWorklistVoAssembler;
import ims.core.vo.domain.DischargedEpisodeVoAssembler;
import ims.core.vo.domain.HomeLeaveVoAssembler;
import ims.core.vo.domain.InPatientEpisodeADTVoAssembler;
import ims.core.vo.domain.InpatConsultantTransferVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.InpatientEpisodeTrackingMoveVoAssembler;
import ims.core.vo.domain.InpatientEpisodeVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffShortVoAssembler;
import ims.core.vo.domain.PatientAssembler;
import ims.core.vo.domain.PatientCaseNoteRequestLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PatientTransportRequirementsVoAssembler;
import ims.core.vo.domain.PendingTransfersLiteVoAssembler;
import ims.core.vo.domain.ReasonForDelayedDischargeVoAssembler;
import ims.core.vo.domain.WardConfigLiteVoAssembler;
import ims.core.vo.domain.WardMixedSexBreachVoAssembler;
import ims.core.vo.domain.WardStayLiteVoAssembler;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.CaseNoteRequestCancellationReason;
import ims.core.vo.lookups.CaseNoteRequestStatus;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MsgUpdateType;
import ims.core.vo.lookups.PASSpecialty;
import ims.core.vo.lookups.PASSpecialtyCollection;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PatientStatus;
import ims.core.vo.lookups.ReasonForBedClosure;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.SpecialtyCollection;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.TransferStatus;
import ims.core.vo.lookups.WaitingListStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DTODomainInterfaceException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.ForeignKeyViolationException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.lookups.LookupInstance;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.ResultException;
import ims.dto.client.Homeleave;
import ims.dto.client.Homeleave.HomeleaveRecord;
import ims.dto.client.Inpat;
import ims.dto.client.Inpat.InpatRecord;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.enumerations.SortOrder;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.Time;
import ims.framework.utils.TimeFormat;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PathwaysRTTClockImpact;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.PauseDetails;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PathwayClockVo;
import ims.pathways.vo.PathwayRTTClockImpactVo;
import ims.pathways.vo.PathwayRTTClockImpactVoCollection;
import ims.pathways.vo.PathwayRTTStatusRefVo;
import ims.pathways.vo.PathwayRTTStatusRefVoCollection;
import ims.pathways.vo.PathwayRTTStatusVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.RTTStatusEventMapRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.RTTStatusPointLiteVo;
import ims.pathways.vo.domain.PathwayRTTClockImpactVoAssembler;
import ims.pathways.vo.domain.PathwayRTTStatusVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.domain.RTTStatusPointLiteVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.RTTClockImpactSource;
import ims.pathways.vo.lookups.RTTClockState;
import ims.scheduling.domain.objects.Appointment_Status;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.CancellationTypeReason;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.CancellationTypeReasonVo;
import ims.scheduling.vo.CancellationTypeReasonVoCollection;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.CancellationTypeReasonVoAssembler;
import ims.scheduling.vo.lookups.CancelAppointmentReason;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.interfaces.IMos;
import ims.vo.interfaces.IVTERiskAssessment;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;

public class BedInfoDialogImpl extends DTODomainImplementation implements BedInfoDialog
{
	private static final Object	PATIENTDIED	= "4";
	private static final String	STILLBIRTH	= "5";
	
	private static final int TRANSFERIN = 1;
	private static final int TRANSFEROUT = 2;
	private static final int TRANSFERCANCEL = 3;
	private static final int START_OF_FIRST_DEFINITIVE_TREATMENT = 30;
	
	
	private static final Logger LOG	= Logger.getLogger(BedInfoDialogImpl.class);
	private static final long serialVersionUID = 1L;
	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public RTTStatusPointLiteVo getRTTStatusPointByNationalCode(Integer nationalCode)
	{
		if (nationalCode == null)
			return null;
		
		String query = "SELECT rttStatus FROM RTTStatusPoint AS rttStatus WHERE rttStatus.national = :NAT_CODE";
		
		return RTTStatusPointLiteVoAssembler.create((RTTStatusPoint) getDomainFactory().findFirst(query, "NAT_CODE", nationalCode));
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}
	/**
	* getPatient
	*/
	public ims.core.vo.Patient getPatient(ims.core.patient.vo.PatientRefVo patient)
	{
		if(patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient os null or id not provided for method getPatient");
		
		return PatientAssembler.create((Patient) getDomainFactory().getDomainObject(patient)); 
	}

	/**
	 * 1)send ADT Transfer
	 * 2)Get Current Bed and set to Available and null Inpatient Episode
	 * 3)save InpatientEpisode record with new ward stay record and referncing new bed & status
	 * 4)delete PendingTransfer record
	 */
	public CareContextShortVo saveTransferIn(BedSpaceStateLiteVo voOldBedSpaceStateLite, InPatientEpisodeADTVo inpatientEpisode, PendingTransfersLiteVo voTransfer, HomeLeaveVo voHL, AdmissionReasonVo admissionReasonVo, WardMixedSexBreachVo wardMixSexBreachedVo,PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer) throws DomainInterfaceException, StaleObjectException 
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method saveTransfer");
		if(!inpatientEpisode.isValidated())
			throw new CodingRuntimeException("inpatientEpisode has not been validated in method saveTransfer");
		
		if(voTransfer == null || voTransfer.getID_PendingTransfers() == null)
			throw new CodingRuntimeException("voTransfer is null or id not provide for delete in method saveTransferIn");
		
		
		DomainFactory factory = getDomainFactory();
		
		// WDEV-19481 - Trigger creation of A02 Transfer HL7 message //WDEV-22454
		if(inpatientEpisode.getPasEvent()!=null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerTransferEvent(inpatientEpisode.getPasEvent());
		}
				
		//1)
		Inpat inpatRec = null;
		Result res = null;
		if (!ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();
		}
		
		//WDEV-8164 - Consultant Transfers - if the consultant has changed
		InpatientEpisode doInpat = addConsultantStayIfNeeded(inpatientEpisode,voTransfer.getPatientStatus());
		
		Sex tempBayGender = inpatientEpisode.getBed() != null ? inpatientEpisode.getBed().getProvisionalBayGender() : null;
		//WDEV-8403 update the patient's ward
		if(doInpat.getPasEvent() != null && doInpat.getPasEvent().getPatient() != null)
		{
			doInpat.getPasEvent().getPatient().setWard(doInpat.getPasEvent().getLocation());
			// WDEV-17867 - Set Current Responsible Clinician to Patient record
			doInpat.getPasEvent().getPatient().setCurrentResponsibleConsultant(doInpat.getPasEvent().getConsultant());
		}
		

		if (!ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			if (inpatientEpisode.getUpdateCaseFolderIsNotNull()
					&& inpatientEpisode.getUpdateCaseFolder())
				copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, false, true, inpatientEpisode.getCaseFolderComments());
			else
				copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, false, false, null);

			res = inpatRec.executeAction("TRANSFER");
			if (res != null && res.getId() != 0)
				throw new DTODomainInterfaceException(res.getId(), "Error occurred Transferring Patient on PAS " + res.getMessage());
		}
	
		//2)
		if(voOldBedSpaceStateLite != null)
		{
			BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voOldBedSpaceStateLite);
			factory.save(doBed);
		}
		//wdev-13509
		doInpat.setIsOnHomeLeave(false);
		doInpat.setDateOnHomeLeave(null);
		doInpat.setTimeOnHomeLeave(null);
		doInpat.setExpectedDateOfReturn(null);
		doInpat.setExpectedTimeOfReturn(null);
		doInpat.setVacatedBedNumber(null);
				
		//3)
		factory.save(doInpat);

		Location destWard = null;
		AdmissionDetail doAdmissionDetail = null;
		try
		{
			PendingTransfers doPending = (PendingTransfers) factory.getDomainObject(voTransfer);	
			
			if (doPending != null)
			{				
				//WDEV-10421 - get the admission detail record and update its history for transfers
				doAdmissionDetail = populateTransferHistory(doPending, TRANSFERIN, null, null);

				destWard = doPending.getDestinationWard();
				//4
				factory.delete(doPending);
			}
			else
				throw new StaleObjectException(doPending, ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
		}
		catch (ForeignKeyViolationException e)
		{
			throw new DomainInterfaceException("Data Constraint : PendingTransfers record could not be deleted", e);
		}
		
		//wdev-20362 - Update any active PatientCaseNotes to new location
		if (collPatientCaseNoteTransfer!=null)
		{
			CaseNoteTransfer implCaseNoteTransfer=(CaseNoteTransfer) getDomainImpl(CaseNoteTransferImpl.class);
			for (int i=0;i<collPatientCaseNoteTransfer.size();i++)
			{
				implCaseNoteTransfer.saveTransfer(collPatientCaseNoteTransfer.get(i), null, null);
			}
		}
		
		//wdev-13509
		if (voHL != null
			&& ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		{
			//UPDATE PAS THAT NO LONGER ON HOME LEAVE 
			Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
			hlRec.DataCollection.add();

			copyHomeLeaveToDto(hlRec, doAdmissionDetail, voHL);
			
			res = hlRec.update();
			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
			}
		}

		//WDEV-8315,WDEV-10421
		if(doAdmissionDetail != null)
		{
			if(destWard != null)
				doAdmissionDetail.setWard(destWard);
			if(doInpat.getBed() != null)
				doAdmissionDetail.setBed(doInpat.getBed().getBedSpace());
			doAdmissionDetail.setEstDischargeDate(doInpat.getEstDischargeDate());
			factory.save(doAdmissionDetail);
		}
		
		//WDEV-20217
		if (voOldBedSpaceStateLite != null)
			updateOccupiedBedsForWardAndBay(voOldBedSpaceStateLite.getWard(), voOldBedSpaceStateLite.getBay(), null);
		
		if (inpatientEpisode.getBed() != null)
			updateOccupiedBedsForWardAndBay(inpatientEpisode.getBed().getWard(), inpatientEpisode.getBed().getBay(), null);
		
		//WDEV-20224
		if (admissionReasonVo != null) 
		{
			if (Boolean.TRUE.equals(admissionReasonVo.getIsGenderSpecificBayValidated()))
			{
				if (inpatientEpisode.getBedIsNotNull() && inpatientEpisode.getBed().getWard() != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(inpatientEpisode.getBed().getBay(), getWardConfig(inpatientEpisode.getBed().getWard()));
					if (bayConfig != null)
					{		
						bayConfig.setTemporaryBayGender(tempBayGender);

						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);
						factory.save(bayConfigDO);
					}				
				}								
			}
			else if (Boolean.TRUE.equals(admissionReasonVo.getIsMixingGenderBayValidated()))
			{				
				if (wardMixSexBreachedVo != null)
				{	
					WardMixedSexBreach wardMixedAdmissionDO = WardMixedSexBreachVoAssembler.extractWardMixedSexBreach(factory, wardMixSexBreachedVo);

					if (Sex.MALE.equals(inpatientEpisode.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setMalePatients(wardMixSexBreachedVo.getMalePatientsIsNotNull() ? new Integer(wardMixSexBreachedVo.getMalePatients().intValue() + 1) : 1);
					if (Sex.FEMALE.equals(inpatientEpisode.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setFemalePatients(wardMixSexBreachedVo.getFemalePatientsIsNotNull() ? new Integer(wardMixSexBreachedVo.getFemalePatients().intValue() + 1) : 1);

					factory.save(wardMixedAdmissionDO);
				}
				if (inpatientEpisode.getBedIsNotNull())
				{	
					BayConfigLiteVo bayConfig = getBayConfigForBay(inpatientEpisode.getBed().getBay());
					if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
					{		
						if (!bayConfig.getTemporaryBayGender().equals(inpatientEpisode.getBed().getProvisionalBayGender()) && !Sex.UNKNOWN.equals(inpatientEpisode.getBed().getProvisionalBayGender()))
						{
							bayConfig.setTemporaryBayGender(inpatientEpisode.getBed().getProvisionalBayGender());

							BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

							factory.save(bayConfigDO);
						}				
					}
				}
			}
		}
		//WDEV-20927 - should update the temporary gender on previous bay config
		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			Sex genderToSet = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getPatient() != null && inpatientEpisode.getPasEvent().getPatient().getSexIsNotNull() && !Sex.UNKNOWN.equals(inpatientEpisode.getPasEvent().getPatient().getSex()) ? inpatientEpisode.getPasEvent().getPatient().getSex() : null;
			if (genderToSet != null)
			{	
				if (voOldBedSpaceStateLite != null)
				{
					voOldBedSpaceStateLite = BedSpaceStateLiteVoAssembler.create((BedSpaceState)factory.getDomainObject(BedSpaceState.class, voOldBedSpaceStateLite.getID_BedSpaceState()));
					checkAndUpdatePreviousBayConfig(factory, voOldBedSpaceStateLite, genderToSet);
				}	
				else
				{
					WardStayVo prevWardStay = getLastClosedWardStay(inpatientEpisode);

					if (prevWardStay != null && prevWardStay.getBay() != null)
					{
						WardConfigLiteVo wardConfigLiteVo = getWardConfig(prevWardStay.getWard());
						BayConfigLiteVo bayConfig = getBayConfigForBay(prevWardStay.getBay());		
						boolean wasConfigChanged = false;
						if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
						{
							if (bayConfig.getNumOfOccupiedBeds() == null || bayConfig.getNumOfOccupiedBeds() == 0)
							{	
								bayConfig.setTemporaryBayGender(null);
								wasConfigChanged = true;
							}	
							Sex tempGender = getTempGenderToInstateForPreviousBay(wardConfigLiteVo, bayConfig);
							if (tempGender == null || (tempGender != null && tempGender.equals(bayConfig.getTemporaryBayGender())))
							{	
								bayConfig.setTemporaryBayGender(tempGender);
								wasConfigChanged = true;
							}
							if (wasConfigChanged)
							{	
								BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);				
								factory.save(bayConfigDO);
							}
						}					
					}				
				}
			}
		}
		//WDEV-11438 - update the CareContext with the EDD (need to get the Inpatient CC) //WDEV-22503		
		CareContextShortVo voCareContext = getCareContextForPasEvent(inpatientEpisode.getPasEvent());
		if(voCareContext != null)
		{
			voCareContext.setEstimatedDischargeDate(inpatientEpisode.getEstDischargeDateIsNotNull() ? inpatientEpisode.getEstDischargeDate().getDate() : null);
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(factory, voCareContext);
			//WDEV-11479
			if(doInpat != null && doInpat.getPasEvent() != null && doCareContext.getEpisodeOfCare() != null) 
			{
				doCareContext.setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue()) //wdev-14309
				{
					doCareContext.getEpisodeOfCare().setResponsibleHCP(doInpat.getPasEvent().getConsultant());
					doCareContext.getEpisodeOfCare().setSpecialty(doInpat.getPasEvent().getSpecialty());	//	WDEV-12771
				}
			}				
		
			factory.save(doCareContext);
			return CareContextShortVoAssembler.create(doCareContext);
		}
		
		return null;
	}
	//WDEV-22503 
	private CareContextShortVo getCareContextForPasEvent(PasEventADTVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			return null;

		List<?> ccList = getDomainFactory().find(" select cc from CareContext as cc left join cc.context as ccontext where cc.pasEvent.id = :PASEVENT_ID and ccontext.id = :INPATIENT_TYPE", new String[]{"PASEVENT_ID", "INPATIENT_TYPE"}, new Object[]{pasEvent.getID_PASEvent(), ContextType.INPATIENT.getID()});		
		if (ccList != null && !ccList.isEmpty())
		{
			return CareContextShortVoAssembler.create((CareContext) ccList.get(0));
		}
		
		return null;
	}

	private BayConfigLiteVo getBayConfigForBay(LocationLiteVo bay)
	{
		DomainFactory factory = getDomainFactory();
		
		BayConfig bayConfigDO = (BayConfig) factory.findFirst("from BayConfig bayc where bayc.bay.id = :BAY", "BAY", bay.getID());
		
		return BayConfigLiteVoAssembler.create(bayConfigDO);
	}

	private WardStayVo getLastClosedWardStay(InPatientEpisodeADTVo inpatientEpisode)
	{
		if (inpatientEpisode == null || inpatientEpisode.getWardStays() == null || inpatientEpisode.getWardStays().size() ==0)
		return null;
		WardStayVoCollection wardStaysColl = inpatientEpisode.getWardStays();
		for (int i=wardStaysColl.size()-1;i>=0;i--)
		{
			if (wardStaysColl.get(i) != null && wardStaysColl.get(i).getTransferOutDateTime() == null)
			{	
			wardStaysColl.remove(i);
			}
		}
		if (wardStaysColl.size() > 0)
		{
			wardStaysColl.sort(WardStayVo.getWardStayVoIdComparator(SortOrder.DESCENDING));
			return wardStaysColl.get(0);
		}
		return null;
	}

	private BayTimesAdmissionBreachedVo populateBayTimesBreachedRecord(PendingTransfersLiteVo voTransfer, BedSpaceStateLiteVo voBedSpaceStateLite, AdmissionReasonVo admissionReasonVo)
	{
		BayTimesAdmissionBreachedVo voBreach = new BayTimesAdmissionBreachedVo();
		
		voBreach.setAdmissionDateTime(voTransfer.getTransferRequestDateTime());
		voBreach.setWard(voTransfer.getDestinationWard());
		if (voBedSpaceStateLite != null)
			voBreach.setBay(voBedSpaceStateLite.getBay());
		Object mosUser = getHcpLiteUser();
		if (mosUser != null)
			voBreach.setMemberOfStaff(((HcpLiteVo) mosUser).getMos());
		voBreach.setReasonForAdmissionOutOfOpeningHours(admissionReasonVo.getReasonForAdmissionOutOfOpeningHours());
		voBreach.setReasonForAdmissionOutOfOpeningHoursComment(admissionReasonVo.getReasonForAdmissionOohComment());
		
		return voBreach;
	}
	/**
	 * @param patientStatus 
	 * @method addConsultantStayIfNeeded
	 * @comment does InpatientAssembler call also - MUST BE CALLED
	 * 
	 */
	private InpatientEpisode addConsultantStayIfNeeded(InPatientEpisodeADTVo inpatientEpisode, PatientStatus patientStatus)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method addConsultantStayIfNeeded"); 
			
		DomainFactory factory = getDomainFactory();
		Medic doExistingCons = null;
		LookupInstance doExistingSpecialty = null;
		Service doExistingService = null;
		if (inpatientEpisode.getPasEventIsNotNull() && inpatientEpisode.getPasEvent().getBoId() != null)
		{
			PASEvent doExistingPe = (PASEvent)factory.getDomainObject(PASEvent.class, inpatientEpisode.getPasEvent().getBoId());
			doExistingCons = doExistingPe != null ? doExistingPe.getConsultant() : null;
			doExistingService =  doExistingPe != null ? doExistingPe.getService() : null;
			doExistingSpecialty = doExistingPe != null ? doExistingPe.getSpecialty() : null;
		}
		
		InpatientEpisode doInpat = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(factory, inpatientEpisode);
		//WDEV-22892
		if (inpatientEpisode.getPasEventIsNotNull())
		{			
			boolean consultantHasChanged = inpatientEpisode.getPasEvent().getConsultantIsNotNull() && doExistingCons != null && !doInpat.getPasEvent().getConsultant().equals(doExistingCons);
			boolean serviceChanged = inpatientEpisode.getPasEvent().getService() != null && !inpatientEpisode.getPasEvent().getService().equals(doExistingService);
			boolean specialtyChanged = inpatientEpisode.getPasEvent().getSpecialty() != null && !inpatientEpisode.getPasEvent().getSpecialty().equals(doExistingSpecialty);
			
			if (consultantHasChanged || (serviceChanged && consultantHasChanged) || (specialtyChanged && consultantHasChanged))
			{
				addConsultantStay(doInpat,patientStatus);
			}							
		}
		
		return doInpat;
	}

	private void addConsultantStay(InpatientEpisode doInpat, PatientStatus patientCategory)
	{
		Date transferDate = getMostRecentWardStayTransferDate(doInpat);
		LookupInstance patientCategoryForStay  = patientCategory != null ? getDomLookup(patientCategory) : doInpat.getPasEvent().getPatient().getPatientCategory();
		ConsultantStay oldCS = updateCurrentConsultantStay(doInpat.getConsultantStays());
		if(oldCS != null)
		{
			oldCS.setEndDateTime(transferDate);
		}
			
		ConsultantStay doConsStay = new ConsultantStay();
		doConsStay.setConsultant(doInpat.getPasEvent().getConsultant());
		doConsStay.setTransferDateTime(transferDate);
		doConsStay.setSpecialty(doInpat.getPasEvent().getSpecialty());
		doConsStay.setService(doInpat.getPasEvent().getService());
		doConsStay.setPatientStatus(patientCategoryForStay);
		
		doInpat.getConsultantStays().add(doConsStay);
	}
	
	private ConsultantStay updateCurrentConsultantStay(Set consultantStays)
	{
		if(consultantStays == null)
			return null;
		
		Iterator it = consultantStays.iterator();
		
		while(it.hasNext())
		{
			Object cs = it.next();
			
			if(cs instanceof ConsultantStay)
			{
				if(((ConsultantStay) cs).getEndDateTime() == null)
					return (ConsultantStay) cs;
			}
		}
		
		return null;
	}

	private void copyInpatEpisodeToDtoForTransfer(Inpat inpatRec, InpatientEpisode inpatientEpisode, boolean isConsultantTransfer, boolean isUpdateFolder, String szCaseFolderComment)
	{
		InpatRecord rec = inpatRec.DataCollection.get(0);
		
		//WDEV-8238
		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeHcpcode = true;
		inpatRec.EditFilter.IncludeSpcd = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeLtdt = true;
		inpatRec.EditFilter.IncludeLttm = true;
		inpatRec.EditFilter.IncludeEddt = true;
		inpatRec.EditFilter.IncludeCflup = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeBtyp = true; //WDEV-10965
		
		rec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);
		if(inpatientEpisode.getPasEvent() != null)
			rec.Hcpcode = getPasMapping(inpatientEpisode.getPasEvent().getConsultant());
		if(inpatientEpisode.getPasEvent() != null)
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getSpecialty());
		
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
			&& inpatientEpisode.getPasEvent() != null
			&& inpatientEpisode.getPasEvent().getPASSpecialty() != null)
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getPASSpecialty());

		rec.Rescode = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getLocation() != null ? inpatientEpisode.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(inpatientEpisode.getWardType());
		
		if(isConsultantTransfer)
		{
			Date consDate = getMostRecentConsultantStayTransferDate(inpatientEpisode);
			if(consDate != null)
			{
				rec.Ltdt = DTOHelper.convertToDtoDate(consDate);
				rec.Lttm = DTOHelper.convertToDtoTime(consDate);	
			}
		}
		else
		{
			Date transDate = getMostRecentWardStayTransferDate(inpatientEpisode);
			if(transDate != null)
			{
				rec.Ltdt = DTOHelper.convertToDtoDate(transDate);
				rec.Lttm = DTOHelper.convertToDtoTime(transDate);
			}
		}
		
		if(inpatientEpisode.getEstDischargeDate() != null)
			rec.Eddt = DTOHelper.convertToDtoDate(inpatientEpisode.getEstDischargeDate());
	
		rec.Cflup = "N";	
		//WDEV-12957/wdev-13402
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO") && isUpdateFolder)
		{
			rec.Cflup = "Y"; 
			
			inpatRec.EditFilter.IncludeCfl = true;
			inpatRec.EditFilter.IncludeCflcomm = true;
			
			rec.Cfl = rec.Rescode;
			rec.Cflcomm = szCaseFolderComment;
		}

		//WDEV-10965 - interim solution
		if(rec.Mors != null)
		{
			if(rec.Mors.equals("M"))
			{
				if(inpatientEpisode.getPasEvent().getPatient().getSex() != null)
				{
					if(inpatientEpisode.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
						rec.Btyp = "M";
					else if(inpatientEpisode.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
						rec.Btyp = "F";
					else
						//defaulting Male for unknown sex
						rec.Btyp = "M";
				}
				else
					//defaulting Male for unknown sex
					rec.Btyp = "M";	
			}
			else if(rec.Mors.equals("S"))
				rec.Btyp = "S";
		}
		
		//WDEV-7827
		rec.Webadt = "Y";				
	}
	


	private Date getMostRecentConsultantStayTransferDate(InpatientEpisode inpatientEpisode)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method getMostRecentConsultantStayTransferDate");
		
		Date transferDate = null;
		if(inpatientEpisode.getConsultantStays() != null && inpatientEpisode.getConsultantStays().size() > 0)
		{
			Iterator it = inpatientEpisode.getConsultantStays().iterator();
			while(it.hasNext())
			{	
				ConsultantStay consStay = (ConsultantStay)it.next();
				if(consStay.getTransferDateTime() != null)
				{
					if(transferDate == null || transferDate.before(consStay.getTransferDateTime()))
						transferDate = consStay.getTransferDateTime();
				}
			}
		}			
			
		return transferDate;
	}

	private void copyToDtoForDischarge(Inpat inpatRec, InpatientEpisode inpatientEpisode, DischargedEpisode doDisch)
	{
		//WDEV-9644
		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeLttm = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeDsmt = true;
		inpatRec.EditFilter.IncludeDsds = true;
		inpatRec.EditFilter.IncludeRrea = true;
		
		InpatRecord rec = inpatRec.DataCollection.get(0); 
		
		rec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);
		if(inpatientEpisode.getPasEvent() != null)
		{
			inpatRec.EditFilter.IncludeHcpcode = true;
			rec.Hcpcode = getPasMapping(inpatientEpisode.getPasEvent().getConsultant());
		}
		if(inpatientEpisode.getPasEvent() != null)
		{
			inpatRec.EditFilter.IncludeSpcd = true;
			rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getSpecialty());
			if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
				&& inpatientEpisode.getPasEvent() != null
				&& inpatientEpisode.getPasEvent().getPASSpecialty() != null)
				rec.Spcd = DTOHelper.getPasMapping(inpatientEpisode.getPasEvent().getPASSpecialty()); //wdev-15724
		}

		rec.Rescode = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getLocation() != null ? inpatientEpisode.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(inpatientEpisode.getWardType());
		Date recentDt = getMostRecentWardStayTransferDate(inpatientEpisode);
		if(recentDt != null)
		{
			inpatRec.EditFilter.IncludeLtdt = true;
			rec.Ltdt = DTOHelper.convertToDtoDate(recentDt);
		}
		if(inpatientEpisode.getAdmissionDateTime() != null)
		{
			inpatRec.EditFilter.IncludeLttm = true;
			rec.Lttm = DTOHelper.convertToDtoTime(inpatientEpisode.getAdmissionDateTime());
		}
		//WDEV-7827
		rec.Webadt = "Y";				
	
		rec.Dsmt = DTOHelper.getPasMapping(doDisch.getMethodOfDischarge());
		rec.Dsds = DTOHelper.getPasMapping(doDisch.getDischargeDestination());
		
		//WDEV
		if(doDisch.getDischargeDateTime() != null)
		{
			inpatRec.EditFilter.IncludeEpen = true;
			inpatRec.EditFilter.IncludeEetm = true;
			
			rec.Epen = DTOHelper.convertToDtoDate(doDisch.getDischargeDateTime());
			rec.Eetm = DTOHelper.convertToDtoTime(doDisch.getDischargeDateTime());
		}
		
		rec.Rrea = DTOHelper.getPasMapping(doDisch.getTreatmentDeferredReason());
		
		if(doDisch.isEighteenWeekClockStopped() != null)
		{
			inpatRec.EditFilter.IncludeRttstop = true;
			rec.Rttstop = doDisch.isEighteenWeekClockStopped() ? "Y" : "N";
		}
	}
	
	private Date getMostRecentWardStayTransferDate(InpatientEpisode inpatientEpisode)
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method getMostRecentWardStayTransferDate");

		Date transferDate = null;
		if(inpatientEpisode.getWardStays() != null && inpatientEpisode.getWardStays().size() > 0)
		{
			Iterator it = inpatientEpisode.getWardStays().iterator();
			while(it.hasNext())
			{	
				WardStay wardStay = (WardStay)it.next();
				//**********************************************
				if(wardStay == null || wardStay.getTransferDateTime()== null)
				   continue;
				//**********************************************
				if(transferDate == null || transferDate.before(wardStay.getTransferDateTime()))
					transferDate = wardStay.getTransferDateTime();
			}
		}			
			
		return transferDate;
	}

	private String getPasMapping(Medic consultant) 
	{
		if(consultant == null || consultant.getMos() == null || consultant.getMos().getCodeMappings() == null || consultant.getMos().getCodeMappings().size() == 0)
			return null;
		
		Iterator it = consultant.getMos().getCodeMappings().iterator();
		while(it.hasNext())
		{
			TaxonomyMap map = (TaxonomyMap) it.next();
			if(map.getTaxonomyName().equals(getDomLookup(TaxonomyType.PAS)))
				return map.getTaxonomyCode();
		}
		
		return null;
	}

	private String getPatientIdValue(InpatientEpisode doInpatientEpisode, PatIdType type) 
	{
		if(doInpatientEpisode == null)
			return null;
		
		if(doInpatientEpisode.getPasEvent() != null && doInpatientEpisode.getPasEvent().getPatient() != null && doInpatientEpisode.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doInpatientEpisode.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}
		
		return null;
	}

	public InPatientEpisodeADTVo getInpatientEpisode(InpatientEpisodeRefVo inpatientEpisode)
	{
		if(inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpatientEpisode is null or id not provided for getInpatientEpisode");
		
		return InPatientEpisodeADTVoAssembler.create( (InpatientEpisode) getDomainFactory().getDomainObject(inpatientEpisode));
	}

	public LocationLiteVoCollection listActiveHospitalsLite()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public LocationLiteVoCollection listActiveWardsForHospitalLite(LocationRefVo hospital)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveWardsForHospitalLite(hospital);
	}

	public void saveTransferOut(PendingTransfersLiteVo pendingTransfer) throws StaleObjectException, DomainInterfaceException  //WDEV-20023
	{
		if(pendingTransfer == null)
			throw new CodingRuntimeException("pendingTransfer is null in method saveTransferOut");
		if(!pendingTransfer.isValidated())
			throw new CodingRuntimeException("pendingTransfer has not been validated in method saveTransferOut");
		
		DomainFactory domainFactory = getDomainFactory();
		//WDEV-9192
		if(pendingTransfer.getInpatientEpisodeIsNotNull())
		{
			String currentTransfer = "";
			if(pendingTransfer.getID_PendingTransfers() != null)
				currentTransfer = " and pt.id <> '" +  pendingTransfer.getID_PendingTransfers() + "'";
			
			List existingPTs = getDomainFactory().find("from PendingTransfers pt where pt.inpatientEpisode.id = '" + pendingTransfer.getInpatientEpisode().getID_InpatientEpisode() + "'" + currentTransfer);
			if(existingPTs != null && existingPTs.size() > 0)
				throw new DomainInterfaceException("Patient already has a transfer pending, the screen will be refreshed");
		}
		
		//WDEV-10421
		PendingTransfers doTransfer = PendingTransfersLiteVoAssembler.extractPendingTransfers(getDomainFactory(), pendingTransfer);
		//get the admission detail record and update its history for transfers
		AdmissionDetail doAdmissionDetail = populateTransferHistory(doTransfer, TRANSFEROUT, null, null);
		//WDEV-20291 - starts here
		BedSpaceStateLiteVo bedSpaceVo = null;
		if (Boolean.TRUE.equals(pendingTransfer.getNoLongerInBed())) 
		{
			InpatientEpisode doInpatEp = doTransfer.getInpatientEpisode();
			if (doInpatEp != null && doInpatEp.getBed() != null)
			{
				bedSpaceVo = BedSpaceStateLiteVoAssembler.create(doInpatEp.getBed());
		
				if (bedSpaceVo.getCurrentBedStatusIsNotNull())
				{
					bedSpaceVo.setPreviousBedStatus((BedSpaceStateStatusLiteVo) bedSpaceVo.getCurrentBedStatus().clone());
					BedSpaceStateStatusLiteVo bedStatusVo = new BedSpaceStateStatusLiteVo();
					bedStatusVo.setBedStatus(BedStatus.AVAILABLE);
					bedStatusVo.setStatusDateTime(pendingTransfer.getTransferRequestDateTime());
					
					bedSpaceVo.setCurrentBedStatus(bedStatusVo);				
					
				}
				bedSpaceVo.setInpatientEpisode(null);	
				updateOccupiedBedsForWardAndBay(LocationLiteVoAssembler.create(doInpatEp.getBed().getWard()), LocationLiteVoAssembler.create(doInpatEp.getBed().getBay()), null);
			}
			doInpatEp.setBedNo(null); //WDEV-20291
		}
		try
		{
			if (bedSpaceVo != null && Boolean.TRUE.equals(pendingTransfer.getNoLongerInBed()))
			{	
				BedSpaceState bedDO = BedSpaceStateLiteVoAssembler.extractBedSpaceState(domainFactory, bedSpaceVo);
				domainFactory.save(bedDO);			
			}
			domainFactory.save(doTransfer);
			
			// WDEV-19774 - Trigger creation of A15 Pending Transfer HL7 message
			InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doTransfer.getInpatientEpisode());
			
			if(inpatEpisodeVo.getPasEvent()!=null)
			{
		    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
				adtimpl.triggerPendingTransferEvent(inpatEpisodeVo.getPasEvent());
			} //WDEV-19974
						
			if(doAdmissionDetail != null)
				getDomainFactory().save(doAdmissionDetail);	
			
		}
		catch (IllegalArgumentException e)
		{
			//where object has been deleted - this happens when a transfer in has been deleted (transfer complete) and this user has the old pending transfer record and is trying to update it
			throw new DomainInterfaceException("Patient's transfer has already been processed, the screen will be refreshed");
		}
	}
	//WDEV-20326 new argument needed as we send some details from screen on cancellation
	public AdmissionDetail populateTransferHistory(PendingTransfers doTransfer, int transferType, LocationRefVo voCancellingfromWard, TransferCancellationReasonDetailsVo cancellationDetails)
	{
		AdmissionDetail doAdmissionDetail = null;
		if (doTransfer != null && doTransfer.getInpatientEpisode() != null && doTransfer.getInpatientEpisode().getPasEvent() != null)
		{
			List admList = getDomainFactory().find("from AdmissionDetail adm where adm.pasEvent.id = " + doTransfer.getInpatientEpisode().getPasEvent().getId());
			if(admList != null && admList.size() > 0)
			{
				doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				
				//create a new or get the latest and check if its being transferred
				TransferHistory doTransferHistory = null;
				if(doAdmissionDetail.getTransferHistory().size() == 0)
					doTransferHistory = new TransferHistory();
				else
				{
					//populate last record
					doTransferHistory = (TransferHistory) doAdmissionDetail.getTransferHistory().get(doAdmissionDetail.getTransferHistory().size() - 1);
				}	
			
				//depending on the operation
				if(transferType != 0)
				{
					if(transferType == TRANSFEROUT)
					{
						//get the last pending if any and update it with rejected - this is when user 
						//changes their mind on a pending transfer and updates it - whether or not they change ward
						if(doAdmissionDetail.getTransferHistory() != null && doAdmissionDetail.getTransferHistory().size() > 0)
						{
							TransferHistory doPrevTransferHistory = (TransferHistory) doAdmissionDetail.getTransferHistory().get(doAdmissionDetail.getTransferHistory().size() - 1);
							
							//WDEV-10589 - if it has already been accepted no need to reject it
							if(doPrevTransferHistory.getAcceptTransferDateTime() == null)
							{
								doPrevTransferHistory.setRejectTransferDateTime(new Date());
								
								if(getLoggedInUser() != null)
									doPrevTransferHistory.setRejectTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
							}
						}
						
						doTransferHistory = new TransferHistory();
						doTransferHistory.setAcceptingOrRejectingWard(doTransfer.getDestinationWard());
						doTransferHistory.setTransferringFromWard(doTransfer.getInpatientEpisode().getPasEvent().getLocation());
						doTransferHistory.setMarkedForTransferOutDateTime(new DateTime().getJavaDate()); //WDEV-10593
						if(getLoggedInUser() != null)
							doTransferHistory.setTransferOutUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
						//WDEV-19761
						doTransferHistory.setTransferReason(doTransfer.getTransferReason());
						doTransferHistory.setTransferComment(doTransfer.getTransferComment());
						
						doAdmissionDetail.getTransferHistory().add(doTransferHistory);
					}
					else if(transferType == TRANSFERIN)
					{
						doTransferHistory.setAcceptingOrRejectingWard(doTransfer.getDestinationWard());
						if(getLoggedInUser() != null)
							doTransferHistory.setAcceptingTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
						
						doTransferHistory.setAcceptTransferDateTime(new Date());
					}
					else if(transferType == TRANSFERCANCEL)
					{
						// WDEV-11139
						// For patients in WaitingArea there is no ward to be set - leave it to null
						if (voCancellingfromWard != null)
							doTransferHistory.setAcceptingOrRejectingWard((Location) getDomainFactory().getDomainObject(voCancellingfromWard));
						
						doTransferHistory.setRejectTransferDateTime(new Date());
						if(getLoggedInUser() != null)
							doTransferHistory.setRejectTransferUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));
						if (cancellationDetails != null) //WDEV-20326
						{
							doTransferHistory.setCancelTransferComment(cancellationDetails.getCancellationComments());
							doTransferHistory.setCancelTransferReason(getDomLookup(cancellationDetails.getCancellationReason()));							
						}
					}
				}
			}
		}
		return doAdmissionDetail;
	}

	public ims.core.vo.DischargedEpisodeADTVo saveDischarge(DischargedEpisodeADTVo dischargedEpisode, BedSpaceStateLiteVo voBedSpacState, DeathDetailsVo deathDetailsVo, Boolean cancelApptsForDeceasedPatient, Boolean checkPatientsGender) throws StaleObjectException, DomainInterfaceException, ForeignKeyViolationException
	{	
		if(dischargedEpisode.getPasEventIsNotNull() && dischargedEpisode.getPasEvent().getPatientIsNotNull())
			return dischargePatient(dischargedEpisode.getPasEvent().getPatient(), dischargedEpisode, voBedSpacState, false, null, deathDetailsVo, cancelApptsForDeceasedPatient, checkPatientsGender);
		
		return null;
	}
	
	@SuppressWarnings("unchecked")
	public DischargedEpisodeADTVo saveDischargeElectiveList(DischargedEpisodeADTVo dischargedEpisode, BedSpaceStateLiteVo voBedSpacState, 
															PatientElectiveListBedAdmissionVo electiveList, AdmissionDetailVo currentAdmissionDetails, PatientElectiveListBedAdmissionVoCollection cancelledElectiveListToBeRemoved,
															DeathDetailsVo deathDetailsVo, Boolean cancelApptsForDeceasedPatient,
															Boolean treatmentGiven, Boolean treatmentDereferred, Boolean checkPatientsGender) throws DomainInterfaceException, StaleObjectException, ForeignKeyViolationException
	{
		Boolean hasElectiveList = false;
		PatientElectiveList domElectiveList = null;
		TCIForPatientElectiveList domTci = null; //WDEV-22655
		CancellationTypeReasonVo deferredReason = dischargedEpisode.getDeferredReasonConfig();
		boolean deferredForNonMedicalReason = deferredReason != null && Boolean.TRUE.equals(deferredReason.getIsNonMedicalReason());

		
		@SuppressWarnings("rawtypes")
		HashMap domMap = new HashMap();
				
		if (electiveList != null)
		{
			PathwayRTTClockImpactVo admissionClockImpact = null;
			// Get Clock impact of the admission
			if (electiveList.getTCIDetails() != null && electiveList.getTCIDetails().getAdmissionDetail() != null)
			{
				StringBuilder query = new StringBuilder("SELECT admissionImpact FROM AdmissionDetail AS admission LEFT JOIN admission.admissionRTTOutcome AS admissionImpact ");
				query.append(" WHERE ");
				query.append(" admission.id = :ADMISSION_ID ");
				
				admissionClockImpact = PathwayRTTClockImpactVoAssembler.create((PathwaysRTTClockImpact) getDomainFactory().findFirst(query.toString(), "ADMISSION_ID", electiveList.getTCIDetails().getAdmissionDetail().getID_AdmissionDetail()));
			}
			
			
			// Step 1 - Update Patient Elective List status
			// Check if the status was updated
			domElectiveList = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), electiveList, domMap);
			domTci = domElectiveList.getTCIDetails(); //WDEV-22655
			if (WaitingListStatus.REQUIRES_TCI.equals(electiveList.getElectiveListStatus().getElectiveListStatus()))
			{				
				domElectiveList.getTCIHistory().add(domTci);
				domElectiveList.setTCIDetails(null);
				
				ReferralEROD erod = domElectiveList.getEROD();
				domElectiveList.getERODHistory().add(erod);
				domElectiveList.setEROD(null);
			}

			getDomainFactory().save(domElectiveList);
			electiveList = PatientElectiveListBedAdmissionVoAssembler.create(domElectiveList);

			if (treatmentGiven)
			{
				// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
				// When discharging a Patient Elective List Admission use the discharge date time
				Date eventDateTime = dischargedEpisode.getDischargeDateTime().getJavaDate();
				electiveList = setFirstDefinitiveTreatement(electiveList, currentAdmissionDetails, eventDateTime);
			}
			else if (treatmentDereferred)
			{
				if (ElectiveListReason.TREATMENT.equals(electiveList.getElectiveListReason()))
				{
					electiveList = setJourneyClockBackToStarted(electiveList, admissionClockImpact,deferredForNonMedicalReason);
				}
				
				// Flag the elective list as 28 day rule if it is for Non - Medical reasons
				if (deferredForNonMedicalReason)
				{
					//electiveList.setRequiresTCIBy(new ims.framework.utils.Date().addDay(28));
					electiveList.setWas28DayRuleApplied(Boolean.TRUE);
				}
			}
			
			domElectiveList = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), electiveList);
			getDomainFactory().save(domElectiveList);
			electiveList = PatientElectiveListBedAdmissionVoAssembler.create(domElectiveList);

			hasElectiveList = true;
		}
		
		if (cancelledElectiveListToBeRemoved != null)
		{
			MemberOfStaff domainMOS = null;
			Object mosUser = getMosUser();

			DomainFactory factory = getDomainFactory();
			ims.framework.utils.Date currentDate = new ims.framework.utils.Date();

			if (mosUser instanceof MemberOfStaffShortVo)
			{
				domainMOS = MemberOfStaffShortVoAssembler.extractMemberOfStaff(factory, ((MemberOfStaffShortVo) getMosUser()));
			}

			for (PatientElectiveListBedAdmissionVo patientElectiveListToCancel : cancelledElectiveListToBeRemoved)
			{
				PatientElectiveList domPatientElectiveListToCancel = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(getDomainFactory(), patientElectiveListToCancel, domMap);

				// check if Elective List has an active TCI
				if (domPatientElectiveListToCancel.getTCIDetails() != null && Boolean.TRUE.equals(domPatientElectiveListToCancel.getTCIDetails().isIsActive()))
				{
					TCIOutcomeForPatientElectiveList outcome = new TCIOutcomeForPatientElectiveList();

					outcome.setOutcome(getDomLookup(AdmissionOfferOutcome.NOT_APPLICABLE_OR_REMOVED_ETC_9));
					outcome.setChangeBy(domainMOS);
					outcome.setStatusDateTime(new Date());

					domPatientElectiveListToCancel.getTCIDetails().setCurrentOutcome(outcome);

					if (domPatientElectiveListToCancel.getTCIDetails().getOutcomeHistory() == null)
						domPatientElectiveListToCancel.getTCIDetails().setOutcomeHistory(new ArrayList());

					domPatientElectiveListToCancel.getTCIDetails().getOutcomeHistory().add(outcome);
					domPatientElectiveListToCancel.getTCIDetails().setIsActive(false);

					// check if the TCI has a linked future Booked Theatre
					// Appointment
					Booking_Appointment doBookAppt = domPatientElectiveListToCancel.getTCIDetails().getAppointment();

					if (doBookAppt != null && doBookAppt.getTheatreBooking() != null && getDomLookup(Status_Reason.BOOKED).equals(doBookAppt.getApptStatus()) && currentDate.getDate().compareTo(doBookAppt.getAppointmentDate()) <= 0)
					{
						doBookAppt.setApptStatus(getDomLookup(Status_Reason.CANCELLED));

						Appointment_Status appStatus = new Appointment_Status();

						appStatus.setStatus(getDomLookup(Status_Reason.CANCELLED));
						appStatus.setStatusReason(getDomLookup(Status_Reason.SLOTOPENED));
						appStatus.setStatusChangeDateTime(new Date());
						//WDEV-23185
						if (doBookAppt.getSession() != null)
						{
							appStatus.setSession(doBookAppt.getSession());
						} //WDEV-23185

						doBookAppt.setCurrentStatusRecord(appStatus);

						if (doBookAppt.getApptStatusHistory() == null)
							doBookAppt.setApptStatusHistory(new HashSet());

						doBookAppt.getApptStatusHistory().add(appStatus);
						

						//WDEV-18940
						Booking_AppointmentVo bookingApptVo = Booking_AppointmentVoAssembler.create(doBookAppt);
						
						if (bookingApptVo.getSessionSlot() != null)
						{
							bookingApptVo.getSessionSlot().setStatus(bookingApptVo.getSession().getAppropiateSessionSlotStatus());
						}						

						try
						{
							Class<?> implClass = Class.forName("ims.scheduling.domain.impl.SessionAdminImpl");
							ims.core.helper.IElectiveListCancelAppt sessionAdminImp = (ims.core.helper.IElectiveListCancelAppt) getDomainImpl(implClass);
							sessionAdminImp.cancelAppt(bookingApptVo, ActionRequestType.NOTIFY_APPT_CANCEL, "Cancel Appt requested from Bed Info Dialog Discharge");
						}
						catch (ClassNotFoundException e)
						{
							// log the exception in system log - but it should
							// be fine
							createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
						}
					}
				}
				
				//WDEV-18680
				if (domPatientElectiveListToCancel.getPathwayClock() != null &&domPatientElectiveListToCancel.getPathwayClock().getStopDate() == null )
				{
					domPatientElectiveListToCancel.getPathwayClock().setStopDate(new Date());
					// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
					// When discharging a Patient Elective List Admission use the discharge date time
					Date eventDateTime = dischargedEpisode.getDischargeDateTime().getJavaDate();
					updateRTTStatus(domPatientElectiveListToCancel.getReferral(), eventDateTime);
				}

				getDomainFactory().save(domPatientElectiveListToCancel);
				
				if (domPatientElectiveListToCancel.getTCIDetails() != null)
					cancelCaseNoteRequests(domPatientElectiveListToCancel.getTCIDetails().getId());
			}
		}
		
		//WDEV-18754
		DomainFactory factory = getDomainFactory();
		//WDEV-22655
		if (electiveList != null && domTci != null && domTci.getAdmissionDetail() != null  && domTci.getAdmissionDetail().getPasEvent() != null && domTci.getAdmissionDetail().getPasEvent().getPasEventId() != null)
			markAssociatedAppoinmentAsDischarged(factory, new Integer(domTci.getAdmissionDetail().getPasEvent().getId()), dischargedEpisode.getDischargeDateTime());//wdev-18155
		
		
		if(dischargedEpisode.getPasEventIsNotNull() && dischargedEpisode.getPasEvent().getPatientIsNotNull())
			return dischargePatient(dischargedEpisode.getPasEvent().getPatient(), dischargedEpisode, voBedSpacState, hasElectiveList, domElectiveList, deathDetailsVo, cancelApptsForDeceasedPatient, checkPatientsGender);
		
		return null;
	}
	
	private PatientElectiveListBedAdmissionVo setJourneyClockBackToStarted(PatientElectiveListBedAdmissionVo electiveList, PathwayRTTClockImpactVo admissionClockImpact, boolean deferredForNonMedicalReason) throws StaleObjectException
	{
		if (electiveList == null)
			return electiveList;
		
		if (electiveList.getReferral() == null || electiveList.getReferral().getID_CatsReferral() == null)
			return electiveList;
		
		CATSReferral_ClockImpactVo referral = CATSReferral_ClockImpactVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, electiveList.getReferral().getID_CatsReferral()));

		// For Treatment Admission discharge where treatment was deferred - REVERT clock stop and set RTT status to previous status
			
		// Check if the referral has a journey and a current clock
		if (referral.getJourney() != null && referral.getJourney().getCurrentClock() != null)
		{
			// REVERT clock stop
			referral.getJourney().getCurrentClock().setStopDate(null);
			
			// REVERT RTT Status
			// 1 - first attempt to revert by admission clock impact record (this record might not be created)
			if (admissionClockImpact != null && Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())) 
			{
				// Initial & final clocks for the admissions
				PathwayRTTStatusRefVo admissionInitialStatus = admissionClockImpact.getInitialRTTStatus();
				PathwayRTTStatusRefVo admissionFinalStatus = admissionClockImpact.getFinalRTTStatus();
				// Current RTT Status for the Journey
				PathwayRTTStatusVo currentRTTStatus = referral.getJourney().getCurrentClock().getCurrentRTTStatus();

				if (referral.getJourney().getCurrentClock().getRTTStatusHistory() != null)
					referral.getJourney().getCurrentClock().getRTTStatusHistory().remove(admissionFinalStatus);
				
				// If the current RTT Status is a match for the current clock - then remove it and set a new status 
				if (admissionFinalStatus != null && currentRTTStatus != null
						&& admissionFinalStatus.getID_PathwayRTTStatus().equals(currentRTTStatus.getID_PathwayRTTStatus()))
				{
					referral.getJourney().getCurrentClock().getRTTStatusHistory().sort(SortOrder.DESCENDING);

					PathwayRTTStatusVo initialAdmissionStatusFull = PathwayRTTStatusVoAssembler.create((PathwayRTTStatus) getDomainFactory().getDomainObject(PathwayRTTStatus.class, admissionInitialStatus.getID_PathwayRTTStatus()));
					referral.getJourney().getCurrentClock().setCurrentRTTStatus(initialAdmissionStatusFull);
					referral.setCurrentRTTStatus(initialAdmissionStatusFull);
					
					if (referral.getJourney().getCurrentClock().getRTTStatusHistory() == null)
						referral.getJourney().getCurrentClock().setRTTStatusHistory(new PathwayRTTStatusRefVoCollection());
					
					if (!referral.getJourney().getCurrentClock().getRTTStatusHistory().contains(admissionInitialStatus))
						referral.getJourney().getCurrentClock().getRTTStatusHistory().add(initialAdmissionStatusFull);
				}
			}
		
			@SuppressWarnings("rawtypes")
			HashMap map = new HashMap();
			CatsReferral catsReferral = CATSReferral_ClockImpactVoAssembler.extractCatsReferral(getDomainFactory(), referral, map);
			
			//Cancel Any Pause associated with the clock - at domain object lever
			//WDEV-21811
			if (deferredForNonMedicalReason)
			{	
				catsReferral = cancelAssociatedClockPausesForReferral(catsReferral);
			}
			//WDEV-21811
			
			getDomainFactory().save(catsReferral);
			
		}
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, electiveList.getID_PatientElectiveList()));
	}
	//WDEV-21811
	@SuppressWarnings("unchecked")
	private CatsReferral cancelAssociatedClockPausesForReferral(CatsReferral catsReferral)
	{
		if (catsReferral == null || catsReferral.getJourney() == null && catsReferral.getJourney().getCurrentClock() == null)
			return null;

		List<PauseDetails> clockPauses = catsReferral.getJourney().getCurrentClock().getPauseDetails();

		if (clockPauses != null)
		{
			for (PauseDetails pause : clockPauses)
			{
				if (pause != null && Boolean.TRUE.equals(pause.isActive()))
				{	
					pause.setActive(Boolean.FALSE);
				}
			}
			catsReferral.getJourney().getCurrentClock().setPauseDetails(clockPauses);
		}
		PauseDetails currentPause = catsReferral.getJourney().getCurrentClock().getCurrentPause();
		if (currentPause != null && Boolean.TRUE.equals(currentPause.isActive()))
		{	
			currentPause.setActive(Boolean.FALSE);
			catsReferral.getJourney().getCurrentClock().setCurrentPause(currentPause);
		}	
		
		return catsReferral;
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PatientElectiveListBedAdmissionVo setFirstDefinitiveTreatement(PatientElectiveListBedAdmissionVo electiveList, AdmissionDetailVo currentAdmissionDetails, Date eventDateTime) throws StaleObjectException
	{
		if (electiveList == null || currentAdmissionDetails == null)
			return electiveList;
		
		if (electiveList.getReferral() == null || electiveList.getReferral().getID_CatsReferral() == null)
			return electiveList;
		
		@SuppressWarnings("rawtypes")
		HashMap map = new HashMap();
		
		AdmissionDetail domAdmissionDetails = (AdmissionDetail) getDomainFactory().getDomainObject(AdmissionDetail.class, currentAdmissionDetails.getID_AdmissionDetail());
		CatsReferral domCatsReferral = (CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, electiveList.getReferral().getID_CatsReferral());
		
		// For Diagnostic Admission discharge where treatment was given - set the status to 30 (Start Of First Definitive Treatment) and stop the clock
		// Also record the RTT Clock Impact as a diagnostic 
		PathwaysRTTClockImpact domClockImpact = null;
			
		// Create the RTT Status
		PathwayRTTStatus newRTTStatus = new PathwayRTTStatus();
		newRTTStatus.setRTTStatus(getRTTStatusPoint(START_OF_FIRST_DEFINITIVE_TREATMENT));
		Object mos = getMosUser();
		if (mos instanceof MemberOfStaffLiteVo)
		{
			newRTTStatus.setStatusBy((MemberOfStaff) getDomainFactory().getDomainObject(MemberOfStaff.class, ((MemberOfStaffLiteVo) mos).getID_MemberOfStaff()));
		}
		newRTTStatus.setStatusDateTime(eventDateTime);
		newRTTStatus.setSetting("I");
		
		// Check if the referral has a journey and a current clock
		if (domCatsReferral.getJourney() != null && domCatsReferral.getJourney().getCurrentClock() != null)
		{
			// Get initial clock and initial  
			PathwayClock initialClock = domCatsReferral.getJourney().getCurrentClock();
			PathwayRTTStatus initialStatus = domCatsReferral.getJourney().getCurrentClock().getCurrentRTTStatus();
			RTTClockState initialClockState = getClockState(initialClock);
			
			
			// Stop the clock if not already stopped
			if (domCatsReferral.getJourney().getCurrentClock().getStopDate() == null)
			{
				domCatsReferral.getJourney().getCurrentClock().setStopDate(new java.util.Date());
			}
			
			// Update current clock status
			if (domCatsReferral.getJourney().getCurrentClock().getRTTStatusHistory() == null)
				domCatsReferral.getJourney().getCurrentClock().setRTTStatusHistory(new ArrayList());
			
			domCatsReferral.getJourney().getCurrentClock().setCurrentRTTStatus(newRTTStatus);
			domCatsReferral.getJourney().getCurrentClock().getRTTStatusHistory().add(newRTTStatus);
			
			PathwayClock finalClock = domCatsReferral.getJourney().getCurrentClock();
			PathwayRTTStatus finalStatus = newRTTStatus;
			RTTClockState finalClockState = getClockState(finalClock);

			domClockImpact = createRTTClockImpactRecord(initialClock, finalClock, initialStatus, finalStatus, initialClockState, finalClockState, null, domCatsReferral.getJourney(), RTTClockImpactSource.DIAGNOSTIC_DISCHARGE);

			if (domCatsReferral.getRTTClockImpacts() == null)
				domCatsReferral.setRTTClockImpacts(new ArrayList());
			domCatsReferral.getRTTClockImpacts().add(domClockImpact);
			domAdmissionDetails.setDischargeRTTOutcome(domClockImpact);
		}
		
		domCatsReferral.setCurrentRTTStatus(newRTTStatus);

		getDomainFactory().save(domCatsReferral);
		getDomainFactory().save(domAdmissionDetails);
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, electiveList.getID_PatientElectiveList()));
	}


	private PathwaysRTTClockImpact createRTTClockImpactRecord(PathwayClock initialClock, PathwayClock finalClock,
															  PathwayRTTStatus initialStatus, PathwayRTTStatus finalStatus,
															  RTTClockState initialClockState, RTTClockState finalClockState,
															  RTTStatusEventMap eventMap, PatientPathwayJourney journey,
															  RTTClockImpactSource source)
	{
		PathwaysRTTClockImpact clockImpact = new PathwaysRTTClockImpact();
		
		clockImpact.setInitialClock(initialClock);
		clockImpact.setFinalClock(finalClock);
		clockImpact.setInitialRTTStatus(initialStatus);
		clockImpact.setFinalRTTStatus(finalStatus);
		
		clockImpact.setOutcomeEvent(eventMap);
		clockImpact.setJourney(journey);
		clockImpact.setSource(getDomLookup(source));
		
		clockImpact.setInitialClockState(getDomLookup(initialClockState));
		clockImpact.setFinalClockState(getDomLookup(finalClockState));
		
		
		clockImpact.setClockStarted(Boolean.FALSE);
		clockImpact.setClockStopped(Boolean.FALSE);
		
		//  Case 1 - If there was not clock initially and one clock was created
		if (initialClock == null && finalClock != null)
		{
			// New clock has a start date - mark the Clock Impact
			if (finalClock.getStartDate() != null)
				clockImpact.setClockStarted(Boolean.TRUE);
			
			if (finalClock.getStopDate() != null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}
		
		// Case 2 - If there was a clock initially and there is no clock now
		if (initialClock != null && finalClock == null)
		{
			clockImpact.setClockStopped(Boolean.TRUE);
		}
		
		// Case 3 - If there was an initial clock and a clock is present now
		if (initialClock != null && finalClock != null)
		{
			// Case 3.1 - Initial and current clock are the same one
			if (initialClock.getId() == finalClock.getId())
			{
				if (initialClock.getStopDate() == null && finalClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
				
				if (initialClock.getStopDate() != null && finalClock.getStopDate() == null)
					clockImpact.setClockStarted(Boolean.TRUE);
				
				if (initialClock.getStartDate() == null && finalClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
			}
			
			// Case 3.2 - Initial and current clock are not the same one
			if (initialClock.getId() != finalClock.getId())
			{
				if (initialClock.getStopDate() == null)
					clockImpact.setClockStopped(Boolean.TRUE);
				
				if (finalClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
				
				if (finalClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
			}
			
		}

		return clockImpact;
	}

	private RTTClockState getClockState(PathwayClock clock)
	{
		if (clock == null)
			return RTTClockState.NOT_PRESENT;
		
		if (clock.getStopDate() != null)
			return RTTClockState.STOPPED;
		
		return RTTClockState.STARTED;
	}
	

	private void cancelCaseNoteRequests(Integer tciId) throws StaleObjectException
	{
		PatientCaseNoteRequestLiteVoCollection requestsForCancellation = getLinkedCaseNoteOpenRequests(tciId);
		
		if (requestsForCancellation == null || requestsForCancellation.size() == 0)
			return;
		
		Object mos = getMosUser();
		
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		
		for (int i = 0; i < requestsForCancellation.size(); i++)
		{
			impl.cancelRequest(requestsForCancellation.get(i), (MemberOfStaffRefVo) mos, CaseNoteRequestCancellationReason.TCI_CANCELLED); //WDEV-20989
		}
		
	}
	
	private PatientCaseNoteRequestLiteVoCollection getLinkedCaseNoteOpenRequests(Integer tciId)
	{
		if(tciId == null)
			   return null;
		
		List<?> list = getDomainFactory().find("select req from PatientCaseNoteRequest as req left join req.tCIDetail as tci left join req.requestStatus as status " +
				"where (tci.id = :tciID and status.id = :requestStatusID)", new String[] {"tciID", "requestStatusID"}, new Object[] {tciId, CaseNoteRequestStatus.OPEN.getID()});
		
		return PatientCaseNoteRequestLiteVoAssembler.createPatientCaseNoteRequestLiteVoCollectionFromPatientCaseNoteRequest(list);
	}

	//WDEV-18754 //WDEV-22685 //WDEV-22794 no longer update WardAttender
	private void markAssociatedAppoinmentAsDischarged(DomainFactory factory, Integer pasEventID, DateTime dischargeDateTime) throws StaleObjectException
	{

		String hql = "from Booking_Appointment ba " + 
				"where ba.pASEvent.id = :eventId " +
				"and ba.currentStatusRecord.status = :statID " +
 				"and (ba.isWardAttendance is null OR ba.isWardAttendance = 0) " + 
				"and (ba.isRIE is null OR ba.isRIE = 0)";

		ArrayList<String> labels = new ArrayList<String>();
		labels.add("eventId");
		labels.add("statID");

		ArrayList<Object> values = new ArrayList<Object>();
		values.add(pasEventID);
		values.add(getDomLookup(Status_Reason.ADMITTED));

		List<?> apptList = getDomainFactory().find(hql.toString(), labels, values);

		if (apptList == null || apptList.isEmpty())
			return;	
		for (int i = 0 ; i < apptList.size(); i++)
		{				
			Booking_Appointment doAppt = (Booking_Appointment) apptList.get(i);

			doAppt.getApptStatusHistory().add(doAppt.getCurrentStatusRecord());

			Appointment_Status doApptStat = new Appointment_Status();
			doApptStat.setStatus(getDomLookup(Status_Reason.DISCHARGED));
			////WDEV-22655
			doApptStat.setStatusChangeDateTime(dischargeDateTime != null ? dischargeDateTime.getJavaDate() : new DateTime().getJavaDate());
			doApptStat.setApptDate(doAppt.getAppointmentDate());
			doApptStat.setApptTime(doAppt.getApptStartTime());
			//WDEV-23185
			if (doAppt.getSession() != null)
			{
				doApptStat.setSession(doAppt.getSession()); 				
			} //WDEV-23185

			doAppt.setCurrentStatusRecord(doApptStat);
			doAppt.setApptStatus(getDomLookup(Status_Reason.DISCHARGED));

			factory.save(doAppt);
		}		
	}
	
	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private RTTStatusPoint updateRTTStatus(CatsReferral doCats, Date eventDateTime) throws DomainInterfaceException, StaleObjectException
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;
		
		if(doCats == null)
			return null;
		
		if(doCats.isRTTClockImpact() == null || Boolean.FALSE.equals(doCats.isRTTClockImpact()))
			return null;
		
		PathwayRTTStatus rttStatus = createPathwayRTTStatus(doCats, eventDateTime);
		
		doCats.setCurrentRTTStatus(rttStatus);
		
		RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus.getRTTStatus());

		if (rttMap != null && rttMap.getEvent() != null)
		{
			PatientEventVo patEvent = new PatientEventVo();
			patEvent.setPatient(PatientListVoAssembler.create(doCats.getPatient()));
			patEvent.setEvent(rttMap.getEvent());
			patEvent.setEventDateTime(new DateTime());
			patEvent.setEventStatus(EventStatus.ACTIVE);
			patEvent.setJourney(PatientJourneyVoAssembler.create(doCats.getJourney()));

			try
			{
				Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
				IPathwayPatientEventHelper pathwayImp = (IPathwayPatientEventHelper) getDomainImpl(implClass);
				pathwayImp.instantiatePatientEvent(patEvent);
			}
			catch (ClassNotFoundException e)
			{
				//Log the exception in system, should be fine
				e.printStackTrace();
			}
		}
		
		return rttStatus.getRTTStatus();
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;
		
		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1 and rttMap.encounterType is null ";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});
		
		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}
		
		return null;
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral doCats, Date eventDateTime)
	{
		if(doCats == null)
			return null;
		
		RTTStatusPoint rttStatusPoint = getRTTStatusPoint(START_OF_FIRST_DEFINITIVE_TREATMENT);
		Object mos = getMosUser();
		MemberOfStaff doMos = null;
		
		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}
		
		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(eventDateTime);
		pathwayRTTStatus.setSetting("I");//WDEV-23292
		
		if(doCats.getJourney() != null && doCats.getJourney().getCurrentClock() != null)
    	{
			doCats.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);
    			
    		if(doCats.getJourney().getCurrentClock().getRTTStatusHistory() == null)
    			doCats.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());
    			
    		doCats.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
    	}
		
		return pathwayRTTStatus;
	}
	
	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";
		
		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});
		
		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}
		
		return null;
	}
	
	private ims.core.vo.DischargedEpisodeADTVo dischargePatient(PatientLite_IdentifiersVo patient, ims.core.vo.DischargedEpisodeADTVo voDischEpis, BedSpaceStateLiteVo voBedSpacState, Boolean hasElectiveList, PatientElectiveList domElectiveList, DeathDetailsVo deathDetailsVo, Boolean cancelApptsForDeceasedPatient, Boolean checkPatientsGender) throws ForeignKeyViolationException, DomainInterfaceException, ims.domain.exceptions.StaleObjectException
	{
		if(voDischEpis == null)
			throw new CodingRuntimeException("dischargedEpisode is null in method dischargePatient");
		if (!voDischEpis.isValidated())
			throw new CodingRuntimeException("voDischEpis has not been validated!");
		if(patient == null)
			throw new CodingRuntimeException("voPatient is null in method dischargePatient");
		
		DomainFactory factory = getDomainFactory();		
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient().intValue());
		DischargedEpisode disDo = DischargedEpisodeADTVoAssembler.extractDischargedEpisode(factory, voDischEpis);
	
		ConsultantStay oldCs = getCurrentConsultantStay(disDo.getConsultantStays());
		if(oldCs != null)
		{
			oldCs.setEndDateTime(disDo.getDischargeDateTime());
		}
		
		//WDEV-20134  --- start
		WardStay oldWs = getCurrentWardStay(disDo.getWardStays());
		if (oldWs != null)
		{
			oldWs.setTransferOutDateTime(disDo.getDischargeDateTime());
		}
		//WDEV-20134 --- ends here
		
		BedSpaceState doBed = null;
		if(voBedSpacState != null)
			doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpacState);
	
		PASEvent peDo = disDo.getPasEvent();
		
		InpatientEpisode ipDo = getCurrentAdmission(factory, patient);
		
		// Patient was discharged already
		if (ipDo == null)
		{
			throw new StaleObjectException(ipDo);
		}
		
		if (ipDo != null)
		{			
			if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			{
				Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
				inpatRec.DataCollection.add();
				
				copyToDtoForDischarge(inpatRec, ipDo, disDo);
				Result res = inpatRec.executeAction("DISCHARGE");
				if (res != null)
				{
					if(res.getId() == -2)
					{
						//specifically ignore this error see WDEV-8158 - patient is not an inpatient
						String error = "Inpatient not found on Hearts - Maxims proceeding with Discharge";
						LOG.error(error);
						createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, error);
					}
					else if(res.getId() != 0)
						throw new DTODomainInterfaceException(res.getId(), "Error occurred Discharging Patient on PAS " + res.getMessage());
				}
			}
			
			//Dod implementation here - if the reason is mapped to PATIENTDIED(4) or STILLBIRTH(5)
			if(disDo.getMethodOfDischarge() != null)
			{
				String mapping = getLookupService().getRemoteLookup(disDo.getMethodOfDischarge().getId(), TaxonomyType.PAS.getIItemText());
				if(mapping != null && (mapping.equals(PATIENTDIED) || mapping.equals(STILLBIRTH)))
				{
//					Date dischDT = disDo.getDischargeDateTime();
//					//WDEV-22439
//					SimpleDateFormat sdfDate = new SimpleDateFormat("HH:mm:ss");
//					String strTime = sdfDate.format(dischDT);
					
					//WDEV-22923 the patient DOD should not be populated with Discharge Date/Time
					domPatient.setDod(deathDetailsVo != null && deathDetailsVo.getPatient().getDodIsNotNull() ? deathDetailsVo.getPatient().getDod().getDate() :null);
					domPatient.setTimeOfDeath(deathDetailsVo != null && deathDetailsVo.getPatient().getTimeOfDeathIsNotNull() ? deathDetailsVo.getPatient().getTimeOfDeath().toString() : null);//WDEV-22439
				}	
			}

			//Want to re-use the one that was created for the Admission. No need for a new one on Discharge.
			peDo = ipDo.getPasEvent();
			factory.initialize(peDo);
			
			//WDEV-8312
			List admList = factory.find("from AdmissionDetail adm where adm.pasEvent.id = " + peDo.getId());
			if(admList != null && admList.size() > 0)
			{
				AdmissionDetail doAdmissionDetail =  (AdmissionDetail) admList.get(0);
				doAdmissionDetail.setWard(null);
				doAdmissionDetail.setBed(null);
				factory.save(doAdmissionDetail);
			}
			 
			//WDEV-18450 
			if (Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue()) && Boolean.TRUE.equals(voDischEpis.getWasTreatmentGiven()))  
			{
				// WDEV-18617
				if (domElectiveList != null && domElectiveList.getElectiveListReason().getId() == ElectiveListReason.DIAGNOSTIC.getId())
				{
					// Need to stop the lock clock as patient was treated during diagnostics
					if (domElectiveList.getReferral() != null && domElectiveList.getReferral().getJourney() != null && domElectiveList.getReferral().getJourney().getCurrentClock() != null)
					{
						domElectiveList.getReferral().getJourney().getCurrentClock().setStopDate(ipDo != null ? ipDo.getAdmissionDateTime() : new Date());
						factory.save(domElectiveList);
					}
				}
				else
				{
					List catsList = factory.find("from CatsReferral cats where cats.careContext.pasEvent.id = " + peDo.getId());
					if (catsList != null && catsList.size() > 0)
					{
						CatsReferral doCatsDetails = (CatsReferral) catsList.get(0);

						if (doCatsDetails != null && Boolean.TRUE.equals(doCatsDetails.isRTTClockImpact()) && doCatsDetails.getJourney() != null && 
								doCatsDetails.getJourney().getCurrentClock() != null && 
								(doCatsDetails.getJourney().getCurrentClock().getStopDate() != null || Boolean.TRUE.equals(hasElectiveList))&& 
								doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory() != null)
						{
							PathwayRTTStatus doPreviousCurrentPathwayRttStatus = getStatusPreviousTheClockStop(doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory());
							PathwayRTTStatus doNewPathwayRttStatus = createNewStausBasedOnThePreviousStatus(doPreviousCurrentPathwayRttStatus);
							if (doNewPathwayRttStatus != null)
							{
								doCatsDetails.setCurrentRTTStatus(doNewPathwayRttStatus);
								doCatsDetails.getJourney().getCurrentClock().setCurrentRTTStatus(doNewPathwayRttStatus);
								doCatsDetails.getJourney().getCurrentClock().setStopDate(null);
								doCatsDetails.getJourney().getCurrentClock().getRTTStatusHistory().add(doNewPathwayRttStatus);
								factory.save(doCatsDetails);
							}
						}
					}
				}
			}				
			
			//WDEV-8403
			if(peDo.getPatient() != null)
			{
				peDo.getPatient().setWard(null);
				// WDEV-17867 - Clear Current Responsible Consultant from Patient record
				peDo.getPatient().setCurrentResponsibleConsultant(null);
			}
			
			disDo.setPasEvent(peDo);
			if(doBed != null)
			{
				doBed.setInpatientEpisode(null);
				factory.save(doBed);
			}
			
			if(ipDo != null)
			{
				PendingTransfers doTransfer = PendingTransfers.getPendingTransfersFromInpatientEpisode(factory, ipDo.getId());
				if(doTransfer != null)
					getDomainFactory().delete(doTransfer);
				
				if (Boolean.TRUE.equals(ipDo.isIsOnHomeLeave())) //WDEV-21086
				{
					HomeLeaveVo lastOngoingHomeLeave = getLatestOngoingHomeLeave(InPatientEpisodeADTVoAssembler.create(ipDo));
					
					if (lastOngoingHomeLeave != null)
					{
						lastOngoingHomeLeave.setDateReturnedFromHomeLeave(new ims.framework.utils.Date(disDo.getDischargeDateTime()));
						lastOngoingHomeLeave.setTimeReturnedFromHomeLeave(new Time(disDo.getDischargeDateTime()));
						
						HomeLeave doHl = HomeLeaveVoAssembler.extractHomeLeave(factory, lastOngoingHomeLeave);
						
						ipDo.getHomeLeaves().set(ipDo.getHomeLeaves().indexOf(doHl), doHl);
					}
					ipDo.setIsOnHomeLeave(Boolean.FALSE);
					ipDo.setDateOnHomeLeave(null);
					ipDo.setTimeOnHomeLeave(null);
					ipDo.setExpectedDateOfReturn(null);
					ipDo.setExpectedTimeOfReturn(null);
					ipDo.setVacatedBedNumber(null);					
				}
			}
				
			//copy over home Leaves
			for (int i = 0 ; i < ipDo.getHomeLeaves().size() ; i++)
			{
				if(ipDo.getHomeLeaves().get(i) == null)
					continue;

				disDo.getHomeLeaves().add((HomeLeave)ipDo.getHomeLeaves().get(i));
				
				ipDo.getHomeLeaves().remove(i);
			}
			
			//WDEV-19680
			ADT adtImpl = (ADT) getDomainImpl(ADTImpl.class);
			adtImpl.vteOnDischarge(domPatient, disDo, ipDo);
			
			factory.delete(ipDo);
		}
		
		factory.save(peDo);
		factory.save(disDo);
		
		//Clear the ward field in Patient record. No longer an inpatient.
		domPatient.setWard(null);
		// WDEV-17867 - Clear Current Responsible Consultant from Patient record
		domPatient.setCurrentResponsibleConsultant(null);
		
		factory.save(domPatient);
		boolean wasPatientAlreadySavedAsDeceased = domPatient.getDod() != null && patient.getDod() == null && domPatient.getVersion() > patient.getVersion_Patient();
				
		//WDEV-12732 - have set other fields other than issue has requested - same as what happens in ADTImpl
		if(ConfigFlag.HL7.INSTANTIATE_EPISODE_FROM_ADT.getValue()
			|| ConfigFlag.HL7.INPATIENT_EPISODE_MANAGEMENT_FROM_PAS.getValue()
			|| ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())//wdev-14358
		{
			StringBuilder queryContext = new StringBuilder("SELECT context FROM CareContext AS context LEFT JOIN context.pasEvent AS pas ");
			queryContext.append(" LEFT JOIN context.context AS contextType ");
			queryContext.append(" LEFT JOIN context.currentStatus AS contextStatus LEFT JOIN contextStatus.status AS status ");
			queryContext.append(" WHERE contextType.id = :INPATIENT_TYPE AND context.endDateTime is null ");
			queryContext.append(" AND pas.id = :PAS_ID ");
			
			ArrayList<String> paramNames = new ArrayList<String>();
			ArrayList<Object> paramValues = new ArrayList<Object>();
			
			paramNames.add("INPATIENT_TYPE");	paramValues.add(ContextType.INPATIENT.getId());
			paramNames.add("PAS_ID");			paramValues.add(peDo.getId());
			
			CareContext doCareContext = (CareContext) getDomainFactory().findFirst(queryContext.toString(), paramNames, paramValues);
			//WDEV-13121
			if(doCareContext != null)
			{
				doCareContext.setBedNumber(null);
				doCareContext.setCurrentStatus(new CareContextStatusHistory());
				doCareContext.getCurrentStatus().setStatusDateTime(new Date());
				if (doCareContext.getEndDateTime() == null && disDo != null)
					doCareContext.setEndDateTime(disDo.getDischargeDateTime());
				doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
				doCareContext.getStatusHistory().add(doCareContext.getCurrentStatus());
				factory.save(doCareContext);
			}
		}
		
		// WDEV-18742
		updateDementiaRecordForDischarge(factory,(domElectiveList!=null && domElectiveList.getTCIDetails()!=null ? domElectiveList.getTCIDetails().getAdmissionDetail() : null), disDo );
		
		// WDEV-19481 Assemble VO before triggerDischargeEvent for creation of HL7 message
		DischargedEpisodeVo disVo = DischargedEpisodeVoAssembler.create(disDo);
		if(disVo.getPasEvent()!=null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerDischargeEvent(disVo.getPasEvent());
		}
		//WDEV-19682
		if (deathDetailsVo != null)
		{
			Demographics patientDemographicsImpl = (Demographics) getDomainImpl(DemographicsImpl.class);
			patientDemographicsImpl.updatePatientDeceasedData(PatientAssembler.create(domPatient), deathDetailsVo, cancelApptsForDeceasedPatient, wasPatientAlreadySavedAsDeceased);
		}
		
		//WDEV-20217
		if (voBedSpacState != null)
			updateOccupiedBedsForWardAndBay(voBedSpacState.getWard(), voBedSpacState.getBay(), null);
		
		//WDEV-20224 
		if (voBedSpacState != null && Boolean.TRUE.equals(checkPatientsGender))
		{
			Sex patGender = patient.getSex() != null && !Sex.UNKNOWN.equals(patient.getSex()) ? patient.getSex() : null;
			checkAndUpdateBayConfig(factory, voBedSpacState,patGender);
		}
		//WDEV-22685
		if (disVo.getPasEventIsNotNull() && !Boolean.TRUE.equals(hasElectiveList))
			markAssociatedAppoinmentAsDischarged(factory, new Integer(disVo.getPasEvent().getID_PASEvent()), disVo.getDischargeDateTime());
		
		return DischargedEpisodeADTVoAssembler.create(disDo);
	}
	//WDEV-20927
	private void checkAndUpdateBayConfig(DomainFactory factory, BedSpaceStateLiteVo voBedSpacState, Sex tempGenderToSet) throws StaleObjectException
	{
		if (voBedSpacState.getBay() == null || voBedSpacState.getWard() == null)
			return;

		WardConfigLiteVo wardConfigLiteVo = getWardConfig(voBedSpacState.getWard());
		BayConfigLiteVo bayConfig = getBayConfig(voBedSpacState.getBay(), wardConfigLiteVo);	

		if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
		{
			Integer intMales = countMalePatientsOnTheWard(wardConfigLiteVo.getWard(), bayConfig.getBay());
			Integer intFemales = countFemalePatientsOnTheWard(wardConfigLiteVo.getWard(), bayConfig.getBay());
			boolean cfgChanged = false;
			
			if (tempGenderToSet != null)
			{	
				if (bayConfig.getNumOfOccupiedBeds() == null || bayConfig.getNumOfOccupiedBeds() == 0 || (intFemales == 0 && intMales == 0))
				{	
					bayConfig.setTemporaryBayGender(null);
					cfgChanged = true;
				}
				else if (allPatientsGenderMatchBayGender(bayConfig) || (intFemales == 0 &&  intMales != 0)  || (intMales == 0 && intFemales != 0))
				{				
					if (intMales != null && intMales >0 && !Sex.MALE.equals(bayConfig.getTemporaryBayGender()))
					{
						bayConfig.setTemporaryBayGender(Sex.MALE);
						cfgChanged = true;
					}
					if (intFemales != null && intFemales >0 && !Sex.FEMALE.equals(bayConfig.getTemporaryBayGender()))
					{
						bayConfig.setTemporaryBayGender(Sex.FEMALE);
						cfgChanged = true;
					}			
				}
			}
			if (cfgChanged)
			{	
				String[] err = bayConfig.validate();
				if (err == null)
				{	
					BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);				
					factory.save(bayConfigDO);
				}
			}	

		}
	}
	private void checkAndUpdatePreviousBayConfig(DomainFactory factory, BedSpaceStateLiteVo voBedSpacState, Sex tempGenderToSet) throws StaleObjectException
	{
		if (voBedSpacState.getBay() == null || voBedSpacState.getWard() == null)
			return;

		WardConfigLiteVo wardConfigLiteVo = getWardConfig(voBedSpacState.getWard());
		BayConfigLiteVo bayConfig = getBayConfig(voBedSpacState.getBay(), wardConfigLiteVo);		
		boolean wasConfigChanged = false;

		if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
		{
			if (bayConfig.getNumOfOccupiedBeds() == null || bayConfig.getNumOfOccupiedBeds() == 0)
			{	
				bayConfig.setTemporaryBayGender(null);
				wasConfigChanged = true;
			}	
			if (tempGenderToSet != null)
			{	
				Sex tempGender = getTempGenderToInstateForPreviousBay(wardConfigLiteVo, bayConfig);
				if (tempGender != null)
				{	
					bayConfig.setTemporaryBayGender(tempGender);
					wasConfigChanged = true;
					if (wasConfigChanged)
					{	
						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);
						factory.save(bayConfigDO);
					}
				}
			}
		}
	}
	private Sex getTempGenderToInstateForPreviousBay(WardConfigLiteVo wardConfigLiteVo,BayConfigLiteVo bayConfig)
	{
		if (wardConfigLiteVo == null || bayConfig == null)
			return null;
		
		Integer intMales = countMalePatientsOnTheWard(wardConfigLiteVo.getWard(), bayConfig.getBay());
		Integer intFemales = countFemalePatientsOnTheWard(wardConfigLiteVo.getWard(), bayConfig.getBay());
		
		if (bayConfig != null && bayConfig.getNumOfOccupiedBedsIsNotNull() &&  bayConfig.getNumOfOccupiedBeds() > 0)
		{
			if ((intFemales == null || intFemales == 0) && (intMales != null && intMales >= 0 && !Sex.MALE.equals(bayConfig.getTemporaryBayGender())))
				return Sex.MALE;
			if ((intMales == null || intMales == 0) && intFemales != null && intFemales >= 0 && !Sex.FEMALE.equals(bayConfig.getTemporaryBayGender()))
				return Sex.FEMALE;
		}
		return null;			
	}

	public Integer countMalePatientsOnTheWard(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return 0;
		
		StringBuilder query = new StringBuilder("SELECT COUNT (inpat.id) ");
		query.append(" FROM BedSpaceState as bs LEFT JOIN bs.inpatientEpisode as inpat LEFT JOIN inpat.bed AS bed ");
		query.append(" LEFT JOIN inpat.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" WHERE ");
		query.append(" bs.ward.id = :WARD_ID AND bs.bay.id = :BAY_ID AND bed is not null AND patient.sex.id = :MALE_SEX ");
		
		String[] paramNames = new String[] {"WARD_ID", "BAY_ID", "MALE_SEX" };
		Object[] paramValues = new Object[] {ward.getID_Location(),bay.getID_Location(), Sex.MALE.getID()}; 

		return (int) getDomainFactory().countWithHQL(query.toString(), paramNames, paramValues);
	}


	public Integer countFemalePatientsOnTheWard(LocationRefVo ward, LocationRefVo bay)
	{
		if (ward == null || ward.getID_Location() == null)
			return 0;
		
		StringBuilder query = new StringBuilder("SELECT COUNT (inpat.id) ");
		query.append(" FROM BedSpaceState as bs LEFT JOIN bs.inpatientEpisode as inpat LEFT JOIN inpat.bed AS bed ");
		query.append(" LEFT JOIN inpat.pasEvent AS pas LEFT JOIN pas.patient AS patient ");
		query.append(" WHERE ");
		query.append(" bs.ward.id = :WARD_ID AND bs.bay.id = :BAY_ID AND bed is not null AND patient.sex.id = :FEMALE_SEX ");
				
		String[] paramNames = new String[] {"WARD_ID", "BAY_ID", "FEMALE_SEX" };
		Object[] paramValues = new Object[] {ward.getID_Location(), bay.getID_Location(), Sex.FEMALE.getID()}; 

		return (int) getDomainFactory().countWithHQL(query.toString(), paramNames, paramValues);
	}

	private boolean allPatientsGenderMatchBayGender(BayConfigLiteVo bayConfig)
	{
		Sex genderToCheck = bayConfig.getTemporaryBayGender();
		
		if (genderToCheck != null)
		{		
			String hql = "select count(bedspacest.id) from BedSpaceState as bedspacest left join bedspacest.inpatientEpisode as inpat left join inpat.pasEvent as pasEv left join pasEv.patient as pat where bedspacest.bay.id = :BAY and pat.sex.id = :GENDER";
				
			long count = getDomainFactory().countWithHQL(hql, new String[]{"BAY", "GENDER"}, new Object[] {bayConfig.getBay().getID_Location(), genderToCheck.getID()});
				
			return (bayConfig.getNumOfOccupiedBedsIsNotNull() && new Integer((int)count).equals(bayConfig.getNumOfOccupiedBeds()));			
		}
		return false;
	}
	//WDEV-20927 -- end
	private BayConfigLiteVo getBayConfig(LocationLiteVo bay, WardConfigLiteVo wardConfigLiteVo)
	{
		if (wardConfigLiteVo != null && wardConfigLiteVo.getBays() != null)
		{
			Iterator<BayConfigLiteVo> bayIterator = wardConfigLiteVo.getBays().iterator();
			
			while (bayIterator.hasNext())
			{
				BayConfigLiteVo bayVo = bayIterator.next();
				if (bay != null && bayVo != null && bayVo.getBay().getID_Location().equals(bay.getID()))
						return bayVo;
					
			}
		}
		return null;
	}
	private WardStay getCurrentWardStay(Set wardStays)
	{
		if (wardStays == null)
			return null;
		
		Iterator<?> it = wardStays.iterator();
		
		while (it.hasNext())
		{
			Object ws = it.next();
			
			if(ws instanceof WardStay)
			{
				if(((WardStay) ws).getTransferOutDateTime() == null)
					return (WardStay) ws;
			}
		}
		return null;	
	}

	private ConsultantStay getCurrentConsultantStay(Set consultantStays)
	{
		if(consultantStays == null)
			return null;
		
		Iterator it = consultantStays.iterator();
		
		while(it.hasNext())
		{
			Object cs = it.next();
			
			if(cs instanceof ConsultantStay)
			{
				if(((ConsultantStay) cs).getEndDateTime() == null)
					return (ConsultantStay) cs;
			}
		}
		
		return null;
	}
	
	
	
	// WDEV-18742
    private void updateDementiaRecordForDischarge(DomainFactory factory, AdmissionDetail admissionDetail, DischargedEpisode disDo) throws StaleObjectException, ForeignKeyViolationException
	{
    	ADT impl = (ADT) getDomainImpl(ADTImpl.class);
    	impl.updateDementiaRecordForDischarge(factory, admissionDetail, disDo);
	}

	private PathwayRTTStatus createNewStausBasedOnThePreviousStatus(PathwayRTTStatus doPreviousCurrentPathwayRttStatus)
	{
		if(doPreviousCurrentPathwayRttStatus != null)
		{
    		PathwayRTTStatus rttStatusDO = new PathwayRTTStatus();
    		
    		rttStatusDO.setRTTStatus(doPreviousCurrentPathwayRttStatus.getRTTStatus());
    		
    		Object mos = getMosUser();
    		MemberOfStaff doMos = null;
    		
    		if(mos instanceof MemberOfStaffLiteVo)
    		{
    			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
    		}
    		
    		rttStatusDO.setStatusBy(doMos);
    		// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
    		rttStatusDO.setStatusDateTime(doPreviousCurrentPathwayRttStatus.getStatusDateTime());
    		rttStatusDO.setSetting("I");
    		
    		return rttStatusDO;
		}
		return null;
	}

	private PathwayRTTStatus getStatusPreviousTheClockStop(List listCatsReferralRttHistory)
	{
		List<Integer> statusToBeRemoved =statusToBeRemovedList();
		
		if (listCatsReferralRttHistory.size() > 0)
		{
			PathwayRTTStatus doPathwayRttStatus = null;
			for (int i = listCatsReferralRttHistory.size() -1 ; i >=0 ; i-- )
			{
				doPathwayRttStatus = (PathwayRTTStatus) listCatsReferralRttHistory.get(i);
				Integer nationalCode = doPathwayRttStatus.getRTTStatus() != null ? doPathwayRttStatus.getRTTStatus().getNationalCode() : null;
				
				if(nationalCode != null && !statusToBeRemoved.contains(nationalCode))
				{
					return doPathwayRttStatus;
				}						
			}			
		}		
		return null;
	}

	private List<Integer> statusToBeRemovedList()
	{
		List<Integer> listOfStatusesToBeRemoved = new ArrayList<Integer>();
		listOfStatusesToBeRemoved.add(30);
		listOfStatusesToBeRemoved.add(31);
		listOfStatusesToBeRemoved.add(32);
		listOfStatusesToBeRemoved.add(33);
		listOfStatusesToBeRemoved.add(34);
		listOfStatusesToBeRemoved.add(35);
		listOfStatusesToBeRemoved.add(36);
		return listOfStatusesToBeRemoved;
	}

	private InpatientEpisode getCurrentAdmission(DomainFactory factory, PatientRefVo patVo) 
	{
		ims.core.patient.domain.objects.Patient domPatient = (ims.core.patient.domain.objects.Patient)factory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patVo.getID_Patient().intValue());
		
		String hql = "from InpatientEpisode ip where ip.pasEvent.patient.id = :pat";
		List<?> l = factory.find(hql, new String[] {"pat"}, new Object[] {domPatient.getId()});		
		if (l != null && l.size() > 0)
		{
			return (InpatientEpisode)l.get(0);
		}
		return null;
	}

	public InpatConsultantTransferVo getInpatConsultantTransfer(InpatientEpisodeRefVo inpat)
	{
		if(inpat == null || inpat.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpatientEpisode is null or id not provided for getInpatConsultantTransfer");
		
		return InpatConsultantTransferVoAssembler.create( (InpatientEpisode) getDomainFactory().getDomainObject(inpat));
	}

	public CareContextShortVo saveInpatConsultantTransfer(InpatConsultantTransferVo inpatConsTransfer) throws DomainInterfaceException, StaleObjectException
	{
		if(inpatConsTransfer == null)
			throw new CodingRuntimeException("inpatConsTransfer is null in method saveInpatConsultantTransfer");
		if(!inpatConsTransfer.isValidated())
			throw new CodingRuntimeException("inpatConsTransfer has not been validated in method saveInpatConsultantTransfer");

		Inpat inpatRec = null;
		if (!ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();
		}
		
		InpatientEpisode doInpat = InpatConsultantTransferVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatConsTransfer);
		
		if (inpatRec != null)
		{
			copyInpatEpisodeToDtoForTransfer(inpatRec, doInpat, true, false, null);
			Result res = inpatRec.executeAction("TRANSFER");
			if (res != null && res.getId() != 0)
				throw new DTODomainInterfaceException(res.getId(), "Error occurred Transferring Patient on PAS " + res.getMessage());
		}
		//WDEV-20675 currentResponsibleConsultant should be the same in Patient record and in the Pas Event that corresponds to current admission
		if (doInpat.getPasEvent() != null && doInpat.getPasEvent().getPatient() != null)
		{				
			doInpat.getPasEvent().getPatient().setCurrentResponsibleConsultant(doInpat.getPasEvent().getConsultant());			
		}
		getDomainFactory().save(doInpat);
		
		// WDEV-19481 - Trigger creation of A08 Update Admission HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpat);
		if(inpatEpisodeVo.getPasEvent()!=null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerUpdateAdmissionEvent(inpatEpisodeVo.getPasEvent(),MsgUpdateType.CONSULTANT);//http://jira/browse/WDEV-22831
		}
		
		//WDEV-11479 - update the CareContext with the ResponsibleHcp
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(inpatConsTransfer.getPasEvent());
		if(voCareContext != null)
		{
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(getDomainFactory(), voCareContext);			
			if(doInpat != null && doInpat.getPasEvent() != null && doCareContext.getEpisodeOfCare() != null) 
			{
				doCareContext.setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue()) //wdev-14309
				{
					doCareContext.getEpisodeOfCare().setSpecialty(doInpat.getPasEvent().getSpecialty());	//	WDEV-12764
					doCareContext.getEpisodeOfCare().setResponsibleHCP(doInpat.getPasEvent().getConsultant());
				}
			}
					
			getDomainFactory().save(doCareContext);	
			return CareContextShortVoAssembler.create(doCareContext);
		}
		
		return null;	
	}

	public LocationLiteVo getParentLocation(LocationRefVo childLoc)
	{
		if(childLoc == null || childLoc.getID_Location() == null )
			throw new CodingRuntimeException("childLoc is null or id not provided in method getParentLocation");

		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{	
			OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
			return impl.getHospitalLiteForLocation((ILocation)childLoc);
		}
		else
		{	
			Location doLocation = (Location) getDomainFactory().getDomainObject(childLoc);
			return LocationLiteVoAssembler.create(doLocation.getParentLocation());
		}
	}

	public BedSpaceStateLiteVo saveCloseBed(BedSpaceStateLiteVo bedSpaceState, String user, ReasonForBedClosure reason, DateTime estReOpen) throws StaleObjectException
	{
		if(bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveCloseBed");
		
		BedSpaceState doBedSpace = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState);
		doBedSpace.getCurrentBedStatus().setEstReopeningDateTime(estReOpen != null ? estReOpen.getJavaDate() : null);
		doBedSpace.getCurrentBedStatus().setReasonForClosure(getDomLookup(reason));
		doBedSpace.getCurrentBedStatus().getSystemInformation().setCreationUser(user);
		
		getDomainFactory().save(doBedSpace);
		return BedSpaceStateLiteVoAssembler.create(doBedSpace);
	}

	public BedSpaceStateStatusVo getBedSpaceStateStatus(BedSpaceStateStatusRefVo bedSpaceStateStatus)
	{
		if(bedSpaceStateStatus == null || bedSpaceStateStatus.getID_BedSpaceStateStatus() == null)
			throw new CodingRuntimeException("bedSpaceStateStatus is null or id not provided in method getBedSpaceStateStatus");
		
		return BedSpaceStateStatusVoAssembler.create((BedSpaceStateStatus) getDomainFactory().getDomainObject(bedSpaceStateStatus));
	}

	public void saveReOpenOrAssignBed(BedSpaceStateLiteVo bedSpaceState) throws StaleObjectException
	{
		if(bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveReOpenOrAssignBed");
		
		//WDEV-8507
		bedSpaceState.setInpatientEpisode(null);
		
		getDomainFactory().save(BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState));	
	}

	public void cancelTransfer(PendingTransfersLiteVo voTransfer, LocationRefVo voCancellingFromWard) throws StaleObjectException, ForeignKeyViolationException
	{		
		if (voTransfer == null || voTransfer.getID_PendingTransfers() == null)
			throw new CodingRuntimeException("voTransfer is null or id not provided in method cancelTransfer");
		
		//WDEV-10421 - get the admission detail record and update its history for transfers
		PendingTransfers doPending = (PendingTransfers) getDomainFactory().getDomainObject(voTransfer);
		
		if (doPending == null || doPending.getVersion() > voTransfer.getVersion_PendingTransfers()) //WDEV-20326
			throw new StaleObjectException(doPending, "This transfer has been processed by another user");
		
		AdmissionDetail doAdmissionDetail = populateTransferHistory(doPending, TRANSFERCANCEL, voCancellingFromWard, voTransfer.getCancellationReasonDetails());
		
		// WDEV-19774 - Trigger creation of A26 Cancel Pending Transfer HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doPending.getInpatientEpisode());
		if(inpatEpisodeVo.getPasEvent()!=null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerCancelPendingTransferEvent(inpatEpisodeVo.getPasEvent());
		} //WDEV-19974
	
		getDomainFactory().delete("from PendingTransfers p where p.id = '" + voTransfer.getID_PendingTransfers() + "'");
		
		//WDEV-10421
		if(doAdmissionDetail != null)
			getDomainFactory().save(doAdmissionDetail);
	}

	public CareContextShortVo saveEstimatedDischarge(InpatientEpisodeLiteVo inpatEpisode) throws StaleObjectException, DomainInterfaceException
	{
		if (inpatEpisode == null)
			throw new CodingRuntimeException("inpatEpisode is null in method saveEstimatedDischarge");
		if (!inpatEpisode.isValidated())
			throw new CodingRuntimeException("inpatEpisode has not been validated in method saveEstimatedDischarge");
		
		Inpat inpatRec = null;
		if (Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			try
			{
				inpatRec = (Inpat) getDTOInstance(Inpat.class);	
			}
			catch(ResultException e)
			{
				throw new DomainInterfaceException("Failed to Connect to PAS - Please check Configuration", e);
			}
		}
		
		if(inpatEpisode.getEstDischargeDateIsNotNull())
		{
			if (inpatRec != null)
				inpatRec.Filter.clear();

			Result result = null;
			if (inpatEpisode.getPasEventIsNotNull() && inpatEpisode.getPasEvent().getPatientIsNotNull())
			{
				ims.core.vo.PatientId intfId = inpatEpisode.getPasEvent().getPatient().getHospnum();
				if (inpatRec != null)
				{
					inpatRec.Filter.Hospnum = intfId.getValue();
					result = inpatRec.get();
					if(inpatRec.DataCollection.count() == 0)
					{
						if(result != null)
							throw new DomainInterfaceException("Failed to get Inpat record on Pas " + result.getMessage());
					}
					
				InpatRecord inpatRecord = inpatRec.DataCollection.get(0);
				
				inpatRec.EditFilter.excludeAll();
				inpatRec.EditFilter.IncludeEddt = true;
				inpatRec.EditFilter.IncludeHospnum = true;

				//WDEV-12957
				if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
				{
					inpatRec.EditFilter.IncludeStay = true;
					inpatRec.EditFilter.IncludeDrdt = true;
					inpatRecord.Drdt = null; //WDEV-17662
					if(inpatRec.DataCollection.get(0).Addt != null && inpatEpisode.getEstDischargeDateIsNotNull())
					{
						try
						{
							inpatRecord.Stay = String.valueOf(ims.framework.utils.Date.daysBetween( new ims.framework.utils.DateTime(inpatRec.DataCollection.get(0).Addt).getDate(), inpatEpisode.getEstDischargeDate().getDate()));
						}
						catch (ParseException e)
						{
							throw new DomainRuntimeException("Error in Admission Date", e);
						}
					}
					if(inpatEpisode.getDischargeReadyDateIsNotNull())
						inpatRecord.Drdt = DTOHelper.convertToDtoDate(inpatEpisode.getDischargeReadyDate().getDate());
				}
				
				inpatRecord.Eddt = DTOHelper.convertToDtoDate(inpatEpisode.getEstDischargeDate().getDate().getDate());
				result = inpatRec.update();
				
				if(result != null && result.getId() < 0)
					throw new DomainInterfaceException("Attempt to save to Pas failed " + result.getMessage());
				}				

			}
		}	
		
		// WDEV-20018 - Trigger creation of A08 HL7 message
		// WDEV-20445 - Focus trigger of A08 message creation so that only occurs if Confirmed Date of Discharge IS null
		if(inpatEpisode.getPasEvent() != null
				&& inpatEpisode.getEstDischargeDate() != null
				&& inpatEpisode.getConfirmedDischargeDateTime() == null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerUpdateAdmissionEvent(inpatEpisode.getPasEvent(),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
		} //WDEV-20018
		
		//WDEV-20445 - Trigger creation of A16 (Pending Discharge) HL7 message
		if(inpatEpisode.getPasEvent() != null
				&& inpatEpisode.getConfirmedDischargeDateTimeIsNotNull())
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerPendingDischargeEvent(inpatEpisode.getPasEvent());			
		} //WDEV-20445
		
		//WDEV-20445 - Trigger creation of A25 (Cancel Pending Discharge) HL7 message
		// Generation of A25 message temporarily commented out. See WDEV-20506
//		if(inpatEpisode.getPasEvent() != null
//				&& inpatEpisode.getConfirmedDischargeDateTime() == null)
//		{
//			// User has cleared Confirmed date of discharge value
//	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
//			adtimpl.triggerCancelPendingDischargeEvent(inpatEpisode.getPasEvent());			
//		}
		//WDEV-20984 -- start 
		boolean updateBed = false;
		BedSpaceStateLiteVo bedSpaceStateLiteVo = null;
		if (Boolean.TRUE.equals(inpatEpisode.getIsReadyToLeave()) && inpatEpisode.getBedIsNotNull())
		{
			bedSpaceStateLiteVo = getBedSpaceStateByInpatientEpisode(inpatEpisode);

			if (bedSpaceStateLiteVo != null && (bedSpaceStateLiteVo.getInpatientEpisode() == null || bedSpaceStateLiteVo.getInpatientEpisode().getVersion_InpatientEpisode() > inpatEpisode.getVersion_InpatientEpisode() || !BedStatus.OCCUPIED.equals(bedSpaceStateLiteVo.getCurrentBedStatus().getBedStatus())))
			{
				throw new DomainInterfaceException(" The inpatient record has been updated by another user. The screen will be refreshed.");
			}

			if (bedSpaceStateLiteVo != null && bedSpaceStateLiteVo.getCurrentBedStatusIsNotNull() && BedStatus.OCCUPIED.equals(bedSpaceStateLiteVo.getCurrentBedStatus().getBedStatus()))
			{
				bedSpaceStateLiteVo.setPreviousBedStatus((BedSpaceStateStatusLiteVo) bedSpaceStateLiteVo.getCurrentBedStatus().clone());
				bedSpaceStateLiteVo.setCurrentBedStatus(new BedSpaceStateStatusLiteVo());
				bedSpaceStateLiteVo.getCurrentBedStatus().setStatusDateTime(inpatEpisode.getReadyToLeaveDecisionDateTimeIsNotNull() ? inpatEpisode.getReadyToLeaveDecisionDateTime() : new DateTime());
				bedSpaceStateLiteVo.getCurrentBedStatus().setBedStatus(BedStatus.AVAILABLE);

				if (bedSpaceStateLiteVo.getBedSpaceIsNotNull())
				{	
					inpatEpisode.setVacatedBedNumber(bedSpaceStateLiteVo.getBedSpace().getBedNumber());
				}
			}
			updateBed = true;
		}
		//WDEV-20984 -- end 1
				
		DomainFactory domainFactory = getDomainFactory();
				
		//WDEV-11438 - update the CareContext with the EDD
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(inpatEpisode.getPasEvent());

		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			AdmissionDetailVo admissionDetailsVo = getAdmissionDetailByPasEvent(inpatEpisode.getPasEvent());
			if (admissionDetailsVo != null)
			{	
				AdmissionDetail admissionDetailsDO = updateExtendedDetails(admissionDetailsVo, domainFactory, inpatEpisode,voCareContext);
				domainFactory.save(admissionDetailsDO);
			}
		}
		InpatientEpisode inpatDO = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(domainFactory, inpatEpisode);
		if (updateBed)
		{
			inpatDO.setBed(null);
			inpatDO.setBedNo(null);
		}
		domainFactory.save(inpatDO);
		
		if (updateBed)
		{
			BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(domainFactory, bedSpaceStateLiteVo);
			doBed.setInpatientEpisode(null);
		
			domainFactory.save(doBed);
		}
		InpatientEpisodeLiteVo savedInpat = InpatientEpisodeLiteVoAssembler.create(inpatDO);
		//voCareContext = impl.getCareContextForPasEvent(inpatEpisode.getPasEvent());
		
		if(voCareContext != null)
		{
			voCareContext.setEstimatedDischargeDate(savedInpat.getEstDischargeDateIsNotNull() ? savedInpat.getEstDischargeDate().getDate() : null);
			CareContext doCareContext = CareContextShortVoAssembler.extractCareContext(domainFactory, voCareContext);			
			domainFactory.save(doCareContext);	
			return CareContextShortVoAssembler.create(doCareContext);
		}
		
		
		
		return null;
	}

	
	private PatientTransportRequirementsVo getPatientTransportRequirements(CareContextRefVo careContext)
	{
		if (careContext == null)
			return null;
		
		String hqlQuery = "SELECT patTranReq FROM PatientTransportRequirements AS patTranReq WHERE patTranReq.careContext.id = :Context_ID AND (patTranReq.isRIE is null OR patTranReq.isRIE = 0)";
		
		return PatientTransportRequirementsVoAssembler.create((PatientTransportRequirements) getDomainFactory().findFirst(hqlQuery, "Context_ID", careContext.getID_CareContext()));
	}
	//WDEV-20367
	private AdmissionDetail updateExtendedDetails(AdmissionDetailVo admissionDetailsVo, DomainFactory factory, InpatientEpisodeLiteVo inpatEpisode,CareContextRefVo voCareContext)
	{
		AdmissionDetail admissionDO = AdmissionDetailVoAssembler.extractAdmissionDetail(factory, admissionDetailsVo);
		PatientTransportRequirementsVo transportDetails = null;
		if (admissionDO.getTransportDetails() == null)
		{	 
			transportDetails = getPatientTransportRequirements(voCareContext);

			if (transportDetails != null)
			{
				if (inpatEpisode.getTransportDetailsIsNotNull())
				{
					transportDetails.setCareContext(inpatEpisode.getTransportDetails().getCareContext());
					transportDetails.setTransport(inpatEpisode.getTransportDetails().getTransport());
					transportDetails.setTransportRequired(inpatEpisode.getTransportDetails().getTransportRequired());
				}	
			}
			else
			{
				transportDetails = inpatEpisode.getTransportDetails();
			}
				
		 }
		else
		{
			transportDetails = admissionDetailsVo.getTransportDetails();
			if (inpatEpisode.getTransportDetailsIsNotNull())
			{
				transportDetails.setCareContext(inpatEpisode.getTransportDetails().getCareContext());
				transportDetails.setTransport(inpatEpisode.getTransportDetails().getTransport());
				transportDetails.setTransportRequired(inpatEpisode.getTransportDetails().getTransportRequired());
			}
		}
		admissionDO.setEstDischargeDate(inpatEpisode.getEstDischargeDateIsNotNull() ? inpatEpisode.getEstDischargeDate().getJavaDate() : null);
		admissionDO.setExtendedLengthOfStayReason(getDomLookup(inpatEpisode.getExtendedLengthOfStayReason()));
		admissionDO.setPatientRequiresTransport(inpatEpisode.getPatientRequiresTransport());
		admissionDO.setTransportDetails( transportDetails != null ? PatientTransportRequirementsVoAssembler.extractPatientTransportRequirements(factory,transportDetails) : null);
		
		admissionDO.setAbleToGoDischargeLounge(inpatEpisode.getAbleToGoDischargeLoungeIsNotNull() ? inpatEpisode.getAbleToGoDischargeLounge() : null);
		admissionDO.setReasonCannotGoDischargeLounge(getDomLookup(inpatEpisode.getReasonCannotGoDischargeLounge()));
		
		admissionDO.setReasonDelayedDischarge(inpatEpisode.getReasonDelayedDischargeIsNotNull() ? ReasonForDelayedDischargeVoAssembler.extractReasonForDelayedDischargeList(factory, inpatEpisode.getReasonDelayedDischarge()) : null);	
	
		admissionDO.setMedicallyFitForDischarge(inpatEpisode.getMedicallyFitForDischargeIsNotNull()  ? getDomLookup(inpatEpisode.getMedicallyFitForDischarge()) : null);
			
		return admissionDO;
	}

	public String[] getRtpStatAndPlBlk(ims.core.vo.PatientId intfId)
	{
		// This condition and return was inserted in WDEV-18604 - as temporary fix for a demo to remove all DTO calls by Rory Fitzpatrik
		// Not sure if this would need to be removed, but this function should return the values from Inpatient Episode not a null,
		// else a local context will not get initialized
		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()) || ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS"))
		{
			return null;
		}
		
		Inpat inpatRec = (Inpat) getDTOInstance(Inpat.class);
		inpatRec.Filter.clear();
		
		if (intfId == null)
		{
			throw new DomainRuntimeException("Patient Get call must contain valid interface identifier");
		}

		if (intfId.getType().equals(PatIdType.PKEY))
		{
			inpatRec.Filter.Pkey = intfId.getValue();
		}
		else if (intfId.getType().equals(PatIdType.HOSPNUM))
		{
			inpatRec.Filter.Hospnum = intfId.getValue();
		}
		else
		{
			throw new DomainRuntimeException("No valid Interface Patient Identifier supplied.");
		}

		Result result = inpatRec.get();
		if (result == null)
		{
			return new String[] {inpatRec.DataCollection.get(0).Rtpstat, inpatRec.DataCollection.get(0).Plbk};
		}
		
		return null;
	}

	public InpatientEpisodeLiteVoCollection listInpatientEpisodeByWard(LocationRefVo ward, PatientRefVo patient)
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		return impl.listInpatientEpisodeByWard(ward, patient);
	}

	public void saveInternalTransfer(InpatientEpisodeLiteVo inpatEpis, BedSpaceStateLiteVo bedSpaceState, AdmissionReasonVo admissionReasonVo) throws StaleObjectException
	{
		if (bedSpaceState == null)
			throw new CodingRuntimeException("bedSpaceState is null in method saveInternalTransfer");
		if (inpatEpis == null)
			throw new CodingRuntimeException("inpatEpis is null in method saveInternalTransfer");
		
		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState);
		
		BedSpaceState domBed = BedSpaceStateBayOnlyVoAssembler.extractBedSpaceState(getDomainFactory(), inpatEpis.getBed());
		
		domBed.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.AVAILABLE));
		domBed.setInpatientEpisode(null);
		getDomainFactory().save(domBed);
		
		InpatientEpisode doInpatEpis = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatEpis);
		
		doBedSpaceState.setInpatientEpisode(doInpatEpis);
		doBedSpaceState.getCurrentBedStatus().setBedStatus(getDomLookup(BedStatus.OCCUPIED));
		doInpatEpis.setBed(doBedSpaceState);
		
		// WDEV-19481 - Trigger creation of A08 Bed Move HL7 message
		if(inpatEpis.getPasEvent() !=null
				&& doBedSpaceState != null
				&& doBedSpaceState.getBedSpace() != null
				&& doBedSpaceState.getBedSpace().getBedNumber() != null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerUpdateAdmissionEvent(inpatEpis.getPasEvent(),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
		} //WDEV-19481
		
		//WDEV-20224
		if (admissionReasonVo != null && Boolean.TRUE.equals(admissionReasonVo.getIsPrivateBedAllocationValidated()) && Boolean.TRUE.equals(doBedSpaceState.getBedSpace().isPrivateBed()))
		{
			WardStay cws = getCurrentWardStay(doInpatEpis.getWardStays());
			
			if (cws != null)
			{
				cws.setReasonPrivateBedAllocated(admissionReasonVo.getReasonForPrivateBedAllocation() != null ? getDomLookup(admissionReasonVo.getReasonForPrivateBedAllocation()) : null);
				cws.setReasonPrivateBedAllocatedComment(admissionReasonVo.getReasonForPrivateBedAllocationComment());
			}
		}
		getDomainFactory().save(doInpatEpis);
		
		//WDEV-20217
		updateOccupiedBedsForWardAndBay(bedSpaceState.getWard(), bedSpaceState.getBay(), inpatEpis.getBed() != null ? inpatEpis.getBed().getBay() : null);
	}

	public InpatientEpisodeLiteVoCollection listInfantsForSelectedPatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient is null or id not provided in method countInfants");
		
		String hql = "select inpatEpis from InpatientEpisode as inpatEpis left join inpatEpis.pasEvent as pE where (pE.patient.id in (select pat.id from Patient as pat where (pat.clientParent.id = " + patient.getID_Patient() + ")))";
		List lstEpisodes = getDomainFactory().find(hql);
		if(lstEpisodes != null)
			return InpatientEpisodeLiteVoAssembler.createInpatientEpisodeLiteVoCollectionFromInpatientEpisode(lstEpisodes);
		
		return null;
	}

	public BedSpaceStateLiteVo getBedSpaceStateByInpatientEpisode(InpatientEpisodeRefVo inpat)
	{
		if (inpat == null || inpat.getID_InpatientEpisode() == null)
			throw new CodingRuntimeException("inpat is null or id not provided in method getBedSpaceStateByInpatientEpisode");
		
		String hql = "from BedSpaceState as bed where bed.inpatientEpisode.id = " + inpat.getID_InpatientEpisode();
		List lstBeds = getDomainFactory().find(hql);
		if(lstBeds != null && lstBeds.size() == 1)
			return BedSpaceStateLiteVoAssembler.create((BedSpaceState) lstBeds.get(0));
		
		return null;
	}
	
	public String getPasMappingFromConsultant(IMos mos)
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getPasMappingFromConsultant(mos);
	}

//	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
//	{
//		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
//		return impl.listSpecialtiesFromConSpc(consultantMapping);
//	}

	public PendingTransfersLiteVo getPendingTransferForInpatient(InpatientEpisodeRefVo inpatEpis)
	{
		if (inpatEpis == null || inpatEpis.getID_InpatientEpisode() == null)
			return null;

		List<?> transfers = getDomainFactory().find("from PendingTransfers pTrans WHERE pTrans.inpatientEpisode.id = " + inpatEpis.getID_InpatientEpisode() + " AND pTrans.currentStatus.id = " + TransferStatus.PENDING.getId());
		if(transfers != null && transfers.size() == 1)
			return PendingTransfersLiteVoAssembler.create((PendingTransfers) transfers.get(0));
			
		return null;
	}

	public AdmissionDetailVo getAdmissionDetailByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getAdmissionDetailByPasEvent");
		
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getAdmissionDetailByPasEvent(pasEvent);
	}

	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.listSpecialtiesFromConSpc(consultantMapping);
	}

	public Specialty getCCOSpecialtyMappingFromPASSpecialty(PASSpecialty pasSpecialty)
	{
		if (pasSpecialty == null)
			return null;
		
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		String szMapping = null;
		for (int i = 0 ; i < pasSpecialty.getMappings().size() ; i++)
		{
			if (pasSpecialty.getMappings().get(i).getExtSystem().equals("PAS"))
				szMapping = pasSpecialty.getMappings().get(i).getExtCode();
		}
		if (szMapping != null)
			return impl.getSpecialtyMappingFromPASSpecialty(szMapping);
		else
			return null;
	}

	public PASSpecialtyCollection listCCOSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.listCCOSpecialtiesFromConSpc(consultantMapping);
	}

	public Specialty getSpecialtyMappingFromPASSpecialty(String szMapping) 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getSpecialtyMappingFromPASSpecialty(szMapping);
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(String szMapping) 
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.getPASSpecialtyMappingFromSpecialty(szMapping);
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(Specialty specialty) {
		// TODO Auto-generated method stub
		return null;
	}

	public CareContextShortVo saveHomeLeave(BedSpaceStateLiteVo voBedSpaceStateLite, InPatientEpisodeADTVo inpatientEpisode, HomeLeaveVo homeLeaveVo) throws DomainInterfaceException, StaleObjectException 
	{
		if(inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method saveTransfer");
		if(!inpatientEpisode.isValidated())
			throw new CodingRuntimeException("inpatientEpisode has not been validated in method saveTransfer");
		
		if(homeLeaveVo == null)
			throw new CodingRuntimeException("homeLeaveVo is null in method saveHomeLeave");
	
		DomainFactory factory = getDomainFactory();
		
		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")) //WDEV-20326
		{
			Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
			hlRec.DataCollection.add();
			
			copyHomeleaveToDto(hlRec, homeLeaveVo, inpatientEpisode);
			
			//Update Home Leave on PAS 
			Result res = hlRec.insert();
			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
			}
		}		
		//Save MAXIMS HomeLeave
		HomeLeave doHL = HomeLeaveVoAssembler.extractHomeLeave(factory, homeLeaveVo);
		
		if (homeLeaveVo.getID_HomeLeave() != null)
		{	
			HomeLeave savedHomeLeave = (HomeLeave) factory.getDomainObject(HomeLeave.class, homeLeaveVo.getID_HomeLeave());
			if (savedHomeLeave == null || Boolean.TRUE.equals(savedHomeLeave.getIsRIE()) ||  savedHomeLeave.getVersion() > homeLeaveVo.getVersion_HomeLeave())
			{
				if (savedHomeLeave == null || Boolean.TRUE.equals(savedHomeLeave.getIsRIE())) 
					throw new DomainInterfaceException("The Home Leave record has been cancelled by another user. The screen will be refreshed.");
				if (savedHomeLeave.getVersion() > homeLeaveVo.getVersion_HomeLeave())
					throw new DomainInterfaceException("The Home Leave record has been modified by another user. The screen will be refreshed.");
			}		
		}		
				
		//Save IP details
		InpatientEpisode doInpatEpis = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		if (homeLeaveVo.getID_HomeLeave() == null)
		{	
			if (doInpatEpis.getHomeLeaves() == null)
				doInpatEpis.setHomeLeaves(new java.util.ArrayList());
			doInpatEpis.getHomeLeaves().add(doHL);

			doInpatEpis.setIsOnHomeLeave(true);
			doInpatEpis.setVacatedBedNumber(homeLeaveVo.getVacatedBedNumberIsNotNull() ? homeLeaveVo.getVacatedBedNumber() : "");
			if (!Boolean.TRUE.equals(homeLeaveVo.getBedRetained()))
			{	
				doInpatEpis.setBedNo(null);
			}	
		}
		if (homeLeaveVo.getID_HomeLeave() != null)
		{
			doInpatEpis.getHomeLeaves().set(doInpatEpis.getHomeLeaves().indexOf(doHL), doHL);
		}
		doInpatEpis.setDateOnHomeLeave(homeLeaveVo.getDateOnHomeLeaveIsNotNull() ? homeLeaveVo.getDateOnHomeLeave().getDate() : null);
		doInpatEpis.setTimeOnHomeLeave(homeLeaveVo.getTimeOnHomeLeaveIsNotNull() ? homeLeaveVo.getTimeOnHomeLeave().toString() : null);
		doInpatEpis.setExpectedDateOfReturn(homeLeaveVo.getExpectedDateOfReturnIsNotNull() ? homeLeaveVo.getExpectedDateOfReturn().getDate() : null);
		doInpatEpis.setExpectedTimeOfReturn(homeLeaveVo.getExpectedTimeOfReturnIsNotNull() ? homeLeaveVo.getExpectedTimeOfReturn().toString() : null);
				
		//WDEV-20405 - Trigger creation of A21 PATIENT GOES ON A LEAVE OF ABSENCE HL7 message
		//		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpat);
		//		if(inpatEpisodeVo.getPasEvent() != null)
		if(inpatientEpisode.getPasEvent() != null && homeLeaveVo.getID_HomeLeave() == null)
		{
			ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			//			adtimpl.triggerTransferEvent(inpatEpisodeVo.getPasEvent());
			adtimpl.triggerLeaveOfAbsenceEvent(inpatientEpisode.getPasEvent());
		} //WDEV-20405

		factory.save(doInpatEpis);

		//Vacate the bed.
		if (homeLeaveVo.getID_HomeLeave() == null)
		{	
			if(voBedSpaceStateLite != null && !Boolean.TRUE.equals(homeLeaveVo.getBedRetained()))
			{
				BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpaceStateLite);
				factory.save(doBed);
			}
			if (voBedSpaceStateLite != null && !Boolean.TRUE.equals(homeLeaveVo.getBedRetained()))
				updateOccupiedBedsForWardAndBay(voBedSpaceStateLite.getWard(), voBedSpaceStateLite.getBay(), null);

			if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS") && voBedSpaceStateLite != null && !Boolean.TRUE.equals(homeLeaveVo.getBedRetained()))
			{
				Sex tempGender = inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getPatientIsNotNull() && inpatientEpisode.getPasEvent().getPatient().getSexIsNotNull() && !Sex.UNKNOWN.equals(inpatientEpisode.getPasEvent().getPatient().getSex())  ? inpatientEpisode.getPasEvent().getPatient().getSex() : null;
				checkAndUpdateBayConfig(factory, voBedSpaceStateLite,tempGender);
			}
		}
		return null;
	}

	private String getPatientIdValue(AdmissionDetail doAdmissionDetail, PatIdType type) 
	{
		if(doAdmissionDetail == null)
			return null;
		
		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getPatient() != null && doAdmissionDetail.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}
		
		return null;
	}

	private void copyHomeLeaveToDto(Homeleave homeLeaveRec, AdmissionDetail doAdmissionDetail, HomeLeaveVo voHomeLeave) 
	{		
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);
	 	
		hlRec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";

		hlRec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());
		if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
		{
			if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
				hlRec.Btyp = "M";
			else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
				hlRec.Btyp = "F";
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";
		}
		else
			//defaulting Male for unknown sex
			hlRec.Btyp = "M";	

		hlRec.Returndt = voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateReturnedFromHomeLeave().getDate()) : "";
		hlRec.Returntm = voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString(TimeFormat.FLAT4) : "";
		
//		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
//			hlRec.Cflup = rec.Rescode;
		
		if (voHomeLeave.getID_HomeLeaveIsNotNull())
			hlRec.Hlfl = "N"; //"N" on an update
		else
			hlRec.Hlfl = "Y"; //"Y" on an insert
		
		hlRec.Webadt = "Y";				
	}

	private void copyHomeleaveToDto(Homeleave homeLeaveRec, HomeLeaveVo voHomeLeave, InPatientEpisodeADTVo inpatientEpisode)
	{
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);
	 	
		hlRec.Pkey = getPatientIdValue(inpatientEpisode, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(inpatientEpisode, PatIdType.HOSPNUM);

		InpatientEpisode doInpat = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		hlRec.Rescode = doInpat.getPasEvent() != null && doInpat.getPasEvent().getLocation() != null ? doInpat.getPasEvent().getLocation().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doInpat.getWardType());

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";
		if(hlRec.Mors.equals("M"))
		{
			if(doInpat.getPasEvent().getPatient().getSex() != null)
			{
				if(doInpat.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
					hlRec.Btyp = "M";
				else if(doInpat.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
					hlRec.Btyp = "F";
				else
					//defaulting Male for unknown sex
					hlRec.Btyp = "M";
			}
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";	
		}
		else if(hlRec.Mors.equals("S"))
			hlRec.Btyp = "S";
	

		hlRec.Hlfl = "Y"; //"Y" on an insert
		
		hlRec.Webadt = "Y";				
	}

	private String getPatientIdValue(InPatientEpisodeADTVo inpatientEpisode, PatIdType type) 
	{
		if(inpatientEpisode == null)
			return null;
		
		if(inpatientEpisode.getPasEvent() != null && inpatientEpisode.getPasEvent().getPatient() != null && inpatientEpisode.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = inpatientEpisode.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				ims.core.vo.PatientId patId = (ims.core.vo.PatientId) it.next();
				if(patId.getType().getId() == getDomLookup(type).getId())
					return patId.getValue();
			}
		}
		
		return null;
	}

	//wdev-14858 //WDEV-22218
	public IVTERiskAssessment getVTEForInpatient(InpatientEpisodeRefVo inpatEpRef) 
	{
		if (inpatEpRef == null)
			return null;
		WardDataView impl = (WardDataView) getDomainImpl(WardDataViewImpl.class);
		return impl.getInpatientEpisodeForVTE(inpatEpRef);
	}

	//wdev-14858
	public InpatientEpisodeForVTERiskAsessmentVo getInpatEpisodeForVTERiskAssessment( InpatientEpisodeRefVo inpatEpRef) 
	{
		if(	inpatEpRef == null )
			return null;
		
		DomainFactory factory = getDomainFactory();
		InpatientEpisode doInpatientEpisode  =(InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, inpatEpRef.getID_InpatientEpisode());
		return InpatientEpisodeForVTERiskAsessmentVoAssembler.create(doInpatientEpisode);
	}

	//wdev-14858
	public VTERiskAssessmentShortVo getVTERiskAssessmentShortVoBYId( VTERiskAssessmentRefVo vTERef) 
	{

		if(vTERef == null || vTERef.getID_VTERiskAssessment() == null) //wdev-14944
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		VTERiskAssessment doVTERiskAssessment  =(VTERiskAssessment) factory.getDomainObject(VTERiskAssessment.class, vTERef.getID_VTERiskAssessment());
		return VTERiskAssessmentShortVoAssembler.create(doVTERiskAssessment);
		
	}
	//wdev-15042
	public InpatientEpisodeLiteVo getInpatientEpisodeLiteVoById(InpatientEpisodeRefVo inpatEpRef) 
	{
		if (inpatEpRef == null || inpatEpRef.getID_InpatientEpisode() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		InpatientEpisode doInpatientEpisode = (InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, inpatEpRef.getID_InpatientEpisode());
				
		return InpatientEpisodeLiteVoAssembler.create(doInpatientEpisode);
	}

	//WDEV-15043
	public String getPIDDiagnosisInfo(CareContextRefVo careContextRefV, EpisodeOfCareRefVo episodeRefVo)
	{
		Alerts impl = (Alerts) getDomainImpl(AlertsImpl.class);
		return impl.getPIDDiagnosisInfo(careContextRefV, episodeRefVo);
	}

	//WDEV-15990
	public VTERiskAssessmentShortVoCollection getVTEByCareContext(CareContextRefVo careContextRef)
	{
		if (careContextRef == null)
			throw new CodingRuntimeException("Cannot get VTEs on null careContextRef");

		DomainFactory factory = getDomainFactory();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String query = "SELECT vte FROM VTERiskAssessment AS vte LEFT JOIN vte.careContext AS cc WHERE cc.id = :ID_CC";
		
		paramNames.add("ID_CC");
		paramValues.add(careContextRef.getID_CareContext());
		
		return VTERiskAssessmentShortVoAssembler.createVTERiskAssessmentShortVoCollectionFromVTERiskAssessment(factory.find(query.toString(), paramNames, paramValues));
	}

	public DischargedEpisodeADTVo getDischargedEpisodeADT(PASEventRefVo pasEventRef)
	{
		if (pasEventRef == null)
			throw new CodingRuntimeException("Cannot get DischargeEpisode on null PASEventRef");

		DomainFactory factory = getDomainFactory();
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String query = "SELECT dis FROM DischargedEpisode AS dis LEFT JOIN dis.pasEvent AS pasev WHERE pasev.id = :ID_PASEV";
		
		paramNames.add("ID_PASEV");
		paramValues.add(pasEventRef.getID_PASEvent());
		
		DischargedEpisodeADTVoCollection dischargeEpisode = DischargedEpisodeADTVoAssembler.createDischargedEpisodeADTVoCollectionFromDischargedEpisode(factory.find(query.toString(), paramNames, paramValues));
		
		if (dischargeEpisode != null && dischargeEpisode.size() > 0)
		{
			if (dischargeEpisode.get(0) != null && dischargeEpisode.get(0).getDeferredReasonIsNotNull())
			{	
				dischargeEpisode.get(0).setDeferredReasonConfig(getDeferredReason(dischargeEpisode.get(0).getDeferredReason()));
			}
			return dischargeEpisode.get(0);
		}
		
		return null;
	}

	//WDEV-16030
	public BedSpaceStateLiteVo getBedSpaceStateStatusByBedId(BedSpaceStateRefVo bedSpaceRef)
	{
		if(bedSpaceRef == null || bedSpaceRef.getID_BedSpaceState() == null)
			throw new CodingRuntimeException("Cannot get BedSpaceState on null Id.");
		
		return BedSpaceStateLiteVoAssembler.create(	(BedSpaceState)		getDomainFactory().getDomainObject(BedSpaceState.class, bedSpaceRef.getID_BedSpaceState()));
	}

	//wdev-15414
	public DischargedEpisodeForVTERiskAssessmentWorklistVo getDischargedEpisodeForVTERiskAssessmentWorklistVo(DischargedEpisodeRefVo dischargeepisodeRef)
	{
		if( dischargeepisodeRef == null)
			throw new CodingRuntimeException("DischargeEpisode cannot be null");
		
		DomainFactory factory = getDomainFactory();
		DischargedEpisode doDischargedEpisode = (DischargedEpisode) factory.getDomainObject(DischargedEpisode.class, dischargeepisodeRef.getID_DischargedEpisode());
				
		return DischargedEpisodeForVTERiskAssessmentWorklistVoAssembler.create(doDischargedEpisode);
	}

	public LocationLiteVo getCurrentHospital(ILocation currentLocation) // 	WDEV-18012
	{
		if(currentLocation == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, currentLocation.getID()));
		
		if(currentHospital instanceof Location)
			return LocationLiteVoAssembler.create((Location) currentHospital);
		
		return null;
	}
	
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public Boolean hasCancelledElectiveListsToRemove(PatientRefVo patient, PatientElectiveListRefVo electiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (service == null || service.getID_Service() == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVo getPatientElectiveListForDischarge(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			return null;
		
		// WDEV-18617  - For some reason only one pasevent being created so have to get the most recent
		StringBuilder query = new StringBuilder("SELECT adm from AdmissionDetail adm LEFT JOIN adm.pasEvent AS pas ");
		
		//StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.referral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas ");
		query.append(" WHERE pas.id = :PAS_ID");
		query.append(" order by adm.admissionDateTime desc ");
		
		ArrayList<String> paramNames = new ArrayList<String>();		
		ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PAS_ID");														
		paramValues.add(pasEvent.getID_PASEvent());
		
		AdmissionDetail domAdmission = (AdmissionDetail) getDomainFactory().findFirst(query.toString(), paramNames, paramValues);
		
		if (domAdmission == null) //WDEV-19872
			return null;
		
		// WDEV-18617  - Get the ELE for this pas event - not the first one for the Referral!!!
		query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.admissionDetail AS adm ");
		query.append(" LEFT JOIN pel.admissions AS admission ");
		
		//StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.referral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas ");
		query.append(" WHERE adm.id = :ADM_ID OR admission.id = :ADM_ID ");
		
		
		paramNames = new ArrayList<String>();
		paramValues = new ArrayList<Object>();
		paramNames.add("ADM_ID");				
		paramValues.add(domAdmission.getId());
		
		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}

	public PatientElectiveListBedAdmissionVoCollection getCancelledElectiveListsToRemove(PatientRefVo patient, PatientElectiveListRefVo electiveList, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		if (service == null || service.getID_Service() == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS pat LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");
		
		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveList.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	//WDEV-18454
	public Boolean hasElectiveListsToRemove(PatientRefVo patientRef, PatientElectiveListRefVo electiveListRef, Specialty specialty)
	{
		if (patientRef == null || patientRef.getID_Patient() == null)
			return Boolean.FALSE;
		
		if (specialty == null)
			return Boolean.FALSE;
		
		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN service.specialty AS specialty LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus");
		query.append(" WHERE patient.id = :PAT_ID AND specialty.id = :SPECIALTY_ID AND eleListStatus.id <> :STATUS_ID ");
		
		if (electiveListRef != null)
			query.append(" AND pel.id <> :PEL_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();
																
		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("SPECIALTY_ID");		
		paramValues.add(specialty.getID());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());
		
		if (electiveListRef != null)
		{
			paramNames.add("PEL_ID");
			paramValues.add(electiveListRef.getID_PatientElectiveList());
		}
		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));
		
		if (count > 0)
			return Boolean.TRUE;
		
		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVoCollection getElectiveListsToRemove(PatientRefVo patientRef, PatientElectiveListRefVo electiveListRef, Specialty specialty)
	{
		if (patientRef == null || patientRef.getID_Patient() == null)
			return null;
		
		if (specialty == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN service.specialty AS specialty LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus");
		query.append(" WHERE patient.id = :PAT_ID AND specialty.id = :SPECIALTY_ID AND eleListStatus.id <> :STATUS_ID ");
		
		if (electiveListRef != null)
			query.append(" AND pel.id <> :PEL_ID ");
		
		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();
																
		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("SPECIALTY_ID");		
		paramValues.add(specialty.getID());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());
		
		if (electiveListRef != null)
		{
			paramNames.add("PEL_ID");
			paramValues.add(electiveListRef.getID_PatientElectiveList());
		}
		
		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(factory.find(query.toString(), paramNames, paramValues));
	}

	public PatientShortCollection getPatientsForCurrentBay(LocationRefVo currentBay)
	{
		StringBuilder query = new StringBuilder();
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
 
		query.append("SELECT patients FROM InpatientEpisode AS inpEp LEFT JOIN inpEp.pasEvent AS pasEv ");
		query.append("LEFT JOIN pasEv.patient AS patients ");
		query.append("LEFT JOIN inpEp.bed AS bed ");
		query.append("LEFT JOIN bed.bay AS patientBay ");
		
		query.append("WHERE patientBay.id = :bay ");
		paramNames.add("bay");
		paramValues.add(currentBay.getID_Location());
		
		return PatientShortAssembler.createPatientShortCollectionFromPatient(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public void swapBeds(BedSpaceStateLiteVo bedStateSource, InpatientEpisodeLiteVo inpatientEpisodeDestination, AdmissionReasonVo admissionReasonVo) throws StaleObjectException
	{
		DomainFactory factory = getDomainFactory();
		
		InpatientEpisodeLiteVo inpatientEpisodeSource = bedStateSource.getInpatientEpisode();
		
		BedSpaceStateLiteVo bedStateDestination = getBedSpaceStateStatusByBedId(inpatientEpisodeDestination.getBed());
						
		BedSpaceState doBedStateDestination = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, bedStateDestination);
		//WDEV-20224
		InpatientEpisode doInpatEpisSource = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(factory, inpatientEpisodeSource);
		if (admissionReasonVo != null && Boolean.TRUE.equals(admissionReasonVo.getIsPrivateBedAllocationValidated()))
		{
			if (Boolean.TRUE.equals(doBedStateDestination.getBedSpace().isPrivateBed()))
			{
				WardStay cws = getCurrentWardStay(doInpatEpisSource.getWardStays());
				if (cws != null)
				{
					cws.setReasonPrivateBedAllocated(admissionReasonVo.getReasonForPrivateBedAllocation() != null ? getDomLookup(admissionReasonVo.getReasonForPrivateBedAllocation()) : null);
					cws.setReasonPrivateBedAllocatedComment(admissionReasonVo.getReasonForPrivateBedAllocationComment());
				}
			}			
		}
		doBedStateDestination.setInpatientEpisode(doInpatEpisSource);
		
		// WDEV-19481 - Trigger creation of A08 HL7 message (only if an actual bed number exists!)
		if(inpatientEpisodeDestination.getPasEvent() !=null
				&& doBedStateDestination.getBedSpace() != null
				&& doBedStateDestination.getBedSpace().getBedNumber() != null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerUpdateAdmissionEvent(inpatientEpisodeDestination.getPasEvent(),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
		} //WDEV-19481
		
		factory.save(doBedStateDestination);
		
		BedSpaceState doBedStateSource = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, bedStateSource);
		InpatientEpisode doInpatEpisDest = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(factory, inpatientEpisodeDestination);
				
		if (admissionReasonVo != null && Boolean.TRUE.equals(admissionReasonVo.getIsPrivateBedAllocationValidated()))
		{
			if (Boolean.TRUE.equals(doBedStateSource.getBedSpace().isPrivateBed()))
			{
				WardStay cws = getCurrentWardStay(doInpatEpisDest.getWardStays());

				if (cws != null)
				{
					cws.setReasonPrivateBedAllocated(admissionReasonVo.getReasonForPrivateBedAllocation() != null ? getDomLookup(admissionReasonVo.getReasonForPrivateBedAllocation()) : null);
					cws.setReasonPrivateBedAllocatedComment(admissionReasonVo.getReasonForPrivateBedAllocationComment());
				}
			}

		}
		doBedStateSource.setInpatientEpisode(doInpatEpisDest);
		// WDEV-19481 - Trigger creation of A08 HL7 message (only if an actual bed number exists!)
		if(inpatientEpisodeSource.getPasEvent() !=null
				&& doBedStateSource.getBedSpace() != null
				&& doBedStateSource.getBedSpace().getBedNumber() != null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerUpdateAdmissionEvent(inpatientEpisodeSource.getPasEvent(),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
		} //WDEV-19481
		
		factory.save(doBedStateSource);
	}

	//WDEV-20023
	public PatientCaseNoteVoCollection getCaseNoteFolders(PatientRefVo patientRef, LocationRefVo locationRef)
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.getCaseNoteFolders(patientRef, locationRef);
	}

	public void updateOccupiedBedsForWardAndBay(LocationRefVo ward, LocationRefVo bayOne, LocationRefVo bayTwo) throws StaleObjectException
	{
		WardView implWardView = (WardView) getDomainImpl(WardViewImpl.class);
		implWardView.updateOccupiedBedsForWardAndBay(ward, bayOne, bayTwo);
		
	}
	//WDEV-20328
	public WardConfigLiteVo getWardConfig(LocationRefVo locRefVo)
	{
		if (locRefVo == null || locRefVo.getID_Location() == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		List<?> lstWbc = factory.find("from WardBayConfig wbc where wbc.ward.id = '" + locRefVo.getID_Location() + "'");
		if(lstWbc != null && lstWbc.size() == 1)
			return WardConfigLiteVoAssembler.create((WardBayConfig) lstWbc.get(0));
		
		return null;
	}

	public BedSpaceStateLiteVo getBedSpaceState(BedSpaceStateRefVo bedSpaceState)
	{
		if (bedSpaceState == null || bedSpaceState.getID_BedSpaceState() == null)
			return null;
		
		return BedSpaceStateLiteVoAssembler.create((BedSpaceState) getDomainFactory().getDomainObject(BedSpaceState.class, bedSpaceState.getID_BedSpaceState()));
	}

	
	public void returnFromHomeLeave(BedSpaceStateLiteVo voBedSpaceStateLite, InpatientEpisodeLiteVo voInpatEpis, HomeLeaveVo voHl,	AdmissionReasonVo admissionReasonVo) throws DomainInterfaceException, StaleObjectException 
	{
		DomainFactory factory = getDomainFactory();
		
		BedSpaceState savedBedSpaceStateDO = (BedSpaceState) factory.getDomainObject(BedSpaceState.class, voBedSpaceStateLite.getID_BedSpaceState());
		
		if (savedBedSpaceStateDO != null && (savedBedSpaceStateDO.getInpatientEpisode() == null ||  savedBedSpaceStateDO.getInpatientEpisode().getVersion() > voInpatEpis.getVersion_InpatientEpisode()))
		{
			if (savedBedSpaceStateDO.getInpatientEpisode() == null)
				throw new DomainInterfaceException(" This patient has been discharged or moved by another user. The screen will be refreshed.");
			if (savedBedSpaceStateDO.getInpatientEpisode().getVersion() > voInpatEpis.getVersion_InpatientEpisode() && !Boolean.TRUE.equals(savedBedSpaceStateDO.getInpatientEpisode().isIsOnHomeLeave()))
				throw new DomainInterfaceException(" The home leave for this patient has been processed by another user. The screen will be refreshed.");
		}		
		InpatientEpisode doInpatEpis = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), voInpatEpis);
		if(voHl != null)
		{
			doInpatEpis = closeCurrentHomeLeaveAndUpdateEpisode(doInpatEpis, voHl);
			doInpatEpis.setIsOnHomeLeave(false);
			doInpatEpis.setDateOnHomeLeave(null);
			doInpatEpis.setTimeOnHomeLeave(null);
			doInpatEpis.setExpectedDateOfReturn(null);
			doInpatEpis.setExpectedTimeOfReturn(null);
			doInpatEpis.setVacatedBedNumber(null);			
		}
		
		savedBedSpaceStateDO.setInpatientEpisode(doInpatEpis);
		
		//WDEV-20405 - Trigger creation of A21 PATIENT GOES ON A LEAVE OF ABSENCE HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpatEpis);
		if(inpatEpisodeVo != null
				&& inpatEpisodeVo.getPasEvent() != null)
		{
	    	ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
			adtimpl.triggerReturnFromLeaveOfAbsenceEvent(inpatEpisodeVo.getPasEvent());
		} //WDEV-20405

		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS") && voBedSpaceStateLite != null && !Boolean.TRUE.equals(voHl.getBedRetained()))
		{
			Sex tempGender = voInpatEpis.getPasEvent() != null && voInpatEpis.getPasEvent().getPatientIsNotNull() ? voInpatEpis.getPasEvent().getPatient().getSex() : null;
			checkAndUpdateBayConfig(factory, voBedSpaceStateLite, tempGender);
		}		
		factory.save(savedBedSpaceStateDO);		
		
	}

	private InpatientEpisode closeCurrentHomeLeaveAndUpdateEpisode(InpatientEpisode doInpatEpis, HomeLeaveVo voHl)
	{
		HomeLeave currentHomeLeaveDO = null;
		if (doInpatEpis == null || !Boolean.TRUE.equals(doInpatEpis.isIsOnHomeLeave()) ||  doInpatEpis.getHomeLeaves() == null)
			return null;
		
		for(int i = 0 ; doInpatEpis.getHomeLeaves().size() > 0 && i < doInpatEpis.getHomeLeaves().size() ; i++)
		{
			HomeLeave doHL = (HomeLeave)doInpatEpis.getHomeLeaves().get(i);
			 if (doHL != null && doHL.getDateReturnedFromHomeLeave() == null && doHL.getDateOnHomeLeave().equals(doInpatEpis.getDateOnHomeLeave()))
			 {
				 currentHomeLeaveDO = doHL;
				 break;
			 }			 
		}

		if (currentHomeLeaveDO != null)
		{	
			currentHomeLeaveDO.setDateReturnedFromHomeLeave(voHl.getDateReturnedFromHomeLeaveIsNotNull() ? voHl.getDateReturnedFromHomeLeave().getDate() : null);
			currentHomeLeaveDO.setTimeReturnedFromHomeLeave(voHl.getTimeReturnedFromHomeLeaveIsNotNull() ? voHl.getTimeReturnedFromHomeLeave().toString() : null);

			doInpatEpis.getHomeLeaves().set(doInpatEpis.getHomeLeaves().indexOf(currentHomeLeaveDO), currentHomeLeaveDO);	 
		} 
		
		return doInpatEpis;
	}
	//WDEV-21282 only list Provider cancellations, not marked as only outpatient
	public CancellationTypeReasonVoCollection listCancellationTypeReason()
	{
		String query = "SELECT reasonConfig FROM CancellationTypeReason AS reasonConfig left join reasonConfig.cancellationType as ctype where ctype.id = :PROVIDER_CANCELLATION and (reasonConfig.tCITheatre = 1  OR reasonConfig.outpatients  <> 1)";
		
		return CancellationTypeReasonVoAssembler.createCancellationTypeReasonVoCollectionFromCancellationTypeReason(getDomainFactory().find(query,new String[]{"PROVIDER_CANCELLATION"},new Object[] {Status_Reason.HOSPITALCANCELLED.getID()}));
	}
	//WDEV-20669 -- start
	public void cancelHomeLeave(BedSpaceStateLiteVo voBedSpaceState,InpatientEpisodeLiteVo voInpat)	throws StaleObjectException, DomainInterfaceException
	{
		if (voInpat == null)
			throw new CodingRuntimeException("InpatientEpisodeLiteVo argument cannot be null in method cancelHomeLeave()");
		DomainFactory factory = getDomainFactory();
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		CareContextShortVo voCareContext = impl.getCareContextForPasEvent(voInpat.getPasEvent());
		InPatientEpisodeADTVo voInpatADTVo = getInpatientEpisode(voInpat);
		if (voInpatADTVo == null)
			throw new DomainInterfaceException("This patient is no longer an inpatient. The screen will be refreshed.");
		if (voInpatADTVo != null && voInpatADTVo.getVersion_InpatientEpisode() > voInpat.getVersion_InpatientEpisode() &&  !Boolean.TRUE.equals(voInpatADTVo.getIsOnHomeLeave()))
			throw new DomainInterfaceException("This inpatient is no longer on home leave. The screen will be refreshed.");
		
		HomeLeaveVo homeLeaveToCancel = getLatestOngoingHomeLeave(voInpatADTVo);
					
		if (homeLeaveToCancel != null)
		{
			factory.markAsRie(HomeLeave.class, homeLeaveToCancel.getID_HomeLeave(), null, voInpat.getPasEvent() != null && voInpat.getPasEvent().getPatientIsNotNull() ?  voInpat.getPasEvent().getPatient().getID_Patient() : null, null, voCareContext != null ? voCareContext.getID_CareContext() : null, "Cancellation of Sending on Home Leave");
			
			InpatientEpisode doInpatientEpisode = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(factory, voInpatADTVo);
			
			doInpatientEpisode.setIsOnHomeLeave(false);
			doInpatientEpisode.setDateOnHomeLeave(null);
			doInpatientEpisode.setTimeOnHomeLeave(null);
			doInpatientEpisode.setExpectedDateOfReturn(null);
			doInpatientEpisode.setExpectedTimeOfReturn(null);
			
			if (doInpatientEpisode.getPasEvent() != null)
			{
				ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
				adtimpl.triggerCancelLeaveOfAbsenceEvent(new PASEventRefVo(doInpatientEpisode.getPasEvent().getId(), doInpatientEpisode.getPasEvent().getVersion()));
			}
			factory.save(doInpatientEpisode);
			if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS") && voBedSpaceState != null && !Boolean.TRUE.equals(homeLeaveToCancel.getBedRetained()))
			{
				Sex tempGender = voInpat.getPasEvent() != null && voInpat.getPasEvent().getPatientIsNotNull() ? voInpat.getPasEvent().getPatient().getSex() : null;
				checkAndUpdateBayConfig(factory, voBedSpaceState,tempGender);
			}
		}
		
	}
	private HomeLeaveVo getLatestOngoingHomeLeave(InPatientEpisodeADTVo voEpisode)
	{
		if (voEpisode == null || voEpisode.getHomeLeaves() == null)
			return null;
		for (int i=voEpisode.getHomeLeaves().size()-1;i>=0;i--)
		{
			if (voEpisode.getHomeLeaves().get(i).getDateReturnedFromHomeLeave() != null)
				voEpisode.getHomeLeaves().remove(i);
		}
		voEpisode.getHomeLeaves().sort(HomeLeaveVo.getDateOnHomeLeaveComparator(SortOrder.DESCENDING));
		if (voEpisode.getHomeLeaves().size() > 0 && voEpisode.getHomeLeaves().get(0) != null)
				return voEpisode.getHomeLeaves().get(0);
		return null;
	}

	public Boolean hasPatientReturnedFromHomeLeave(InpatientEpisodeLiteVo voInpat)
	{
		if (voInpat == null || Boolean.TRUE.equals(voInpat.getIsOnHomeLeave()))
			return false;
		
		String hql = " select count(hl.id) from InpatientEpisode inp left join inp.homeLeaves as hl WHERE hl.dateReturnedFromHomeLeave is not null AND (hl.isRIE is null OR hl.isRIE = 0) and inp.id = :INPAT_ID";
		
		DomainFactory fact = getDomainFactory();
		
		long count = fact.countWithHQL(hql, new String[]{"INPAT_ID"}, new Object[]{voInpat.getID_InpatientEpisode()});
		
		return count > 0;		
	}
	
	public void cancelHomeLeaveReturn(InpatientEpisodeLiteVo voInpat,BedSpaceStateLiteVo voBedSpaceState, HomeLeaveVo voHlToReOpen) throws DomainInterfaceException,StaleObjectException
	{
		if (voInpat == null)
			throw new CodingRuntimeException("The InpatientEpisodeLiteVo argument cannot be null in method cancelHomeLeaveReturn()");
		if (voHlToReOpen == null)
			throw new CodingRuntimeException("The HomeLeaveVo argument cannot be null in method cancelHomeLeaveReturn()");
		if (!voHlToReOpen.isValidated())
			throw new CodingRuntimeException("The HomeLeaveVo is not validated in method cancelHomeLeaveReturn()");
		DomainFactory factory = getDomainFactory();

		InpatientEpisode inpatEpisodeDO = (InpatientEpisode) factory.getDomainObject(InpatientEpisode.class, voInpat.getID_InpatientEpisode());
		
		if (inpatEpisodeDO == null)
			throw new DomainInterfaceException("This patient is no longer an inpatient. The screen will be refreshed.");
		if (inpatEpisodeDO != null && inpatEpisodeDO.getVersion() > voInpat.getVersion_InpatientEpisode() &&  Boolean.TRUE.equals(inpatEpisodeDO.isIsOnHomeLeave()))
			throw new DomainInterfaceException("This inpatient has been sent on home leave or their home leave return was cancelled by another user. The screen will be refreshed.");
		
		if (inpatEpisodeDO.getHomeLeaves() != null && !inpatEpisodeDO.getHomeLeaves().isEmpty())
		{	
			HomeLeave homeLeaveDO = HomeLeaveVoAssembler.extractHomeLeave(factory, voHlToReOpen);
			
			if (homeLeaveDO != null)
			{
				if (inpatEpisodeDO.getHomeLeaves().contains(homeLeaveDO))
					inpatEpisodeDO.getHomeLeaves().set(inpatEpisodeDO.getHomeLeaves().indexOf(homeLeaveDO), homeLeaveDO);
				
				inpatEpisodeDO.setIsOnHomeLeave(true);
				inpatEpisodeDO.setDateOnHomeLeave(homeLeaveDO.getDateOnHomeLeave() != null ? homeLeaveDO.getDateOnHomeLeave() : null);
				inpatEpisodeDO.setTimeOnHomeLeave(homeLeaveDO.getTimeOnHomeLeave() != null ? homeLeaveDO.getTimeOnHomeLeave() : null);
				inpatEpisodeDO.setExpectedDateOfReturn(homeLeaveDO.getExpectedDateOfReturn() != null ? homeLeaveDO.getExpectedDateOfReturn() : null);
				inpatEpisodeDO.setExpectedTimeOfReturn(homeLeaveDO.getExpectedTimeOfReturn() != null ? homeLeaveDO.getExpectedTimeOfReturn()  : null);
				inpatEpisodeDO.setVacatedBedNumber(homeLeaveDO.getVacatedBedNumber() != null ? homeLeaveDO.getVacatedBedNumber() : null);

				if (voBedSpaceState != null && !Boolean.TRUE.equals(homeLeaveDO.isBedRetained()))
				{
					if (voBedSpaceState.getCurrentBedStatusIsNotNull())
					{
						voBedSpaceState.setPreviousBedStatus((BedSpaceStateStatusLiteVo) voBedSpaceState.getCurrentBedStatus().clone());
						voBedSpaceState.setCurrentBedStatus(new BedSpaceStateStatusLiteVo());
						voBedSpaceState.getCurrentBedStatus().setStatusDateTime(new DateTime());
						voBedSpaceState.getCurrentBedStatus().setBedStatus(BedStatus.AVAILABLE);						
					}
								
					voBedSpaceState.setInpatientEpisode(null);
					
					inpatEpisodeDO.setBed(null);
				}
			}
			if (inpatEpisodeDO.getPasEvent() != null)
			{
				ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
				adtimpl.triggerCancelReturnFromLeaveOfAbsenceEvent(new PASEventRefVo(inpatEpisodeDO.getPasEvent().getId(), inpatEpisodeDO.getPasEvent().getVersion()));
			}
			factory.save(inpatEpisodeDO);

			if (voBedSpaceState != null)
			{
				BedSpaceState doBed = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpaceState);
				factory.save(doBed);				
			}

			if (voBedSpaceState != null && !Boolean.TRUE.equals(voHlToReOpen.getBedRetained()))
				updateOccupiedBedsForWardAndBay(voBedSpaceState.getWard(), voBedSpaceState.getBay(), null);
			
			if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS") && voBedSpaceState != null && !Boolean.TRUE.equals(voHlToReOpen.getBedRetained()))
			{
				Sex tempGender = voInpat.getPasEvent() != null && voInpat.getPasEvent().getPatientIsNotNull() && voInpat.getPasEvent().getPatient().getSexIsNotNull() && !Sex.UNKNOWN.equals(voInpat.getPasEvent().getPatient().getSex())? voInpat.getPasEvent().getPatient().getSex() : null;
				checkAndUpdateBayConfig(factory, voBedSpaceState,tempGender);
			}
		}		
	}
	//WDEV-20669 --- end
	
	public ServiceLiteVoCollection listServices(String value)
	{
		BedAdmissionComponent impl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		return impl.listServices(value);
	}

	public InpatientEpisodeTrackingMoveVo getInpatientTrackingMove(InpatientEpisodeRefVo inpatientEpisode)
	{
		if (inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			return null;
		
		return InpatientEpisodeTrackingMoveVoAssembler.create((InpatientEpisode) getDomainFactory().getDomainObject(InpatientEpisode.class, inpatientEpisode.getID_InpatientEpisode()));
	}


	public InpatientEpisodeTrackingMoveVo saveInpatientEpisodeTrackingMovement(InpatientEpisodeTrackingMoveVo inpatientEpisodeTrackingMove) throws StaleObjectException
	{
		if (inpatientEpisodeTrackingMove == null)
			throw new CodingRuntimeException("Cannot save null record");
		
		if (!inpatientEpisodeTrackingMove.isValidated())
			throw new CodingRuntimeException("Cannot save records not validated");
		
		@SuppressWarnings("rawtypes")
		HashMap map =  new HashMap();
		InpatientEpisode domInpatientEpisode = InpatientEpisodeTrackingMoveVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisodeTrackingMove, map);
		
		getDomainFactory().save(domInpatientEpisode);

		return InpatientEpisodeTrackingMoveVoAssembler.create(domInpatientEpisode);
	}

	public void vacateBedSpace(InPatientEpisodeADTVo voInpat, BedSpaceStateLiteVo voBedSpaceStateLite, HomeLeaveVo voCurrentHomeLeave) throws DomainInterfaceException, StaleObjectException
	{
		if (voInpat == null)
			throw new CodingRuntimeException("InPatientEpisodeADTVo argument cannot be null in method vacateBedSpace()");

		if (voCurrentHomeLeave == null)
			throw new CodingRuntimeException("HomeLeaveVo argument cannot be null in method vacateBedSpace()");

		DomainFactory domainFactory = getDomainFactory();

		InpatientEpisode inpatientEpisodeDO = (InpatientEpisode) domainFactory.getDomainObject(InpatientEpisode.class, voInpat.getID_InpatientEpisode());

		if (inpatientEpisodeDO == null || inpatientEpisodeDO.getVersion() > voInpat.getVersion_InpatientEpisode())
			throw new DomainInterfaceException("The patient record was updated by another user. The screen will refresh.");
		if (inpatientEpisodeDO.getBed() == null)
			throw new DomainInterfaceException("The bed was vacated by another user. The screen will refresh.");

		InpatientEpisode doInpat = InPatientEpisodeADTVoAssembler.extractInpatientEpisode(domainFactory, voInpat);
		HomeLeave doHomeLeave = HomeLeaveVoAssembler.extractHomeLeave(domainFactory, voCurrentHomeLeave);
		
		int currentHomeLeaveIndex = -1;
		if (doHomeLeave != null)
		{	
			currentHomeLeaveIndex = doInpat.getHomeLeaves().indexOf(doHomeLeave);
			if (currentHomeLeaveIndex != -1)
			{
				HomeLeave doHLForUpdate = (HomeLeave) doInpat.getHomeLeaves().get(currentHomeLeaveIndex);
				if (doHLForUpdate != null)
				{	
					doHLForUpdate.setBedRetained(doHomeLeave.isBedRetained());
				}	
			}
		}
		else
		{
			throw new DomainInterfaceException("The home leave was cancelled by another user. The screen will refresh.");
		}
		
		domainFactory.save(doInpat);

		if (voBedSpaceStateLite != null)
		{	
			BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(domainFactory,voBedSpaceStateLite);
			domainFactory.save(doBedSpaceState);
		}
		updateOccupiedBedsForWardAndBay(voBedSpaceStateLite.getWard(), voBedSpaceStateLite.getBay(), null);			

		if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("MAXIMS") && voBedSpaceStateLite != null )
		{
			Sex tempGender = voInpat.getPasEvent() != null && voInpat.getPasEvent().getPatientIsNotNull() && voInpat.getPasEvent().getPatient().getSexIsNotNull() && !Sex.UNKNOWN.equals(voInpat.getPasEvent().getPatient().getSex())  ? voInpat.getPasEvent().getPatient().getSex() : null;
			checkAndUpdateBayConfig(domainFactory, voBedSpaceStateLite,tempGender);
		}
	}
	//WDEV-21156
	public AdmissionDetailVo updateAdmissionDetailWithHealthyLodgerInfo(AdmissionDetailVo admissionDetailToSave, HealthyLodgerVo healthyLodgerDetails) throws StaleObjectException
	{
		if (admissionDetailToSave == null)
			throw new CodingRuntimeException("admissionDetailToSave argument cannot be null in method updateAdmissionDetailsWithHealthyLodgerInfo");
		
		DomainFactory factory = getDomainFactory();
		
		AdmissionDetail admissionDO = AdmissionDetailVoAssembler.extractAdmissionDetail(factory, admissionDetailToSave);
		
		factory.save(admissionDO);
		
		return AdmissionDetailVoAssembler.create(admissionDO);
	}


	public PatientShort getPatientShort(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;
		
		return PatientShortAssembler.create((Patient) getDomainFactory().getDomainObject(Patient.class, patient.getID_Patient()));
	}

	
	private CancellationTypeReasonVo getDeferredReason(CancelAppointmentReason reason)
	{
		String query = "SELECT reasonConfig FROM CancellationTypeReason AS reasonConfig left join reasonConfig.cancellationType as ctype where ctype.id = :PROVIDER_CANCELLATION and (reasonConfig.tCITheatre = 1  OR reasonConfig.outpatients  <> 1) and reasonConfig.cancellationReason.id = :REASON";
		
		List<?> results = getDomainFactory().find(query,new String[]{"PROVIDER_CANCELLATION", "REASON"},new Object[] {Status_Reason.HOSPITALCANCELLED.getID(),reason.getID()});
		if (results == null || results.isEmpty())
			return null;
		
		return CancellationTypeReasonVoAssembler.create((CancellationTypeReason) results.get(0));
	}

	public void cancelCurrentAdmission(PatientShort patientShort)throws StaleObjectException, ForeignKeyViolationException//WDEV-22327
	{
	if(patientShort == null)
		throw new CodingRuntimeException("patientShort is null in method cancelCurrentAdmission");
	
	InpatientEpisodeMaintenance implIEM = (InpatientEpisodeMaintenance)getDomainImpl(InpatientEpisodeMaintenanceImpl.class);
	implIEM.cancelCurrentAdmission(patientShort);		
	}
	
	//WDEV-22326
	public void updateAdmissionDetail(InpatientEpisodeRefVo inpatEpisodeRef, AdmissionDetailVo currentAdmission, AdmissionDetailForADTUpdateAdmissionVo admissionUpdatesVo) throws StaleObjectException
	{		
		if (currentAdmission == null)
			throw new CodingRuntimeException("AdmissionDetailVo argument cannot be null in method updateAdmissionDetail()");
		if (admissionUpdatesVo == null)
			throw new CodingRuntimeException("AdmissionDetailForADTUpdateAdmissionVo argument cannot be null in method updateAdmissionDetail()");
		if (inpatEpisodeRef == null)
			throw new CodingRuntimeException("InpatientEpisodeRefVo argument cannot be null in method updateAdmissionDetail()");
		
		ADT impl = (ADT) getDomainImpl(ADTImpl.class);
		DomainFactory dfact = getDomainFactory();
		InpatientEpisode domainObjectInpat = (InpatientEpisode)dfact.getDomainObject(InpatientEpisode.class, inpatEpisodeRef.getID_InpatientEpisode());
		
		if (domainObjectInpat == null)
			throw new StaleObjectException(domainObjectInpat);
		
		InpatientEpisodeVo inpatientRecord = InpatientEpisodeVoAssembler.create(domainObjectInpat);
		if (inpatientRecord != null)
		{	
			inpatientRecord = updateInpatientRecord(inpatientRecord,currentAdmission,admissionUpdatesVo);
			String[] err = inpatientRecord.validate();
			if (err != null)
			{
				throw new CodingRuntimeException("InpatientEpisodeVo object has validation errors in method updateAdmissionDetail()");
			}

			impl.updateInpatient(inpatientRecord, null, false);

			if (inpatientRecord.getPasEvent()!= null)
			{
				PASEvent domainObjectPASEvent = (PASEvent)dfact.getDomainObject(PASEvent.class, inpatientRecord.getPasEvent().getID_PASEvent());   
				impl.triggerUpdateAdmissionEvent(new PASEventRefVo(domainObjectPASEvent.getId(), domainObjectPASEvent.getVersion()),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
			}
		}
				
	}

	private InpatientEpisodeVo updateInpatientRecord(InpatientEpisodeVo inpatientRecord, AdmissionDetailVo currentAdmission, AdmissionDetailForADTUpdateAdmissionVo admissionUpdatesVo)
	{
		inpatientRecord.setAdmissionDetailUpdates(admissionUpdatesVo);
		inpatientRecord.setMethodOfAdmission(currentAdmission.getMethodOfAdmission());
		inpatientRecord.setSourceOfAdmission(currentAdmission.getSourceOfAdmission());
		inpatientRecord.setPatientStatus(currentAdmission.getPatientStatus());
		inpatientRecord.setIsChaplainRequired(currentAdmission.getIsChaplainRequired());
		inpatientRecord.setAdmissionDetails(currentAdmission.toAdmissionDetailRefVo());
		
		return inpatientRecord;
	}
	//WDEV-22326 -- end	

	//WDEV-22448
	public DeathDetailsVo getDeathDetails(PatientRefVo voPat)
	{
		if (voPat == null)
			return null;
		PDSDemographics demographicsImpl = (PDSDemographics) getDomainImpl(PDSDemographicsImpl.class);
		return demographicsImpl.getDeathDetails(voPat);
	}

	@Override
	public Boolean isCaseNoteFolderLocation(PatientRefVo patientRef)//WDEV-22851
	{
		if(patientRef== null)
			return false;
		
		AdmitToWard	 impl =(AdmitToWard)getDomainImpl(AdmitToWardImpl.class);
		return impl.isCaseNoteFolderLocation(patientRef);	
	}
	

	public WardStayLiteVo getCurrentWardStay(InpatientEpisodeRefVo inpatientEpisode)
	{
		if (inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			return null;
		
		String query = "SELECT wardStay FROM InpatientEpisode AS inpatEp LEFT JOIN inpatEp.wardStays AS wardStay WHERE inpatEp.id = :INPATIENT_EPISODE AND (wardStay.isRIE is null OR wardStay.isRIE = 0) ORDER BY wardStay.transferDateTime DESC";
		
		return WardStayLiteVoAssembler.create((WardStay) getDomainFactory().findFirst(query, "INPATIENT_EPISODE", inpatientEpisode.getID_InpatientEpisode()));
	}


	public ConsultantStayMinVo getCurrentConsultantStay(InpatientEpisodeRefVo inpatientEpisode)
	{
		if (inpatientEpisode == null || inpatientEpisode.getID_InpatientEpisode() == null)
			return null;
		
		String query = "SELECT consStay FROM InpatientEpisode AS inpatEp LEFT JOIN inpatEp.consultantStays AS consStay WHERE inpatEp.id = :INPATIENT_EPISODE AND (consStay.isRIE is null OR consStay.isRIE = 0) ORDER BY consStay.transferDateTime DESC";
		
		return ConsultantStayMinVoAssembler.create((ConsultantStay) getDomainFactory().findFirst(query, "INPATIENT_EPISODE", inpatientEpisode.getID_InpatientEpisode()));
	}
}	
