//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.66 build 3261.22124)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.ServiceConfiguration;
import ims.admin.domain.impl.ServiceConfigurationImpl;
import ims.admin.vo.ElectiveListConfigurationVo;
import ims.admin.vo.domain.ElectiveListConfigurationVoAssembler;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.BookAppointmentForWardAttendersVo;
import ims.RefMan.vo.BookAppointmentForWardAttendersVoCollection;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.ContractConfigShortVo;
import ims.RefMan.vo.ContractServiceLocationsConfigVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVo;
import ims.RefMan.vo.PatientElectiveListBedAdmissionVoCollection;
import ims.RefMan.vo.PatientElectiveListBedInfoVoCollection;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.PatientElectiveListTCIVo;
import ims.RefMan.vo.domain.BookAppointmentForWardAttendersVoAssembler;
import ims.RefMan.vo.domain.ContractConfigShortVoAssembler;
import ims.RefMan.vo.domain.ContractServiceLocationsConfigVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedAdmissionVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListBedInfoVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListTCIVoAssembler;
import ims.RefMan.vo.lookups.ElectiveAdmissionType;
import ims.clinical.vo.lookups.VTEAsessmentStatus;
import ims.configuration.InitConfig;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.CareContextStatusHistory;
import ims.core.admin.domain.objects.CareSpell;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.domain.objects.Referral;
import ims.core.admin.pas.domain.objects.AdmissionDetail;
import ims.core.admin.pas.domain.objects.BayTimesAdmissionBreach;
import ims.core.admin.pas.domain.objects.BedSpaceState;
import ims.core.admin.pas.domain.objects.HomeLeave;
import ims.core.admin.pas.domain.objects.InpatientEpisode;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.admin.pas.domain.objects.PendingElectiveAdmission;
import ims.core.admin.pas.domain.objects.PendingEmergencyAdmission;
import ims.core.admin.pas.domain.objects.PendingNoEDEmergencyAdmit;
import ims.core.admin.pas.domain.objects.WardBayConfig;
import ims.core.admin.pas.domain.objects.WardMixedSexBreach;
import ims.core.admin.pas.domain.objects.WardStay;
import ims.core.admin.pas.vo.AdmissionDetailRefVo;
import ims.core.admin.pas.vo.BedSpaceStateRefVo;
import ims.core.admin.pas.vo.InpatientEpisodeRefVo;
import ims.core.admin.pas.vo.PASEventRefVo;
import ims.core.admin.pas.vo.PendingEmergencyAdmissionRefVo;
import ims.core.admin.pas.vo.WardBayConfigRefVo;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.ReferralRefVo;
import ims.core.clinical.domain.objects.TaxonomyMap;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.domain.objects.AppUser;
import ims.core.configuration.domain.objects.ContractConfig;
import ims.core.configuration.domain.objects.ContractServiceLocationsConfig;
import ims.core.configuration.domain.objects.ElectiveListConfiguration;
import ims.core.configuration.vo.AppUserRefVo;
import ims.core.configuration.vo.ContractConfigRefVo;
import ims.core.domain.ADT;
import ims.core.domain.AdmitToWard;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.BedInfoDialog;
import ims.core.domain.CaseNoteTransfer;
import ims.core.domain.Demographics;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.PatientSearch;
import ims.core.domain.WardView;
import ims.core.helper.DTOHelper;
import ims.core.helper.IEmergencyHelper;
import ims.core.helper.IPathwayPatientEventHelper;
import ims.core.layout.domain.objects.BayConfig;
import ims.core.patient.domain.objects.PatientId;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.Medic;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.CCGPCTPCCodes;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.domain.objects.Organisation;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.AdmissionDetailVo;
import ims.core.vo.AdmissionReasonVo;
import ims.core.vo.BayConfigLiteVo;
import ims.core.vo.BayConfigVo;
import ims.core.vo.BayTimesAdmissionBreachedVo;
import ims.core.vo.BedSpaceStateLiteVo;
import ims.core.vo.BedSpaceVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.CareContextShortVoCollection;
import ims.core.vo.CareSpellAdmitVo;
import ims.core.vo.CareSpellVo;
import ims.core.vo.CatsReferralEmergencyAdmissionVo;
import ims.core.vo.CatsReferralPendingAdmissionAdmitVo;
import ims.core.vo.CatsReferralPendingEmergencyNonEDAdmissionListVo;
import ims.core.vo.CatsReferralPendingEmergencyNonEDAdmissionListVoCollection;
import ims.core.vo.ConsultantStayVo;
import ims.core.vo.EpisodeOfCareWithPrimaryDiagnosisVo;
import ims.core.vo.EpisodeOfCareWithPrimaryDiagnosisVoCollection;
import ims.core.vo.FloorBedSpaceLayoutVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HealthyLodgerVo;
import ims.core.vo.HomeLeaveVo;
import ims.core.vo.InpatientEpisodeLiteVo;
import ims.core.vo.InpatientEpisodeLiteVoCollection;
import ims.core.vo.InpatientEpisodeVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.MedicVo;
import ims.core.vo.MedicVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.Patient;
import ims.core.vo.PatientCaseNoteRequestLiteVoCollection;
import ims.core.vo.PatientCaseNoteRequestVoCollection;
import ims.core.vo.PatientCaseNoteTransferVoCollection;
import ims.core.vo.PatientCaseNoteVoCollection;
import ims.core.vo.PatientFilter;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.PatientLite_IdentifiersVo;
import ims.core.vo.PatientLite_IdentifiersVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.PatientShortCollection;
import ims.core.vo.PatientWithGPForCCGVo;
import ims.core.vo.PendingElectiveAdmissionAdmitVo;
import ims.core.vo.PendingElectiveAdmissionAdmitVoCollection;
import ims.core.vo.PendingEmergencyAdmissionAdmitVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.TrackingForPendingEmergencyAdmitVo;
import ims.core.vo.TrackingForPendingEmergencyAdmitVoCollection;
import ims.core.vo.WardBayConfigForWardViewVo;
import ims.core.vo.WardMixedSexBreachVo;
import ims.core.vo.WardStayVo;
import ims.core.vo.domain.AdmissionDetailVoAssembler;
import ims.core.vo.domain.BayConfigLiteVoAssembler;
import ims.core.vo.domain.BayTimesAdmissionBreachedVoAssembler;
import ims.core.vo.domain.BedSpaceStateLiteVoAssembler;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.CareSpellAdmitVoAssembler;
import ims.core.vo.domain.CareSpellVoAssembler;
import ims.core.vo.domain.CatsReferralEmergencyAdmissionVoAssembler;
import ims.core.vo.domain.CatsReferralPendingAdmissionAdmitVoAssembler;
import ims.core.vo.domain.CatsReferralPendingEmergencyNonEDAdmissionListVoAssembler;
import ims.core.vo.domain.ConsultantStayVoAssembler;
import ims.core.vo.domain.EpisodeOfCareWithPrimaryDiagnosisVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.InpatientEpisodeLiteVoAssembler;
import ims.core.vo.domain.InpatientEpisodeVoAssembler;
import ims.core.vo.domain.LocationListVoAssembler;
import ims.core.vo.domain.MedicVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffMappingsLiteVoAssembler;
import ims.core.vo.domain.PatientCaseNoteRequestLiteVoAssembler;
import ims.core.vo.domain.PatientIdAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.PatientLite_IdentifiersVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.PatientWithGPForCCGVoAssembler;
import ims.core.vo.domain.PendingElectiveAdmissionAdmitVoAssembler;
import ims.core.vo.domain.PendingEmergencyAdmissionAdmitVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.domain.TrackingForPendingEmergencyAdmitVoAssembler;
import ims.core.vo.domain.WardBayConfigForWardViewVoAssembler;
import ims.core.vo.domain.WardMixedSexBreachVoAssembler;
import ims.core.vo.domain.WardStayVoAssembler;
import ims.core.vo.enums.AdmissionType;
import ims.core.vo.lookups.AlertType;
import ims.core.vo.lookups.BedStatus;
import ims.core.vo.lookups.CareContextStatus;
import ims.core.vo.lookups.CareSpelltoEpisodeRelationship;
import ims.core.vo.lookups.CaseNoteRequestStatus;
import ims.core.vo.lookups.ContextType;
import ims.core.vo.lookups.ElectiveAdmissionStatus;
import ims.core.vo.lookups.EmergencyAdmissionStatus;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MethodOfAdmission;
import ims.core.vo.lookups.MsgUpdateType;
import ims.core.vo.lookups.PASSpecialty;
import ims.core.vo.lookups.PASSpecialtyCollection;
import ims.core.vo.lookups.PatIdType;
import ims.core.vo.lookups.PendingAdmissionStatus;
import ims.core.vo.lookups.ReferralType;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.Sex;
import ims.core.vo.lookups.Specialty;
import ims.core.vo.lookups.SpecialtyCollection;
import ims.core.vo.lookups.TCIType;
import ims.core.vo.lookups.TaxonomyType;
import ims.core.vo.lookups.TransferStatus;
import ims.core.vo.lookups.WaitingListStatus;
import ims.core.vo.lookups.WardBayStatus;
import ims.domain.DomainFactory;
import ims.domain.DomainObject;
import ims.domain.exceptions.DTODomainInterfaceException;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.lookups.LookupInstance;
import ims.domain.lookups.LookupMapping;
import ims.dto.DTODomainImplementation;
import ims.dto.Result;
import ims.dto.client.Conspc;
import ims.dto.client.Conspc.ConspcRecord;
import ims.dto.client.Homeleave;
import ims.dto.client.Homeleave.HomeleaveRecord;
import ims.dto.client.Inpat;
import ims.dto.client.Inpat.InpatRecord;
import ims.emergency.domain.objects.Tracking;
import ims.emergency.vo.TrackingRefVo;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.enumerations.SystemLogLevel;
import ims.framework.enumerations.SystemLogType;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.DateTimeFormat;
import ims.framework.utils.Time;
import ims.framework.utils.TimeFormat;
import ims.pathways.configuration.domain.objects.RTTStatusPoint;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PathwayRTTStatus;
import ims.pathways.domain.objects.PathwaysRTTClockImpact;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.RTTStatusEventMap;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.PatientJourneyVo;
import ims.pathways.vo.PatientPathwayJourneyRefVo;
import ims.pathways.vo.RTTStatusEventMapRefVo;
import ims.pathways.vo.RTTStatusEventMapVo;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.domain.RTTStatusEventMapVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.pathways.vo.lookups.RTTClockImpactSource;
import ims.pathways.vo.lookups.RTTClockState;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.PendingEmergencyTheatre;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.PendingEmergencyTheatreForAdmitVo;
import ims.scheduling.vo.PendingEmergencyTheatreForAdmitVoCollection;
import ims.scheduling.vo.domain.PendingEmergencyTheatreForAdmitVoAssembler;
import ims.scheduling.vo.lookups.PendingEmergencyTheatreStatus;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.vo.LookupMappingVo;
import ims.vo.LookupMappingVoCollection;
import ims.vo.interfaces.IMos;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.hibernate.StaleObjectStateException;
import org.hibernate.exception.LockAcquisitionException;



public class BedAdmissionComponentImpl extends DTODomainImplementation implements BedAdmissionComponent
{
	private static final long serialVersionUID = 1L;

	private static final Integer SUBSEQUENT_ACTIVITY							= 20;
	private static final Integer START_OF_FIRST_DEFINITIVE_TREATMENT			= 30;
	private static final Integer START_ACTIVE_MONITORING_PATIENT				= 31;
	private static final Integer START_ACTIVE_MONITORING_CARE_PROFESSIONAL		= 32;
	private static final Integer FIRST_DEFINITIVE_TREATMENT_OCURRED_PREVIOUSLY	= 90;
	private static final Integer CARE_ACTIVITY_DURING_ACTIVE_MONITORING			= 91;




	private enum ConfigChange //WDEV-20224
	{
		WARD_BLOCKED (-3110),
		WARD_CLOSED (-3109),
		BAY_BLOCKED (-3108),
		BAY_CLOSED (-3107),
		OTHER(-3106);

		private int action;

		private ConfigChange (int action)
		{
			this.action = action;
		}
	}


	public boolean dtoOnly()
	{
		return InitConfig.getConfigType().equals("DTO");
	}

	public Class getLookupServiceClass()
	{
		return ims.domain.lookups.impl.LookupServiceImpl.class;
	}
	/**
	 * listPendingElectiveAdmission
	 */
	public ims.core.vo.PendingElectiveAdmissionAdmitVoCollection listPendingElectiveAdmission(LocationRefVo voLocation)
	{
		if(voLocation == null)
			throw new CodingRuntimeException("voLocation is null in method listPendingElectiveAdmission");

		DomainFactory factory = getDomainFactory();
		List pendingElectives = factory.find("from PendingElectiveAdmission pea where (pea.tCIDate = :today or pea.tCIDate = :yesterday) and pea.allocatedWard.id = :idWard and pea.electiveAdmissionStatus = :status  and pea.tCIType = :tciType ", new String[]{"today","yesterday", "idWard","status","tciType"}, new Object[]{new Date().getDate(),new Date().addDay(-1).getDate(), voLocation.getID_Location(), getDomLookup(ElectiveAdmissionStatus.TCI), getDomLookup(TCIType.BOOKED)});
		return PendingElectiveAdmissionAdmitVoAssembler.createPendingElectiveAdmissionAdmitVoCollectionFromPendingElectiveAdmission(pendingElectives);
	}


	@SuppressWarnings({ "unchecked", "rawtypes" })
	public PatientElectiveListBedAdmissionVo saveTCIAdmissionAndUpdateList(PatientElectiveListBedAdmissionVo electiveAdmission, 
			BedSpaceStateLiteVo bedSpaceState, 
			WardStayVo wardStay, 
			ConsultantStayVo consultant, 
			AdmissionReasonVo admissionReasonVo, 
			WardMixedSexBreachVo wardMixedSexBreachVo, 
			WardBayConfigRefVo wardbayConfigRef, 
			PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer) 
																				throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException
	{
		if (electiveAdmission == null)
			throw new CodingRuntimeException("Elective Admission is mandatory for saving");
		if (!electiveAdmission.isValidated())
			throw new CodingRuntimeException("Elective Admission has not been validated in method saveAdmission");

		WardBayConfig domWardBayConfig = null;
		DomainFactory factory = getDomainFactory();
		if (wardbayConfigRef != null && wardbayConfigRef.getID_WardBayConfig() != null)
		{
			domWardBayConfig = (WardBayConfig) factory.getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
		}

		HashMap domMap = new HashMap();
		PatientElectiveList domElectiveAdmission = PatientElectiveListBedAdmissionVoAssembler.extractPatientElectiveList(factory, electiveAdmission, domMap);

		
		try
		{
			// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
			// When admitting a patient from Elective List - use the Admission Date Time
			java.util.Date eventDateTime = electiveAdmission.getTCIDetails().getAdmissionDetail().getAdmissionDateTime().getJavaDate();
			saveElectiveTCIAdmissions(electiveAdmission, bedSpaceState, wardStay, consultant, admissionReasonVo, wardMixedSexBreachVo, wardbayConfigRef, domWardBayConfig, factory, domMap, domElectiveAdmission, eventDateTime);
			
			updatePatientCaseNotesTransfers(collPatientCaseNoteTransfer);

			// WDEV-18742
			saveDementiaRecord(electiveAdmission.getTCIDetails().getAdmissionDetail(), domMap, factory);
		}
		catch (DomainInterfaceException ex)
		{
			throw new DomainInterfaceException(ex);
		}
		catch (Exception ex)
		{
			DomainObject staleObject = null;
			
			if (ex instanceof DomainRuntimeException && ((DomainRuntimeException)ex).getCause() instanceof StaleObjectStateException)
			{
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'doSaveAdmissionAndUpdateList': " + ex.getMessage());
				
				StaleObjectStateException staleException = (StaleObjectStateException) ((DomainRuntimeException)ex).getCause();

				try
				{
    				Integer id = (Integer) staleException.getIdentifier();
    				String className = staleException.getEntityName();
    				ims.domain.DomainObject domainObject = null;
    				Class domainClass;
					domainClass = Class.forName(className);
					domainObject = getDomainFactory().getDomainObject(domainClass, id);
					throw new StaleObjectException(domainObject);
				}
				catch (ClassNotFoundException e)
				{
					e.printStackTrace();
					throw new StaleObjectException(null);
				}
				
			}
			if (ex instanceof StaleObjectException)
			{
				staleObject = ((StaleObjectException) ex).getStaleObject();
			}

			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'doSaveAdmissionAndUpdateList': " + ex.getMessage());
			throw new StaleObjectException(staleObject);
		}

		//WDEV-20217
		try
		{
			updateOccupiedBedsValue(domWardBayConfig, bedSpaceState);
		}
		catch (Exception ex)
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Elective Admission Error in method 'updateOccupiedBedsValue' - first try: " + ex.getMessage());;
			ex.printStackTrace(); //just for test - remove

			try
			{
				if (wardbayConfigRef != null && wardbayConfigRef.getID_WardBayConfig() != null)
				{
					domWardBayConfig = (WardBayConfig) getDomainFactory().getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
				}
				updateOccupiedBedsValue(domWardBayConfig, bedSpaceState);
			}
			catch (Exception ex1)
			{
				ex1.printStackTrace(); // just for testing - remove
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Elective Admission Error in method 'updateOccupiedBedsValue' - second try: " + ex1.getMessage());

				throw new StaleObjectException(domWardBayConfig);
			}
		}


		try
		{
			return PatientElectiveListBedAdmissionVoAssembler.create(domElectiveAdmission);
		}
		catch (Exception ex)
		{
			throw new StaleObjectException(domWardBayConfig);
		}
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private void saveElectiveTCIAdmissions(PatientElectiveListBedAdmissionVo electiveAdmission, BedSpaceStateLiteVo bedSpaceState, WardStayVo wardStay, ConsultantStayVo consultant, AdmissionReasonVo admissionReasonVo, WardMixedSexBreachVo wardMixedSexBreachVo, WardBayConfigRefVo wardbayConfigRef, WardBayConfig domWardBayConfig, DomainFactory factory, HashMap domMap, PatientElectiveList domElectiveAdmission, java.util.Date eventDateTime) throws UniqueKeyViolationException, StaleObjectException, DomainInterfaceException
	{
		if (wardbayConfigRef != null)
		{	
			ConfigChange configChange = wasConfigChanged(bedSpaceState, domWardBayConfig);
			//WDEV-23279
			//			if (configChange != null)
			if (configChange != null && !ConfigChange.OTHER.equals(configChange)) //WDEV-23279
			{	
				throw new UniqueKeyViolationException(buildExceptionMessage(configChange));
			}
		}

		//WDEV-21646
		if(domElectiveAdmission.getTCIDetails().getAdmissionDetail() != null)
		{
			domElectiveAdmission.getTCIDetails().getAdmissionDetail().setAdmittingUser((AppUser) factory.getDomainObject((AppUserRefVo) getLoggedInUser()));
			if (domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent() != null && domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getPatient() != null)
			{	
				domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getPatient().setWard(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getWard());
			}
		}

		factory.save(domElectiveAdmission);

		CatsReferral domCats = domElectiveAdmission.getReferral();

		//WDEV-20010 Create a new CareContext
		if (domCats != null && domCats.getCareContext() != null && domCats.getCareContext().getEpisodeOfCare() != null)
		{
			EpisodeOfCare episodeOfCare = domCats.getCareContext().getEpisodeOfCare();

			CareContext doCareContext = new CareContext();
			doCareContext.setEpisodeOfCare(episodeOfCare);
			doCareContext.setContext(getDomLookup(ContextType.INPATIENT));
			doCareContext.setStartDateTime(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getAdmissionDateTime());
			doCareContext.setPasEvent(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent());
			doCareContext.setResponsibleHCP(episodeOfCare.getResponsibleHCP());
			doCareContext.setEstimatedDischargeDate(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getEstDischargeDate());

			doCareContext.setCurrentStatus(new CareContextStatusHistory());
			doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
			doCareContext.getCurrentStatus().setStatusDateTime(new java.util.Date());

			episodeOfCare.getCareContexts().add(doCareContext);
			factory.save(episodeOfCare);
		}



		//WDEV-18316  WDEV-18617 - only stop clock if EL is non-diagnostic
		if (Boolean.TRUE.equals(ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue()) && Boolean.TRUE.equals(domCats.isRTTClockImpact()))
		{
			// Place holders for clock Impact variables
			PathwaysRTTClockImpact clockImpact = null;
			PathwayClock initialClock = null;
			PathwayRTTStatus initialRTTStatus = null;
			boolean wasClockStarted = false; // since we can't create a copy of the initial clock and it's possible it will be changed
			boolean wasClockStopped = false; // retain in these 2 boolean variables the state of the initial clock
			LookupInstance initialClockState = getDomLookup(RTTClockState.NOT_PRESENT);


			if (domCats.getJourney() != null)
			{
				initialClock = domCats.getJourney().getCurrentClock();
				wasClockStarted = initialClock != null && initialClock.getStartDate() != null;
				wasClockStopped = initialClock != null && initialClock.getStopDate() != null;
				initialClockState = getClockState(initialClock);
			}
			initialRTTStatus = domCats.getCurrentRTTStatus();

			// WDEV-18686 - Instead of just stopping the clock and setting the status, we set status, and look for the relevant admission
			// event dependent on whether this is a Treatment or Diagnostic Admission
			Boolean isDiagnostic = false;
			PathwayRTTStatus rttStatus = null;

			// WDEV-18617 - create 20 for diagnostic on admission, so pass this to create method
			// WDEV-22420 - For Treatment Admission we have 2 cases
			// Case 1 - the admission is done when the current clock is not stopped
			if (initialClock != null && initialClock.getStopDate() == null)
			{
				// Diagnostic - set status to 20
				if ( domElectiveAdmission.getElectiveListReason() != null && domElectiveAdmission.getElectiveListReason().getId() == ElectiveListReason.DIAGNOSTIC.getId())
				{
					rttStatus = createPathwayRTTStatus(domCats, SUBSEQUENT_ACTIVITY, eventDateTime);
					isDiagnostic = true;
				}
				// Treatment - set status to 30
				else if (initialClock != null && initialClock.getStopDate() == null)
				{
					rttStatus = createPathwayRTTStatus(domCats, START_OF_FIRST_DEFINITIVE_TREATMENT, eventDateTime);
				}
			}
			// Case 2 - the admission is done when the current clock is stopped - then set the RTT Status to 90
			else
			{
				// Sub-Case 1 - the RTT Status is 31 or 32 or 91 - then set the RTT Status to 91
				if (domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null && domCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null
						&& (START_ACTIVE_MONITORING_PATIENT.equals(domCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus().getNationalCode())
								|| START_ACTIVE_MONITORING_CARE_PROFESSIONAL.equals(domCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus().getNationalCode())
								|| CARE_ACTIVITY_DURING_ACTIVE_MONITORING.equals(domCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus().getNationalCode())))
				{
					rttStatus = createPathwayRTTStatus(domCats, CARE_ACTIVITY_DURING_ACTIVE_MONITORING, eventDateTime);
				}
				// Sub-Case 2 - the RTT Status is 30 or 90 - then set the RTT Status to 90
				else if (domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null && domCats.getJourney().getCurrentClock().getCurrentRTTStatus() != null
						&& (START_OF_FIRST_DEFINITIVE_TREATMENT.equals(domCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus().getNationalCode())
								|| FIRST_DEFINITIVE_TREATMENT_OCURRED_PREVIOUSLY.equals(domCats.getJourney().getCurrentClock().getCurrentRTTStatus().getRTTStatus().getNationalCode())))
				{
					rttStatus = createPathwayRTTStatus(domCats, FIRST_DEFINITIVE_TREATMENT_OCURRED_PREVIOUSLY, eventDateTime);
				}
				// Default to 90
				else
				{
					rttStatus = createPathwayRTTStatus(domCats, FIRST_DEFINITIVE_TREATMENT_OCURRED_PREVIOUSLY, eventDateTime);
				}
			}

			if (rttStatus != null) domCats.setCurrentRTTStatus(rttStatus);

			Class<?> implClass;
			try 
			{
				implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
				IPathwayPatientEventHelper pathwayImp = (IPathwayPatientEventHelper) getDomainImpl(implClass);


				// Find the event that needs to be instantiated - PAS mapping of type CONS is required for Consultant Upgrade
				ims.pathways.vo.EventVo pthwEvent=null;
				try
				{
					if (isDiagnostic)
						pthwEvent = pathwayImp.getEventByTaxonomyMap(TaxonomyType.PAS, "ADD");
					else
						pthwEvent = pathwayImp.getEventByTaxonomyMap(TaxonomyType.PAS, "ADT");
				}
				catch (DomainInterfaceException e) 
				{
					super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "Event was not found for Admission code = " + (isDiagnostic ? "ADD" : "ADT"));
				}

				if (pthwEvent != null)
				{
					PatientEventVo patientEvent = new PatientEventVo();
					patientEvent.setEvent(pthwEvent);
					if (electiveAdmission.getTCIDetailsIsNotNull() && electiveAdmission.getTCIDetails().getTCIDateIsNotNull())
						patientEvent.setEventDateTime(new DateTime(electiveAdmission.getTCIDetails().getTCIDate()));
					else
						patientEvent.setEventDateTime(new DateTime());	
					patientEvent.setPatient(PatientListVoAssembler.create(domCats.getPatient()));
					patientEvent.setEventStatus(EventStatus.ACTIVE);
					patientEvent.setJourney(PatientJourneyVoAssembler.create(domCats.getJourney()));
					patientEvent.setDescription("Admission Event created from Bed Admission Component");
					pathwayImp.instantiatePatientEvent(patientEvent);

					// CODE HERE

					LookupInstance finalClockState = getClockState(domCats.getJourney().getCurrentClock());

					clockImpact = createRTTClockImpactRecord(initialClock, domCats.getJourney().getCurrentClock(), initialRTTStatus, domCats.getCurrentRTTStatus(), null, domCats.getJourney(), RTTClockImpactSource.ADMISSION, wasClockStarted, wasClockStopped, initialClockState, finalClockState);

				}
				else // No Event found - proceed as previous
				{
					RTTStatusEventMapVo rttMap = getRTTStatusEventMap(rttStatus != null ? rttStatus.getRTTStatus() : null);

					if (rttMap != null && rttMap.getEvent() != null)
					{
						PatientEventVo patEvent = new PatientEventVo();
						patEvent.setPatient(PatientListVoAssembler.create(domCats.getPatient()));
						patEvent.setEvent(rttMap.getEvent());
						patEvent.setEventDateTime(new DateTime());
						patEvent.setEventStatus(EventStatus.ACTIVE);
						patEvent.setJourney(PatientJourneyVoAssembler.create(domCats.getJourney()));
						pathwayImp.instantiatePatientEvent(patEvent);
					}

					if (ElectiveListReason.TREATMENT.equals(electiveAdmission.getElectiveListReason())
							&& (ElectiveAdmissionType.BOOKED_TYPE12.equals(electiveAdmission.getElectiveAdmissionType())
									|| ElectiveAdmissionType.ELECTIVE_TYPE11.equals(electiveAdmission.getElectiveAdmissionType())
									|| ElectiveAdmissionType.PLANNED_TYPE13.equals(electiveAdmission.getElectiveAdmissionType())
							)
					)
					{
						if (domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null
								&& domCats.getJourney().getCurrentClock().getStopDate() == null)
						{
							domCats.getJourney().getCurrentClock().setStopDate(new java.util.Date());

							if (domElectiveAdmission.getPathwayClock() != null)
								domElectiveAdmission.getPathwayClock().setStopDate(new java.util.Date());

							factory.save(domCats);
							factory.save(domElectiveAdmission);
						}
					}

					if (domCats.getJourney() != null)
					{
						LookupInstance finalClockState = getClockState(domCats.getJourney().getCurrentClock());
						clockImpact = createRTTClockImpactRecord(initialClock, domCats.getJourney().getCurrentClock(), initialRTTStatus, domCats.getCurrentRTTStatus(), rttMap, domCats.getJourney(), RTTClockImpactSource.ADMISSION, wasClockStarted, wasClockStopped, initialClockState, finalClockState);
					}
				}

				if (clockImpact != null)
				{
					factory.save(clockImpact);

					if (domCats.getRTTClockImpacts() == null)
					{
						domCats.setRTTClockImpacts(new ArrayList());
					}
					AdmissionDetail admissionDetails = domElectiveAdmission.getTCIDetails().getAdmissionDetail();
					admissionDetails.setAdmissionRTTOutcome(clockImpact);
					domCats.getRTTClockImpacts().add(clockImpact);

					factory.save(admissionDetails);
					factory.save(domCats);
				}

			}
			catch (ClassNotFoundException e1) 
			{
				e1.printStackTrace();
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.WARNING, "ClassNotFoundException - " + e1.getMessage());
			}
		}

		// Pas event was created, Patient has had it's ward updated

		// Create InpatientEpisode
		InpatientEpisode inpatEpisode = null;
		//		if (!isAdmitedOnPAS)
		//		{
		//			// Check for an existing inpatient episode - stop admission process if one exists
		//			String query = "SELECT COUNT(inpat.id) FROM InpatientEpisode AS inpat LEFT JOIN inpat.pasEvent AS pasEv LEFT JOIN pasEv.patient AS pat WHERE pat.id = :PAT_ID";
		//			long count = getDomainFactory().countWithHQL(query, new String[] {"PAT_ID"}, new Object[] {electiveAdmission.getPatient().getID_Patient()});
		//			
		//			if (count > 0) throw new DomainInterfaceException("Patient is already admitted");
		//			
		//			inpatEpisode = new InpatientEpisode();
		//		}
		//		else
		//		{
		//			List<?> episodes = getDomainFactory().find("from InpatientEpisode inpatEpis left join fetch inpatEpis.bed as bedspace  where inpatEpis.pasEvent.id = '" + domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getId() + "' and bedspace is null" );
		//			if(episodes != null && episodes.size() == 1)
		//				inpatEpisode = (InpatientEpisode) episodes.get(0);
		//		}

		if (inpatEpisode == null)
			inpatEpisode = new InpatientEpisode();

		inpatEpisode.setPasEvent(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent());

		inpatEpisode.getPasEvent().setAttendingHCP(domElectiveAdmission.getConsultant());

		inpatEpisode.setAdmissionDateTime(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getAdmissionDateTime());
		inpatEpisode.setEstDischargeDate(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getEstDischargeDate());
		inpatEpisode.setWardType(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getWardType());

		if (wardStay != null)
			inpatEpisode.getWardStays().add(WardStayVoAssembler.extractWardStay(factory, wardStay, domMap));
		if (consultant != null)
			inpatEpisode.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(factory, consultant, domMap));

		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, bedSpaceState, domMap);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(inpatEpisode);	
			inpatEpisode.setBed(doBedSpaceState);
			inpatEpisode.setBedNo(doBedSpaceState.getBedSpace().getBedNumber());
		}

		if (wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true)
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), factory);
			if (doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				inpatEpisode.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}

		// WDEV-19481 - Trigger creation of A01 Admission HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(inpatEpisode);

		ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);

		if(inpatEpisodeVo.getPasEvent()!=null)
		{
			adtimpl.triggerAdmissionEvent(inpatEpisodeVo.getPasEvent());
		}

		//WDEV-12991
		inpatEpisode.setReasonForAdmission(electiveAdmission.getTCIDetails().getAdmissionDetail().getReasonForAdmission());

		//WDEV-19680
		adtimpl.vteOnAdmission(inpatEpisode, domElectiveAdmission.getPatient(), Boolean.TRUE);

		//WDEV-18742
		factory.save(inpatEpisode);


		//WDEV-20224
		if (admissionReasonVo != null) 
		{
			if (Boolean.TRUE.equals(admissionReasonVo.getIsOohAllocationValidated()))
			{
				BayTimesAdmissionBreachedVo bayTimeAdmission = populateBayTimesBreachedRecord(electiveAdmission.getTCIDetails().getAdmissionDetail(),bedSpaceState,admissionReasonVo);

				BayTimesAdmissionBreach bayTimesBreachedDO = BayTimesAdmissionBreachedVoAssembler.extractBayTimesAdmissionBreach(factory, bayTimeAdmission); 
				factory.save(bayTimesBreachedDO);				
			}

			if (Boolean.TRUE.equals(admissionReasonVo.getIsGenderSpecificBayValidated()))
			{
				if (bedSpaceState != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpaceState.getBay());
					if (bayConfig != null)
					{		
						bayConfig.setTemporaryBayGender(bedSpaceState.getProvisionalBayGender());

						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

						factory.save(bayConfigDO);
					}				
				}								
			}
			else if (Boolean.TRUE.equals(admissionReasonVo.getIsMixingGenderBayValidated()))
			{				
				if (wardMixedSexBreachVo != null)
				{	
					WardMixedSexBreach wardMixedAdmissionDO = WardMixedSexBreachVoAssembler.extractWardMixedSexBreach(factory, wardMixedSexBreachVo);

					if (getDomLookup(Sex.MALE).equals(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setMalePatients(wardMixedSexBreachVo.getMalePatientsIsNotNull() ? wardMixedSexBreachVo.getMalePatients().intValue() + 1 : 1);
					if (getDomLookup(Sex.FEMALE).equals(domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setFemalePatients(wardMixedSexBreachVo.getFemalePatientsIsNotNull() ? wardMixedSexBreachVo.getFemalePatients().intValue() + 1 : 1);

					factory.save(wardMixedAdmissionDO);
				}
				if (bedSpaceState != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpaceState.getBay());
					if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
					{		
						if (!bayConfig.getTemporaryBayGender().equals(inpatEpisodeVo.getPasEvent().getPatient().getSex()) && !Sex.UNKNOWN.equals(inpatEpisodeVo.getPasEvent().getPatient().getSex()))
						{
							bayConfig.setTemporaryBayGender(inpatEpisodeVo.getPasEvent().getPatient().getSex());

							BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

							factory.save(bayConfigDO);
						}				
					}
				}

			}
		}	
		//		if(!isAdmitedOnPAS)
		//		{
		//			//4) only admit to pas if record is new 
		//			Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
		//			inpatRec.DataCollection.add();
		//
		//			copyAdmissionToDto(inpatRec, domElectiveAdmission.getTCIDetails().getAdmissionDetail(), null, null);
		//			Result res = inpatRec.executeAction("ADMIT");
		//			
		//			if (res != null && res.getId() < 0 )
		//			{
		//				if (res.getId() == -5)
		//					throw new DomainInterfaceException("Error occurred Admitting Patient to PAS " + res.getMessage());
		//				else 
		//					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS " + res.getMessage());	
		//			}
		//			else
		//			{
		//				if (inpatRec.getLastResultData() == null) {
		//					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS : no result data from PAS");
		//				}
		//					
		//				//WDEV-9663
		//				domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().setPasEventId("I_" +  inpatRec.getLastResultData().getValue("DSPN"));
		//				domElectiveAdmission.getTCIDetails().getAdmissionDetail().getPasEvent().setPasEpisodeId(inpatRec.getLastResultData().getValue("DSPN"));  // WDEV-12588
		//				getDomainFactory().save(domElectiveAdmission.getTCIDetails().getAdmissionDetail());
		//			}
		//		}

		//5) a) Create CareSpell,CareContext and EpisodeOfCare 	or b) Use Selected Episode
		// Not needed - PatientElectiveList has a CATS Referral mandatory which in turn has CareContext mandatory
		// createOrSaveCareSpell(getDomainFactory(), domElectiveAdmission.getTCIDetails().getAdmissionDetail());
	}


	private LookupInstance getClockState(PathwayClock clock)
	{
		if (clock == null)
			return getDomLookup(RTTClockState.NOT_PRESENT);

		if (clock.getStopDate() != null)
			return getDomLookup(RTTClockState.STOPPED);

		return getDomLookup(RTTClockState.STARTED);
	}


	public PathwaysRTTClockImpact createRTTClockImpactRecord(PathwayClock initialClock, PathwayClock pathwayClock, PathwayRTTStatus initialRTTStatus, PathwayRTTStatus pathwayRTTStatus, RTTStatusEventMapRefVo eventMapRefVo, PatientPathwayJourney patientPathwayJourney, RTTClockImpactSource source, boolean wasClockStarted, boolean wasClockStopped, LookupInstance initialClockState, LookupInstance finalClockState)
	{
		PathwaysRTTClockImpact clockImpact = new PathwaysRTTClockImpact();
		clockImpact.setInitialClock(initialClock);
		clockImpact.setFinalClock(pathwayClock);
		clockImpact.setInitialRTTStatus(initialRTTStatus);
		clockImpact.setFinalRTTStatus(pathwayRTTStatus);

		clockImpact.setInitialClockState(initialClockState);
		clockImpact.setFinalClockState(finalClockState);

		if (eventMapRefVo != null && eventMapRefVo.getID_RTTStatusEventMap() != null)
		{
			clockImpact.setOutcomeEvent((RTTStatusEventMap) getDomainFactory().getDomainObject(RTTStatusEventMap.class, eventMapRefVo.getID_RTTStatusEventMap()));
		}
		else
		{
			clockImpact.setOutcomeEvent(null);
		}

		clockImpact.setJourney(patientPathwayJourney);
		clockImpact.setSource(getDomLookup(source));

		clockImpact.setClockStarted(Boolean.FALSE);
		clockImpact.setClockStopped(Boolean.FALSE);

		// Case 1 - If there was no clock initially and one clock was created
		if (initialClock == null && pathwayClock != null)
		{
			// New clock has a start date - mark the ClockImpact
			if (pathwayClock.getStartDate() != null)
				clockImpact.setClockStarted(Boolean.TRUE);

			if (pathwayClock.getStopDate() != null)
				clockImpact.setClockStopped(Boolean.TRUE);
		}

		// Case 2 - If there was a clock initially and there is no clock now
		if (initialClock != null && pathwayClock == null)
		{
			if (wasClockStopped == false)
				clockImpact.setClockStopped(Boolean.TRUE);
		}

		// Case 3 - If there was an initial clock and a clock is present now
		if (initialClock != null && pathwayClock != null)
		{
			// Case 3.1 - Initial and current clock are the same one
			if (initialClock.getId() == pathwayClock.getId())
			{
				if (!wasClockStopped && pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (wasClockStopped && pathwayClock.getStopDate() == null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (!wasClockStarted && pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);
			}

			// Case 3.2 - Initial and current clock are not the same one
			if (!initialClock.getId().equals(pathwayClock.getId()))
			{
				if (!wasClockStopped)
					clockImpact.setClockStopped(Boolean.TRUE);

				if (pathwayClock.getStartDate() != null)
					clockImpact.setClockStarted(Boolean.TRUE);

				if (pathwayClock.getStopDate() != null)
					clockImpact.setClockStopped(Boolean.TRUE);
			}
		}

		return clockImpact;
	}

	/*private void cancelCaseNoteRequests(Integer tciId) throws StaleObjectException
	{
		PatientCaseNoteRequestLiteVoCollection requestsForCancellation = getLinkedCaseNoteOpenRequests(tciId);

		if (requestsForCancellation == null || requestsForCancellation.size() == 0)
			return;

		Object mos = getMosUser();

		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);

		for (int i = 0; i < requestsForCancellation.size(); i++)
		{
			impl.cancelRequest(requestsForCancellation.get(i), (MemberOfStaffRefVo) mos, null);
		}

	}*/

	private PatientCaseNoteRequestLiteVoCollection getLinkedCaseNoteOpenRequests(Integer tciId)
	{
		if(tciId == null)
			return null;

		List<?> list = getDomainFactory().find("select req from PatientCaseNoteRequest as req left join req.tCIDetail as tci left join req.requestStatus as status " +
				"where (tci.id = :tciID and status.id = :requestStatusID)", new String[] {"tciID", "requestStatusID"}, new Object[] {tciId, CaseNoteRequestStatus.OPEN.getID()});

		return PatientCaseNoteRequestLiteVoAssembler.createPatientCaseNoteRequestLiteVoCollectionFromPatientCaseNoteRequest(list);
	}

	// WDEV-18742
	private void saveDementiaRecord(AdmissionDetailVo admissionDetailVo, HashMap domMap, DomainFactory factory) throws StaleObjectException
	{
		ADT impl = (ADT) getDomainImpl(ADTImpl.class);
		AdmissionDetail domAdmDet = AdmissionDetailVoAssembler.extractAdmissionDetail(factory, admissionDetailVo, domMap);
		impl.createDementiaRecordIfRequired(factory, domAdmDet );
	}


	public AdmissionDetailVo saveEmergencyAdmissionInElectiveCase(AdmissionDetailVo admission, CareSpellVo careSpell, CatsReferralEmergencyAdmissionVo catsReferral, BedSpaceStateLiteVo bedSpaceState, WardStayVo wardStay, ConsultantStayVo consultant, AdmissionReasonVo admissionReasonVo, WardMixedSexBreachVo wardMixedSexBreachVo, WardBayConfigRefVo wardbayConfigRef, PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException
	{
		if (admission == null)
			throw new CodingRuntimeException("Admission Details parameter is mandatory.");

		if (careSpell == null)
			throw new CodingRuntimeException("Care Spell parameter is mandatory.");

		if (catsReferral == null)
			throw new CodingRuntimeException("Cats Referral parameter is mandatory.");

		WardBayConfig domWardBayConfig = null;
		if (wardbayConfigRef != null || wardbayConfigRef.getID_WardBayConfig() != null)
		{
			domWardBayConfig = (WardBayConfig) getDomainFactory().getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
		}

		//WDEV-20944
		if (Boolean.TRUE.equals(catsReferral.getIsEmergencyReferral()))
		{
			catsReferral.setJourney(null);
		}
		else
		{
			PatientPathwayJourneyRefVo journey = createPatientJourney(catsReferral, admission);
			catsReferral.setJourney(journey);
		}


		@SuppressWarnings("rawtypes")
		HashMap domMap = new HashMap();
		AdmissionDetail domAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(getDomainFactory(), admission, domMap);
		CareSpell domCareSpell = CareSpellVoAssembler.extractCareSpell(getDomainFactory(), careSpell, domMap);
		CatsReferral domCatsReferral = CatsReferralEmergencyAdmissionVoAssembler.extractCatsReferral(getDomainFactory(), catsReferral, domMap);
		domCatsReferral.getCareContext().setPasEvent(domAdmissionDetail.getPasEvent());

		if (wardbayConfigRef != null)
		{	
			ConfigChange configChange = wasConfigChanged(bedSpaceState, domWardBayConfig);
			//WDEV-23279
			//			if (configChange != null)
			if (configChange != null && !ConfigChange.OTHER.equals(configChange)) //WDEV-23279

			{	
				throw new UniqueKeyViolationException(buildExceptionMessage(configChange));
			}
		}

		try
		{
			saveElectiveEmergencyAdmission(admission, bedSpaceState, wardStay, consultant, admissionReasonVo, wardMixedSexBreachVo, collPatientCaseNoteTransfer, domMap, domAdmissionDetail, domCareSpell, domCatsReferral);
		}
		catch (DomainInterfaceException ex)
		{
				throw new DomainInterfaceException(ex);
		}
		catch (Exception ex)
		{
			DomainObject staleObject = null;
			if (ex instanceof StaleObjectException)
			{
				staleObject = ((StaleObjectException) ex).getStaleObject();
			}

			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Elective Emergency Admission Error in method 'saveElectiveEmergencyAdmission': " + ex.getMessage());
			throw new StaleObjectException(staleObject);
		}


		//WDEV-20217
		try
		{
			updateOccupiedBedsValue(domWardBayConfig, bedSpaceState);
		}
		catch (Exception ex)
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Elective Emergency Admission Error in method 'updateOccupiedBedsValue': " + ex.getMessage());;
			ex.printStackTrace(); //just for test - remove

			try
			{
				if (wardbayConfigRef != null && wardbayConfigRef.getID_WardBayConfig() != null)
				{
					domWardBayConfig = (WardBayConfig) getDomainFactory().getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
				}
				updateOccupiedBedsValue(domWardBayConfig, bedSpaceState);
			}
			catch (Exception ex1)
			{
				ex1.printStackTrace(); // just for testing - remove
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Elective Emergency Admission Error in method 'updateOccupiedBedsValue': " + ex1.getMessage());

				throw new StaleObjectException(domWardBayConfig);
			}
		}
		
		return null;
	}

	private void saveElectiveEmergencyAdmission(AdmissionDetailVo admission, BedSpaceStateLiteVo bedSpaceState, WardStayVo wardStay, ConsultantStayVo consultant, AdmissionReasonVo admissionReasonVo, WardMixedSexBreachVo wardMixedSexBreachVo, PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer, HashMap domMap, AdmissionDetail domAdmissionDetail, CareSpell domCareSpell, CatsReferral domCatsReferral) throws DomainInterfaceException, StaleObjectException
	{
		getDomainFactory().save(domAdmissionDetail);
		getDomainFactory().save(domCareSpell);
		getDomainFactory().save(domCatsReferral);

		InpatientEpisode inpatEpisode = new InpatientEpisode();
		inpatEpisode.setPasEvent(domAdmissionDetail.getPasEvent());
		inpatEpisode.getPasEvent().setConsultant(domAdmissionDetail.getConsultant());
		inpatEpisode.setAdmissionDateTime(domAdmissionDetail.getAdmissionDateTime());
		inpatEpisode.setEstDischargeDate(domAdmissionDetail.getEstDischargeDate()); //WDEV-20367
		inpatEpisode.setWardType(domAdmissionDetail.getWardType());
		inpatEpisode.setIsMaternityInpatient(admission.getIsMaternity());

		if (wardStay != null)
			inpatEpisode.getWardStays().add(WardStayVoAssembler.extractWardStay(getDomainFactory(), wardStay, domMap));
		if (consultant != null)
			inpatEpisode.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(getDomainFactory(), consultant, domMap));

		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpaceState, domMap);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(inpatEpisode);	
			inpatEpisode.setBed(doBedSpaceState);
			inpatEpisode.setBedNo(doBedSpaceState.getBedSpace().getBedNumber());
		}

		if (wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true)
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), getDomainFactory());
			if (doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				inpatEpisode.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}

		// WDEV-19481 - Trigger creation of A01 Admission HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(inpatEpisode);

		ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);

		if(inpatEpisodeVo.getPasEvent()!=null)
		{
			adtimpl.triggerAdmissionEvent(inpatEpisodeVo.getPasEvent());
		}

		//WDEV-19680
		adtimpl.vteOnAdmission(inpatEpisode, domCatsReferral.getPatient(), Boolean.FALSE);

		// WDEV-18742
		DomainFactory factory = getDomainFactory();
		factory.save(inpatEpisode);

		saveDementiaRecord(admission, domMap, factory);

		updatePatientCaseNotesTransfers(collPatientCaseNoteTransfer);




		//WDEV-20224
		if (admissionReasonVo != null) 
		{
			if (Boolean.TRUE.equals(admissionReasonVo.getIsOohAllocationValidated()))
			{
				BayTimesAdmissionBreachedVo bayTimeAdmission = populateBayTimesBreachedRecord(admission,bedSpaceState,admissionReasonVo);

				BayTimesAdmissionBreach bayTimesBreachedDO = BayTimesAdmissionBreachedVoAssembler.extractBayTimesAdmissionBreach(factory, bayTimeAdmission); 
				factory.save(bayTimesBreachedDO);				
			}

			if (Boolean.TRUE.equals(admissionReasonVo.getIsGenderSpecificBayValidated()))
			{
				if (bedSpaceState != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpaceState.getBay());
					if (bayConfig != null)
					{		
						bayConfig.setTemporaryBayGender(bedSpaceState.getProvisionalBayGender());

						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

						factory.save(bayConfigDO);
					}				
				}								
			}
			else if (Boolean.TRUE.equals(admissionReasonVo.getIsMixingGenderBayValidated()))
			{				
				if (wardMixedSexBreachVo != null)
				{	
					WardMixedSexBreach wardMixedAdmissionDO = WardMixedSexBreachVoAssembler.extractWardMixedSexBreach(factory, wardMixedSexBreachVo);

					if (getDomLookup(Sex.MALE).equals(domAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setMalePatients(wardMixedSexBreachVo.getMalePatientsIsNotNull() ? wardMixedSexBreachVo.getMalePatients().intValue() + 1 : 1);
					if (getDomLookup(Sex.FEMALE).equals(domAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setFemalePatients(wardMixedSexBreachVo.getFemalePatientsIsNotNull() ? wardMixedSexBreachVo.getFemalePatients().intValue() + 1 : 1);

					factory.save(wardMixedAdmissionDO);
				}
				if (bedSpaceState != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpaceState.getBay());
					if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
					{		
						if (!bayConfig.getTemporaryBayGender().equals(admission.getPasEvent().getPatient().getSex()) && !Sex.UNKNOWN.equals(admission.getPasEvent().getPatient().getSex()))
						{
							bayConfig.setTemporaryBayGender(admission.getPasEvent().getPatient().getSex());

							BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

							factory.save(bayConfigDO);
						}				
					}
				}
			}			
		}
		//WDEV-20224 -- end
	}


	private PatientJourneyVo createPatientJourney(CatsReferralEmergencyAdmissionVo referral, AdmissionDetailVo admission)
	{
		// Only create the patient journey if the flag specified to do this.
		if (!ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue())
			return null;

		// If a patientjourney already exists for the referral, then don't create a new one
		PatientJourneyVo journey = new PatientJourneyVo();
		journey.setPatient(getPatientShort(referral.getPatient()));

		try 
		{
			Class<?> implClass = Class.forName("ims.pathways.domain.impl.HL7PathwayIfImpl");
			ims.core.helper.IPathwayPatientEventHelper pathwayImp = (ims.core.helper.IPathwayPatientEventHelper) getDomainImpl(implClass);

			// Create the holding referral first
			Referral domReferral = new Referral();
			domReferral.setAuthoringDateTime(new java.util.Date());			
			domReferral.setClockId("MAXIMS_1");
			domReferral.setReferralType(getDomainFactory().getLookupInstance(ReferralType.INTERNAL.getId()));
			
			 // WDEV-23419  Include user Id as part of external referral key
			int userId=0;
			ims.framework.interfaces.IAppUser user = super.getLoggedInUser();
			if (user != null)
				userId = user.getUserId();
			domReferral.setExtReferralKey("IMS_" + userId + "_" + new java.util.Date().getTime()); // WDEV-23419 Include UserId

			domReferral.setPatient((ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, referral.getPatient().getID_Patient()));

			getDomainFactory().save(domReferral);

			journey.setReferral(new ReferralRefVo(domReferral.getId(), domReferral.getVersion()));

			journey.setStartDate(new Date());
			journey.setExtReferralKey(domReferral.getExtReferralKey());

			// Services specialty - if not set then use Emergency
			journey = pathwayImp.createPatientJourney(journey, null, admission.getSpecialty(), null,null);


			return journey;
		} 
		catch (ClassNotFoundException exception)
		{
			// Log the exception in application log
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Class Cast exception has occured.Please check log file for: " + new DateTime().toString(DateTimeFormat.STANDARD, true) + " timestamp.");
			return null;
		}
		catch (DomainInterfaceException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Domain Interface Exception occurred creating patient journey - " + e.getMessage());
			return null;
		} 
		catch (StaleObjectException e) 
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Stale Object Exception occurred creating patient journey - " + e.getMessage());
			return null;
		}
	}

	private RTTStatusEventMapVo getRTTStatusEventMap(RTTStatusPoint rttStatusPoint)
	{
		if(rttStatusPoint == null)
			return null;

		String query = "select rttMap from RTTStatusEventMap as rttMap left join rttMap.currentRTTStatus as rtt where rtt.id = :RTTStatusPoint and rttMap.event is not null and rttMap.active = 1 and rttMap.encounterType is null ";
		List<?> listRTTMap = getDomainFactory().find(query, new String[] {"RTTStatusPoint"}, new Object[] {rttStatusPoint.getId()});

		if(listRTTMap != null && listRTTMap.size() > 0 && listRTTMap.get(0) instanceof RTTStatusEventMap)
		{
			return RTTStatusEventMapVoAssembler.create((RTTStatusEventMap) listRTTMap.get(0));
		}

		return null;
	}

	// WDEV-23646 - Ensure the correct event Date Time is used when creating a new RTT Status
	private PathwayRTTStatus createPathwayRTTStatus(CatsReferral domCats, int rttStatusCode, java.util.Date eventDateTime) // WDEV-18617
	{
		if(!ConfigFlag.DOM.RTT_STATUS_POINT_FUNCTIONALITY.getValue())
			return null;

		if(domCats == null)
			return null;

		RTTStatusPoint rttStatusPoint =	getRTTStatusPoint(rttStatusCode);

		Object mos = getMosUser();
		MemberOfStaff doMos = null;

		if(mos instanceof MemberOfStaffLiteVo)
		{
			doMos = MemberOfStaffLiteVoAssembler.extractMemberOfStaff(getDomainFactory(), (MemberOfStaffLiteVo) mos);
		}

		PathwayRTTStatus pathwayRTTStatus = new PathwayRTTStatus();
		pathwayRTTStatus.setRTTStatus(rttStatusPoint);
		pathwayRTTStatus.setStatusBy(doMos);
		pathwayRTTStatus.setStatusDateTime(eventDateTime);
		pathwayRTTStatus.setSetting("I");

		if(domCats.getJourney() != null && domCats.getJourney().getCurrentClock() != null)
		{
			domCats.getJourney().getCurrentClock().setCurrentRTTStatus(pathwayRTTStatus);

			if(domCats.getJourney().getCurrentClock().getRTTStatusHistory() == null)
				domCats.getJourney().getCurrentClock().setRTTStatusHistory(new java.util.ArrayList());

			domCats.getJourney().getCurrentClock().getRTTStatusHistory().add(pathwayRTTStatus);
		}

		return pathwayRTTStatus;
	}

	private RTTStatusPoint getRTTStatusPoint(int nationalCode)
	{
		String query = "select rtt from RTTStatusPoint as rtt where rtt.nationalCode = :NationalCode";

		List<?> rttList = getDomainFactory().find(query, new String[] {"NationalCode"}, new Object[] {nationalCode});

		if(rttList != null && rttList.size() > 0 && rttList.get(0) instanceof RTTStatusPoint)
		{
			return (RTTStatusPoint) rttList.get(0);
		}

		return null;
	}

	/**
	 * saveAdmission - save AdmissionDetail record linked to PasEvent(new) and saveInpatientEpisode
	 *
	 * 1) save Admission Detail
	 * 2) save Inpatient Episode
	 * 3) update PendingElectiveAdmission or PendingEmergencyAdmission 
	 * 4) make DTO call to inpat - action admit only if not already on PAS(waiting area patient)
	 * 5) a)Create CareSpell,CareContext and EpisodeOfCare or b)Use selected Episode
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	//WDEV-23376 - start here
	public void saveAdmissionAndUpdateList(AdmissionDetailVo admissionDetail, BedSpaceStateLiteVo voBedSpaceStateLite,
			CareSpellAdmitVo careSpell, CatsReferralEmergencyAdmissionVo referral,
			WardStayVo wardStay, ConsultantStayVo voConsStay, 
			PendingElectiveAdmissionAdmitVo voBookedElective, 
			PendingEmergencyAdmissionAdmitVo voEmergency, 
			PendingElectiveAdmissionAdmitVo voPlannedElective, 
			CatsReferralPendingEmergencyNonEDAdmissionListVo pendingEmergencyAdmission, 

			AdmissionType admitType, 

			AdmissionReasonVo admissionReasonVo, 
			WardMixedSexBreachVo wardMixedSexBreachVo, 
			WardBayConfigRefVo wardbayConfigRef, 

			PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException	
			{
		WardBayConfig domWardBayConfig = null;
		if (wardbayConfigRef != null && wardbayConfigRef.getID_WardBayConfig() != null)
		{
			domWardBayConfig = (WardBayConfig) getDomainFactory().getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
		}

		try
		{
			doSaveAdmissionAndUpdateList(admissionDetail, voBedSpaceStateLite,
					careSpell, referral, wardStay, voConsStay, voBookedElective,
					voEmergency, voPlannedElective, pendingEmergencyAdmission,
					admitType, admissionReasonVo, wardMixedSexBreachVo,
					domWardBayConfig, collPatientCaseNoteTransfer);
		}
		catch (DomainInterfaceException ex)
		{
			throw new DomainInterfaceException(ex);
		}
		catch (StaleObjectException staleException)
		{
			System.out.println("Stale Excetion" + staleException.getStaleObject());
			throw new StaleObjectException(staleException.getStaleObject());
		}
		catch (Exception ex)
		{
			DomainObject staleObject = null;
			
			if (ex instanceof DomainRuntimeException && ((DomainRuntimeException)ex).getCause() instanceof StaleObjectStateException)
			{
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'doSaveAdmissionAndUpdateList': " + ex.getMessage());
				
				StaleObjectStateException staleException = (StaleObjectStateException) ((DomainRuntimeException)ex).getCause();

				try
				{
    				Integer id = (Integer) staleException.getIdentifier();
    				String className = staleException.getEntityName();
    				ims.domain.DomainObject domainObject = null;
    				Class domainClass;
					domainClass = Class.forName(className);
					domainObject = getDomainFactory().getDomainObject(domainClass, id);
					throw new StaleObjectException(domainObject);
				}
				catch (ClassNotFoundException e)
				{
					e.printStackTrace();
					throw new StaleObjectException(null);
				}
				
			}
			if (ex instanceof StaleObjectException)
			{
				staleObject = ((StaleObjectException) ex).getStaleObject();
			}

			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'doSaveAdmissionAndUpdateList': " + ex.getMessage());
			throw new StaleObjectException(staleObject);
		}

		//WDEV-20217
		try
		{
			updateOccupiedBedsValue(domWardBayConfig, voBedSpaceStateLite);
		}
		catch (Exception ex)
		{
			super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'updateOccupiedBedsValue' - first try: " + ex.getMessage());;
			ex.printStackTrace(); //just for test - remove

			try
			{
				if (wardbayConfigRef != null && wardbayConfigRef.getID_WardBayConfig() != null)
				{
					domWardBayConfig = (WardBayConfig) getDomainFactory().getDomainObject(WardBayConfig.class, wardbayConfigRef.getID_WardBayConfig());
				}
				updateOccupiedBedsValue(domWardBayConfig, voBedSpaceStateLite);
			}
			catch (Exception ex1)
			{
				ex1.printStackTrace(); // just for testing - remove
				super.createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.ERROR, "Admission Error in method 'updateOccupiedBedsValue' - second try: " + ex1.getMessage());

				throw new StaleObjectException(domWardBayConfig);
			}
		}
	}

	//	public void updateOccupiedBedsForWardAndBay(LocationRefVo ward, LocationRefVo bayOne, LocationRefVo bayTwo) throws StaleObjectException
	//	{
	//		WardView implWardView = (WardView) getDomainImpl(WardViewImpl.class);
	//		implWardView.updateOccupiedBedsForWardAndBay(ward, bayOne, bayTwo);
	//		
	//	}

	private void updateOccupiedBedsForWardAndBay(WardBayConfig wardBayConfig, LocationRefVo bayOne, LocationRefVo bayTwo) throws StaleObjectException
	{
		try
		{
			if (wardBayConfig == null || bayOne == null)
				return;

			// this is a move from one bed to another in the same bay - no need to update the occupied beds
			if (bayOne != null && bayTwo != null && bayOne.getID_Location().equals(bayTwo.getID_Location()))
				return;

			int bayOneOccupiedBeds = 0;
			int bayTwoOccupiedBeds = 0;
			int wardOccupiedBeds = 0;

			if (wardBayConfig != null && wardBayConfig.getBays() != null)
			{
				Iterator<BayConfig> bayIterator = wardBayConfig.getBays().iterator();

				while (bayIterator.hasNext())
				{
					BayConfig wardBay = bayIterator.next();

					if (wardBay == null)
						continue;

					if (wardBay.getBay() != null)
					{
						if (wardBay.getBay().getId().equals(bayOne.getID_Location()))
						{
							bayOneOccupiedBeds = getNumberOfOccupiedBedsInBay(bayOne);

							wardBay.setNumOfOccupiedBeds(bayOneOccupiedBeds);
							wardOccupiedBeds += bayOneOccupiedBeds;
						}
						else if (bayTwo != null && wardBay.getBay().getId().equals(bayTwo.getID_Location()))
						{
							bayTwoOccupiedBeds = getNumberOfOccupiedBedsInBay(bayTwo);

							wardBay.setNumOfOccupiedBeds(bayTwoOccupiedBeds);
							wardOccupiedBeds += bayTwoOccupiedBeds;
						}
					}
					else
						wardOccupiedBeds += wardBay.getNumOfBeds();
				}
			}

			//transfer has been made from 2 bays in the same ward - no need to update the ward occupied beds 
			if ( !(bayOne != null && bayTwo != null))
				wardBayConfig.setNumOfOccupiedBeds(wardOccupiedBeds);

			DomainFactory factory = getDomainFactory();

			factory.save(wardBayConfig);
		}
		catch (Exception e)
		{
			e.printStackTrace();
			throw new StaleObjectException(wardBayConfig);
		}
	}


	private int getNumberOfOccupiedBedsInBay(LocationRefVo bay) throws Exception
	{
		if (bay == null || bay.getID_Location() == null)
			return 0;

		StringBuilder query = new StringBuilder("SELECT COUNT (bedSpace.id) FROM BedSpaceState AS bedSpaceState RIGHT JOIN bedSpaceState.bedSpace AS bedSpace ");
		query.append(" LEFT JOIN bedSpaceState.currentBedStatus AS currentStatus LEFT JOIN currentStatus.bedStatus AS bedStatus ");
		query.append(" LEFT JOIN bedSpaceState.bay AS bay ");

		query.append(" WHERE ");

		query.append(" bay.id = :BAY_ID AND bedStatus.id = :OCCUPIED_BED ");

		long occupiedBeds = getDomainFactory().countWithHQL(query.toString(), new String[] { "BAY_ID", "OCCUPIED_BED" }, new Object[] { bay.getID_Location(), BedStatus.OCCUPIED.getId() });

		return (int) occupiedBeds;
	}


	private void doSaveAdmissionAndUpdateList(
			AdmissionDetailVo admissionDetail,
			BedSpaceStateLiteVo voBedSpaceStateLite,
			CareSpellAdmitVo careSpell,
			CatsReferralEmergencyAdmissionVo referral,
			WardStayVo wardStay,
			ConsultantStayVo voConsStay,
			PendingElectiveAdmissionAdmitVo voBookedElective,
			PendingEmergencyAdmissionAdmitVo voEmergency,
			PendingElectiveAdmissionAdmitVo voPlannedElective,
			CatsReferralPendingEmergencyNonEDAdmissionListVo pendingEmergencyAdmission,
			AdmissionType admitType, AdmissionReasonVo admissionReasonVo,
			WardMixedSexBreachVo wardMixedSexBreachVo,
			WardBayConfig wardbayConfigRef,
			PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer)
	throws UniqueKeyViolationException, StaleObjectException,
	DomainInterfaceException,DTODomainInterfaceException
	{
		if(admissionDetail == null)
			throw new CodingRuntimeException("admissionDetail is mandatory in method saveAdmission");
		if(!admissionDetail.isValidated())
			throw new CodingRuntimeException("admissionDetail has not been validated in method saveAdmission");

		DomainFactory factory = getDomainFactory();
		HashMap admissionMap = new HashMap();
		AdmissionDetail doAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(factory, admissionDetail, admissionMap);

		//already on PAS ie pas Admission previously worked and AdmissionDetail record instantiated (Waiting Area patient)
		boolean isAdmittedOnPAS = false;
		if(doAdmissionDetail.getId() != null)
			isAdmittedOnPAS  = true;

		PendingElectiveAdmissionAdmitVo voElective = null;
		boolean isMaternity = false;

		//WDEV-18774
		if (AdmissionType.EMERGENCY.equals(admitType) && Boolean.TRUE.equals(admissionDetail.getIsMaternity()))
			isMaternity = true;

		if (admitType != null && ( ! admitType.equals(AdmissionType.EMERGENCY)))
		{
			if(admitType.equals(AdmissionType.BOOKED))
				voElective  = voBookedElective;
			else if(admitType.equals(AdmissionType.PLANNED))
				voElective = voPlannedElective;

			if(voElective.getIsMaternityIsNotNull())
				isMaternity = voElective.getIsMaternity();
		}

		doAdmissionDetail.getPasEvent().setConsultant(doAdmissionDetail.getConsultant());
		doAdmissionDetail.getPasEvent().setSpecialty(doAdmissionDetail.getSpecialty());
		doAdmissionDetail.getPasEvent().setPASSpecialty(doAdmissionDetail.getPasEvent() != null ? doAdmissionDetail.getPasEvent().getPASSpecialty() : null);
		doAdmissionDetail.getPasEvent().setLocation(doAdmissionDetail.getAdmissionWard());

		//WDEV-8403
		if(doAdmissionDetail.getPasEvent().getPatient() != null)
			doAdmissionDetail.getPasEvent().getPatient().setWard(doAdmissionDetail.getAdmissionWard());

		//WDEV-10421		
		if(getLoggedInUser() != null)
			doAdmissionDetail.setAdmittingUser((AppUser) getDomainFactory().getDomainObject((AppUserRefVo) getLoggedInUser()));


		//WDEV-10964 - needed as patient replicate sorts the identifiers and tries to update the collection causing sql errors
		doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().clear();
		List lst = PatientIdAssembler.extractPatientIdList(factory, admissionDetail.getPasEvent().getPatient().getIdentifiers());
		doAdmissionDetail.getPasEvent().getPatient().setIdentifiers(lst);


		if (wardbayConfigRef != null)
		{	
			ConfigChange configChange = wasConfigChanged(voBedSpaceStateLite, wardbayConfigRef);
			//WDEV-23279
			//			if (configChange != null)
			if (configChange != null && !ConfigChange.OTHER.equals(configChange)) //WDEV-23279
			{	
				throw new UniqueKeyViolationException(buildExceptionMessage(configChange));
			}
		}

		//1)	
		factory.save(doAdmissionDetail);


		// Save (update) the Care Spell
		if (careSpell != null)
		{
			CareSpell domCareSpell = CareSpellAdmitVoAssembler.extractCareSpell(factory, careSpell, admissionMap);
			factory.save(domCareSpell);
		}

		// Save (update) the Cats Referral
		if (referral != null)
		{
			CatsReferral domCatsReferral = CatsReferralEmergencyAdmissionVoAssembler.extractCatsReferral(factory, referral, admissionMap);
			factory.save(domCatsReferral);
		}

		// Get CatsReferral if one exists
		//		if (doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getId() != null)
		//		{
		//			CatsReferral catsReferral =	(CatsReferral) factory.findFirst("SELECT cats FROM CatsReferral AS cats LEFT JOIN cats.careContext AS context LEFT JOIN context.pasEvent AS pas WHERE pas.id = :PASID AND (cats.isRIE = 0 or cats.isRIE is null)", "PASID", doAdmissionDetail.getPasEvent().getId());
		//			if (catsReferral != null)
		//			{
		//				catsReferral.getAdmissions().add(doAdmissionDetail);
		//				factory.save(catsReferral);
		//			}
		//		}	

		//WDEV-20563 update the ward booking if one exists
		//WDEV-22794 status update no longer required
		if (admissionDetail.getWardAppointment() != null)
		{
			BookAppointmentForWardAttendersVo appointment = admissionDetail.getWardAppointment();

			/*appointment.getApptStatusHistory().add(appointment.getCurrentStatusRecord());

			Appointment_StatusVo voApptStat = new Appointment_StatusVo();
			voApptStat.setStatus(Status_Reason.ADMITTED);
			//WDEV-22685 -- starts here
			voApptStat.setStatusChangeDateTime(admissionDetail.getAdmissionDateTime());
			voApptStat.setApptDate(appointment.getAppointmentDate());
			voApptStat.setApptTime(appointment.getApptStartTime());

			appointment.setCurrentStatusRecord(voApptStat);					
			appointment.setApptStatus(Status_Reason.ADMITTED);*/

			if (doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getId() != null)
				appointment.setPASEvent(new PASEventRefVo(doAdmissionDetail.getPasEvent().getId(), doAdmissionDetail.getPasEvent().getVersion()));
			//WDEV-22685 - ends here

			Booking_Appointment doAppt = BookAppointmentForWardAttendersVoAssembler.extractBooking_Appointment(factory, appointment, admissionMap);

			factory.save(doAppt);
		}

		//WDEV-20371
		if (admissionDetail.getPendingEmergencyTheatre() != null)
		{
			PendingEmergencyTheatreForAdmitVo pendingEmergencyTheatre = admissionDetail.getPendingEmergencyTheatre();

			pendingEmergencyTheatre.setCurrentStatus(PendingEmergencyTheatreStatus.ADMITTED);

			PendingEmergencyTheatre doPET = PendingEmergencyTheatreForAdmitVoAssembler.extractPendingEmergencyTheatre(factory, pendingEmergencyTheatre, admissionMap);
			doPET.setAdmissionDetail(doAdmissionDetail);
			factory.save(doPET);
		}

		//2)
		InpatientEpisode doInpatEpis = null;
		if(!isAdmittedOnPAS)
			doInpatEpis = new InpatientEpisode();
		else
		{
			//get existing InpatientEpisode from DB (WDEV-7676)
			List episodes = factory.find("from InpatientEpisode inpatEpis left join fetch inpatEpis.bed as bedspace  where inpatEpis.pasEvent.id = '" + doAdmissionDetail.getPasEvent().getId() + "' and bedspace is null" );
			if(episodes != null && episodes.size() == 1)
				doInpatEpis = (InpatientEpisode) episodes.get(0);
		}
		if(doInpatEpis == null) //http://jira/browse/WDEV-22615 cant find one create one
		{
			doInpatEpis = new InpatientEpisode();
		}

		if(doInpatEpis == null)
			throw new DomainInterfaceException("Data Error occurred in Admission - no inpatient episode");

		doInpatEpis.setPasEvent(doAdmissionDetail.getPasEvent());
		doInpatEpis.setAdmissionDateTime(doAdmissionDetail.getAdmissionDateTime());
		doInpatEpis.setEstDischargeDate(doAdmissionDetail.getEstDischargeDate());
		doInpatEpis.setWardType(doAdmissionDetail.getWardType());
		doInpatEpis.setIsMaternityInpatient(isMaternity);

		if(wardStay != null)
			doInpatEpis.getWardStays().add(WardStayVoAssembler.extractWardStay(factory, wardStay, admissionMap));
		if(voConsStay != null)
			doInpatEpis.getConsultantStays().add(ConsultantStayVoAssembler.extractConsultantStay(factory, voConsStay, admissionMap));

		BedSpaceState doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(factory, voBedSpaceStateLite, admissionMap);	
		if(doBedSpaceState != null)
		{
			doBedSpaceState.setInpatientEpisode(doInpatEpis);	
			doInpatEpis.setBed(doBedSpaceState);
		}
		//wdev-14784
		if( wardStay != null && wardStay.getWardIsNotNull() && ConfigFlag.UI.VTE_RISK_ASSESSMENT_FUNCTIONALITY.getValue() == true) //wdev-15602
		{
			Location doloc = getLocation(wardStay.getWard().getID_Location(), factory);
			if(	doloc != null && !Boolean.TRUE.equals(doloc.isVTEAsessmentNotRequired()))
			{
				doInpatEpis.setVTEAssessmentStatus(getDomLookup(VTEAsessmentStatus.REQUIRED));
			}
		}
		//WDEV-12991
		doInpatEpis.setReasonForAdmission(doAdmissionDetail.getReasonForAdmission());

		// WDEV-19733 - Move code from bottom of method. Was causing SOE.
		// WDEV-19481 - Trigger creation of A01 Admission HL7 message
		InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpatEpis);

		ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);

		if(inpatEpisodeVo.getPasEvent()!=null)
		{
			adtimpl.triggerAdmissionEvent(new PASEventRefVo(doInpatEpis.getPasEvent().getId(), doInpatEpis.getPasEvent().getVersion()));
		}

		//WDEV-19680
		adtimpl.vteOnAdmission(doInpatEpis, doAdmissionDetail.getPasEvent().getPatient(), !AdmissionType.EMERGENCY.equals(admitType));

		factory.save(doInpatEpis);

		if(doBedSpaceState != null)
			doAdmissionDetail.setBed(doBedSpaceState.getBedSpace());

		//WDEV-10593 - only set this once
		if(doAdmissionDetail.getAdmissionTransactionDateTime() == null)
			doAdmissionDetail.setAdmissionTransactionDateTime(new DateTime().getJavaDate());

		factory.save(doAdmissionDetail);

		//wdev-20362 - Update any active PatientCaseNotes to new location
		updatePatientCaseNotesTransfers(collPatientCaseNoteTransfer);

		//WDEV-20224
		if (admissionReasonVo != null) 
		{
			if (Boolean.TRUE.equals(admissionReasonVo.getIsOohAllocationValidated()))
			{
				BayTimesAdmissionBreachedVo bayTimeAdmission = populateBayTimesBreachedRecord(admissionDetail,voBedSpaceStateLite,admissionReasonVo);

				BayTimesAdmissionBreach bayTimesBreachedDO = BayTimesAdmissionBreachedVoAssembler.extractBayTimesAdmissionBreach(factory, bayTimeAdmission, admissionMap); 
				factory.save(bayTimesBreachedDO);				
			}

			if (Boolean.TRUE.equals(admissionReasonVo.getIsGenderSpecificBayValidated()))
			{
				if (voBedSpaceStateLite != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(voBedSpaceStateLite.getBay());
					if (bayConfig != null)
					{		
						bayConfig.setTemporaryBayGender(voBedSpaceStateLite.getProvisionalBayGender());

						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig, admissionMap);

						factory.save(bayConfigDO);
					}				
				}								
			}
			if (Boolean.TRUE.equals(admissionReasonVo.getIsMixingGenderBayValidated()))
			{				
				if (wardMixedSexBreachVo != null)
				{	
					WardMixedSexBreach wardMixedAdmissionDO = WardMixedSexBreachVoAssembler.extractWardMixedSexBreach(factory, wardMixedSexBreachVo, admissionMap);

					if (getDomLookup(Sex.MALE).equals(doAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setMalePatients(wardMixedSexBreachVo.getMalePatientsIsNotNull() ? wardMixedSexBreachVo.getMalePatients().intValue() + 1 : 1);
					if (getDomLookup(Sex.FEMALE).equals(doAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setFemalePatients(wardMixedSexBreachVo.getFemalePatientsIsNotNull() ? wardMixedSexBreachVo.getFemalePatients().intValue() + 1 : 1);

					factory.save(wardMixedAdmissionDO);
				}
				if (voBedSpaceStateLite != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(voBedSpaceStateLite.getBay());
					if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
					{		
						if (!bayConfig.getTemporaryBayGender().equals(voBedSpaceStateLite.getProvisionalBayGender()) && !Sex.UNKNOWN.equals(voBedSpaceStateLite.getProvisionalBayGender()))
						{
							bayConfig.setTemporaryBayGender(voBedSpaceStateLite.getProvisionalBayGender());

							BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig, admissionMap);

							factory.save(bayConfigDO);
						}				
					}
				}
			}			
		}
		//WDEV-20224 -- end
		//3)
		if(voElective != null && voElective.getID_PendingElectiveAdmissionIsNotNull())
		{
			PendingElectiveAdmission doPending = (PendingElectiveAdmission) factory.getDomainObject(voElective);
			if(doPending != null)
			{
				doPending.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		else if(voEmergency != null)
		{
			PendingEmergencyAdmission doPending = (PendingEmergencyAdmission) factory.getDomainObject(voEmergency);
			if(doPending != null)
			{
				doPending.setAdmissionStatus(getDomLookup(EmergencyAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		else if(voPlannedElective != null)
		{
			PendingElectiveAdmission doPending = (PendingElectiveAdmission) factory.getDomainObject(voPlannedElective);
			if(doPending != null)
			{
				doPending.setElectiveAdmissionStatus(getDomLookup(ElectiveAdmissionStatus.ADMITTED));
				factory.save(doPending);
			}
		}
		else if (pendingEmergencyAdmission != null && pendingEmergencyAdmission.getRepatriationRequest() != null)
		{
			PendingNoEDEmergencyAdmit doPendingNonEDAdmission = (PendingNoEDEmergencyAdmit) factory.getDomainObject(pendingEmergencyAdmission.getRepatriationRequest());

			// TODO: Request script here if necessary
			//			//WDEV-20944
			//			CatsReferral doCatsRef = (CatsReferral)factory.getDomainObject(pendingEmergencyAdmission);
			//			if (doCatsRef!=null && Boolean.TRUE.equals(doCatsRef.isIsEmergencyReferral()))
			//			{
			//				//WDEV-20944
			//				doCatsRef.getReferralDetails().setEnd18WW(null); 
			//				doCatsRef.getReferralDetails().setEndDateKPI(null);
			//				doCatsRef.getReferralDetails().setEndDateEmailKPI(null);
			//				doCatsRef.getReferralDetails().setEndDatePaperKPI(null);
			//				
			//				doCatsRef.setJourney(null);
			//				doCatsRef.setRTTClockImpact(Boolean.FALSE);
			//			}


			if (doPendingNonEDAdmission != null)
			{
				ims.core.admin.pas.domain.objects.PendingAdmissionStatus admittedStatus = new ims.core.admin.pas.domain.objects.PendingAdmissionStatus();
				admittedStatus.setStatus(getDomLookup(PendingAdmissionStatus.ADMITTED));
				doPendingNonEDAdmission.setAdmissionDetail(doAdmissionDetail);

				doPendingNonEDAdmission.setCurrentStatus(admittedStatus);
				if (doPendingNonEDAdmission.getStatusHistory() == null)
				{
					doPendingNonEDAdmission.setStatusHistory(new ArrayList());
				}
				doPendingNonEDAdmission.getStatusHistory().add(admittedStatus);



				factory.save(doPendingNonEDAdmission);
			}
		}


		// Create Dementia record for admission
		saveDementiaRecord(admissionDetail, admissionMap, factory);


		if(!isAdmittedOnPAS
				&& Boolean.FALSE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
		{
			//4) only admit to pas if record is new 
			Inpat inpatRec = (Inpat)getDTOInstance(Inpat.class);
			inpatRec.DataCollection.add();

			copyAdmissionToDto(inpatRec, doAdmissionDetail, voElective, admitType);
			Result res = inpatRec.executeAction("ADMIT");

			if (res != null && res.getId() < 0 )
			{
				if (res.getId() == -5)
					throw new DomainInterfaceException("Error occurred Admitting Patient to PAS " + res.getMessage());
				else 
					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS " + res.getMessage());	
			}
			else
			{
				if (inpatRec.getLastResultData() == null) {
					throw new DTODomainInterfaceException(res.getId(), "Error occurred Admitting Patient to PAS : no result data from PAS");
				}

				//WDEV-9663
				doAdmissionDetail.getPasEvent().setPasEventId("I_" +  inpatRec.getLastResultData().getValue("DSPN"));
				doAdmissionDetail.getPasEvent().setPasEpisodeId(inpatRec.getLastResultData().getValue("DSPN"));  // WDEV-12588
				factory.save(doAdmissionDetail);
			}
		}
	}

	private void updateOccupiedBedsValue(WardBayConfig domWardBayConfig, BedSpaceStateLiteVo voBedSpaceStateLite) throws StaleObjectException 
	{
		if (voBedSpaceStateLite == null)
			return;
		updateOccupiedBedsForWardAndBay(domWardBayConfig, voBedSpaceStateLite.getBay(), null);
	}
	//WDEV-23376  - ends here
	private void updatePatientCaseNotesTransfers(PatientCaseNoteTransferVoCollection collPatientCaseNoteTransfer) throws StaleObjectException
	{
		if (collPatientCaseNoteTransfer != null)
		{
			CaseNoteTransfer implCaseNoteTransfer = (CaseNoteTransfer) getDomainImpl(CaseNoteTransferImpl.class);
			for (int i = 0; i < collPatientCaseNoteTransfer.size(); i++)
			{
				implCaseNoteTransfer.saveTransfer(collPatientCaseNoteTransfer.get(i), null, null);
			}
		}
	}

	public PatientCaseNoteVoCollection getCaseNoteFolders(PatientRefVo patientRef, LocationRefVo locationRef)
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.getCaseNoteFolders(patientRef, locationRef);
	}

	private String buildExceptionMessage(ConfigChange configChange)
	{	
		//WDEV-23279
		//		if (ConfigChange.OTHER.equals(configChange))
		//			return ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue();
		//WDEV-23279

		return "Current "  + (ConfigChange.BAY_BLOCKED.equals(configChange) || ConfigChange.BAY_CLOSED.equals(configChange) ? "bay" : "ward") + " has been " + (ConfigChange.BAY_BLOCKED.equals(configChange) || ConfigChange.WARD_BLOCKED.equals(configChange) ? "blocked" : "closed") +  " by another user. The screen will be refreshed.";
	}

	private ConfigChange wasConfigChanged(BedSpaceStateLiteVo voBedSpaceStateLite, WardBayConfig wardbayConfigRef)
	{
		if (wardbayConfigRef == null)
			return null;

		DomainFactory factory = getDomainFactory();

		if (voBedSpaceStateLite != null && voBedSpaceStateLite.getBayIsNotNull())
		{
			BayConfig bayConfig = getBayConfig(voBedSpaceStateLite.getBay(), wardbayConfigRef);
			if (bayConfig != null)
			{
				if (getDomLookup(WardBayStatus.CLOSED).equals(bayConfig.getBayStatus()))
					return ConfigChange.BAY_CLOSED;

				if (getDomLookup(WardBayStatus.BLOCKED).equals(bayConfig.getBayStatus()))
					return ConfigChange.BAY_BLOCKED;
			}

		}

		if (getDomLookup(WardBayStatus.CLOSED).equals(wardbayConfigRef.getWardStatus()))
			return ConfigChange.WARD_CLOSED;

		if (getDomLookup(WardBayStatus.BLOCKED).equals(wardbayConfigRef.getWardStatus()))
			return ConfigChange.WARD_BLOCKED;

		//WDEV-23279
		//			if (configDO.getVersion() > wardbayConfigRef.getVersion_WardBayConfig())
		//				return ConfigChange.OTHER;
		//WDEV-23279
		return null;
	}

	private BayConfig getBayConfig(LocationLiteVo bay, WardBayConfig configDO)
	{
		if (configDO != null && configDO.getBays() != null)
		{
			Iterator<BayConfig> bayIterator = configDO.getBays().iterator();

			while (bayIterator.hasNext())
			{
				BayConfig bayDO = bayIterator.next();
				if (bayDO != null && bayDO.getBay().getId().equals(bay.getID()))
					return bayDO;

			}
		}
		return null;
	}

	private BayTimesAdmissionBreachedVo populateBayTimesBreachedRecord(AdmissionDetailVo admissionDetail, BedSpaceStateLiteVo voBedSpaceStateLite, AdmissionReasonVo admissionReasonVo)
	{
		BayTimesAdmissionBreachedVo voBreach = new BayTimesAdmissionBreachedVo();

		voBreach.setAdmissionDateTime(admissionDetail.getAdmissionDateTime());
		voBreach.setWard(admissionDetail.getWard());
		if (voBedSpaceStateLite != null)
			voBreach.setBay(voBedSpaceStateLite.getBay());
		//WDEV-22353
		Object mosUser = getMosUser();
		if (mosUser != null)
			voBreach.setMemberOfStaff((MemberOfStaffLiteVo) mosUser);
		voBreach.setReasonForAdmissionOutOfOpeningHours(admissionReasonVo.getReasonForAdmissionOutOfOpeningHours());
		voBreach.setReasonForAdmissionOutOfOpeningHoursComment(admissionReasonVo.getReasonForAdmissionOohComment());

		return voBreach;
	}

	//wdev-14784
	private Location getLocation(Integer loc, DomainFactory factory)
	{
		if( loc == null)
			return null;

		Location doLocation = (Location) getDomainFactory().getDomainObject(Location.class,loc);
		return doLocation;

	}

	//method now optionally uses an existing episode and carespell or will create new as previously
	private void createOrSaveCareSpell(DomainFactory factory, AdmissionDetail doAdmissionDetail) throws StaleObjectException
	{
		//WDEV-13001 //5) b) Use Selected Episode
		EpisodeOfCare doEpisode = new EpisodeOfCare();
		CareSpell doCareSpell = new CareSpell();
		if(ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
		{
			if(doAdmissionDetail.getAdmissionEpisode() != null)
				doEpisode = doAdmissionDetail.getAdmissionEpisode();

			if(doEpisode.getCareSpell() != null)
				doCareSpell = doEpisode.getCareSpell();
		}

		doCareSpell.setPatient(doAdmissionDetail.getPasEvent().getPatient());

		//WDEV-13001
		if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
		{	
			doCareSpell.setStartDate(doAdmissionDetail.getAdmissionDateTime());

			doEpisode.setCareSpell(doCareSpell);

			//wdev-14309
			doEpisode.setResponsibleHCP(doAdmissionDetail.getConsultant());

			doEpisode.setRelationship(getDomLookup(CareSpelltoEpisodeRelationship.PRIMARY));
			doEpisode.setSpecialty(doAdmissionDetail.getPasEvent().getSpecialty());
			doEpisode.setStartDate( doAdmissionDetail.getAdmissionDateTime());
			//wdev-14309
		}

		//WDEV-13001
		if(!ConfigFlag.DOM.ADT_LINK_ADMISSION_TO_EPISODE.getValue())
			doCareSpell.getEpisodes().add(doEpisode);

		CareContext doCareContext = new CareContext();
		doCareContext.setEpisodeOfCare(doEpisode);
		doCareContext.setContext(getDomLookup(ContextType.INPATIENT));
		doCareContext.setStartDateTime(doAdmissionDetail.getAdmissionDateTime());
		doCareContext.setPasEvent(doAdmissionDetail.getPasEvent());
		doCareContext.setResponsibleHCP(doEpisode.getResponsibleHCP());
		doCareContext.setEstimatedDischargeDate(doAdmissionDetail.getEstDischargeDate()); //WDEV-11438

		doCareContext.setCurrentStatus(new CareContextStatusHistory());
		doCareContext.getCurrentStatus().setStatus(getDomLookup(CareContextStatus.OPEN));
		doCareContext.getCurrentStatus().setStatusDateTime(new java.util.Date());

		doEpisode.getCareContexts().add(doCareContext);
		factory.save(doCareSpell);
	}

	public String checkForPatientAlreadyAdmited(PatientRefVo  voPatient)
	{
		if (voPatient == null || voPatient.getID_Patient() == null)
			throw new CodingRuntimeException("voPatient is null or id not provided in method checkForPatientAlreadyAdmited");

		InpatientEpisode doInpatEpis = null;
		DomainFactory factory = getDomainFactory();

		List episodes = factory.find("from InpatientEpisode inpatEpis left join fetch inpatEpis.pasEvent as pe where pe.patient.id = '" + voPatient.getID_Patient() + "'" );
		if(episodes != null && episodes.size() >= 1) 
		{			
			doInpatEpis = (InpatientEpisode) episodes.get(0);		
			String patientName = doInpatEpis.getPasEvent() != null ? doInpatEpis.getPasEvent().getPatient().getName() != null ? doInpatEpis.getPasEvent().getPatient().getName().toString() : "" : "";

			//wdev-13924
			DateTime dtAdmission = null; 
			if (doInpatEpis.getAdmissionDateTime() != null)
				dtAdmission = new DateTime(doInpatEpis.getAdmissionDateTime());

			return "Patient " +  patientName + " was already admitted on " + (dtAdmission != null ? dtAdmission.toString(DateTimeFormat.STANDARD) : "");
		}

		return null;
	}

	private void copyAdmissionToDto(Inpat inpatRec, AdmissionDetail doAdmissionDetail, PendingElectiveAdmissionAdmitVo voElective, AdmissionType admitType) 
	{		
		InpatRecord rec = inpatRec.DataCollection.get(0);

		inpatRec.EditFilter.excludeAll();
		inpatRec.EditFilter.IncludePkey = true;
		inpatRec.EditFilter.IncludeHospnum = true;
		inpatRec.EditFilter.IncludeHcpcode = true;
		inpatRec.EditFilter.IncludeSpcd = true;
		inpatRec.EditFilter.IncludeRescode = true;
		inpatRec.EditFilter.IncludeMors = true;
		inpatRec.EditFilter.IncludeAddt = true;
		inpatRec.EditFilter.IncludeAdtm = true;
		inpatRec.EditFilter.IncludeReas = true;
		inpatRec.EditFilter.IncludeEddt = true;
		inpatRec.EditFilter.IncludeAdmt = true;
		inpatRec.EditFilter.IncludeAdsc = true;
		inpatRec.EditFilter.IncludeCflup = true;
		inpatRec.EditFilter.IncludeChap = true;
		inpatRec.EditFilter.IncludeAmen = true;
		inpatRec.EditFilter.IncludeConf = true;
		inpatRec.EditFilter.IncludeWebadt = true;
		inpatRec.EditFilter.IncludeBtyp = true; //WDEV-10965
		inpatRec.EditFilter.IncludeRfcd = true; //WDEV-12587

		//WDEV-12957
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		{
			inpatRec.EditFilter.IncludeStay = true;
			inpatRec.EditFilter.IncludeCflcomm = true;
			inpatRec.EditFilter.IncludeCfl = true;
		}

		//remove from BookedList
		if(admitType != null && !AdmissionType.EMERGENCY.equals(admitType)) //WDEV-18895
		{
			if(doAdmissionDetail.getMethodOfAdmission().equals(getDomLookup(MethodOfAdmission.BOOKED)) && admitType.equals(AdmissionType.BOOKED))
				rec.Plbk = "B";
			else if(doAdmissionDetail.getMethodOfAdmission().equals(getDomLookup(MethodOfAdmission.PLANNED)) && admitType.equals(AdmissionType.PLANNED))
				rec.Plbk = "P";

			inpatRec.EditFilter.IncludeBookremv = true;
			inpatRec.EditFilter.IncludePlbk = true;
			inpatRec.EditFilter.IncludeBookdate = true;
			inpatRec.EditFilter.IncludeBooktime = true;

			rec.Bookremv = "Y";

			if(voElective != null)
			{
				if(voElective.getTCIDateIsNotNull())
					rec.Bookdate = DTOHelper.convertToDtoDate(voElective.getTCIDate().getDate());
				if(voElective.getTCITimeIsNotNull())
					rec.Booktime = voElective.getTCITime().toString(TimeFormat.FLAT4);
			}
		}

		rec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		rec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);
		rec.Hcpcode = getPasMapping(doAdmissionDetail.getConsultant());

		rec.Spcd = DTOHelper.getPasMapping(doAdmissionDetail.getSpecialty());

		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO")
				&& doAdmissionDetail.getPasEvent() != null
				&& doAdmissionDetail.getPasEvent().getPASSpecialty() != null)
			rec.Spcd = DTOHelper.getPasMapping(doAdmissionDetail.getPasEvent().getPASSpecialty());

		rec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		rec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());

		//WDEV-10965 - interim solution
		if(rec.Mors != null)
		{
			if(rec.Mors.equals("M"))
			{
				if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
				{
					if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
						rec.Btyp = "M";
					else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
						rec.Btyp = "F";
					else
						//defaulting Male for unknown sex
						rec.Btyp = "M";
				}
				else
					//defaulting Male for unknown sex
					rec.Btyp = "M";	
			}
			else if(rec.Mors.equals("S"))
				rec.Btyp = "S";
		}

		rec.Addt = DTOHelper.convertToDtoDate(doAdmissionDetail.getAdmissionDateTime());
		rec.Adtm = DTOHelper.convertToDtoTime(doAdmissionDetail.getAdmissionDateTime());
		rec.Reas = doAdmissionDetail.getReasonForAdmission() != null && doAdmissionDetail.getReasonForAdmission().length() > 32 ? doAdmissionDetail.getReasonForAdmission().substring(0, 32) : doAdmissionDetail.getReasonForAdmission(); //Hearts restriction of 32 chars
		rec.Admt = DTOHelper.getPasMapping(doAdmissionDetail.getMethodOfAdmission());
		rec.Adsc = DTOHelper.getPasMapping(doAdmissionDetail.getSourceOfAdmission());
		rec.Cflup = doAdmissionDetail.isUpdateCFL() != null && doAdmissionDetail.isUpdateCFL() ? "Y" : "N";

		//WDEV-12957
		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		{
			rec.Cfl = rec.Rescode;
			rec.Cflcomm = doAdmissionDetail.getCaseFolderComments();
			if(doAdmissionDetail.getAdmissionDateTime() != null && doAdmissionDetail.getEstDischargeDate() != null)
				rec.Stay =  String.valueOf(Date.daysBetween( new Date(doAdmissionDetail.getAdmissionDateTime()), new Date(doAdmissionDetail.getEstDischargeDate())));
		}

		rec.Chap = doAdmissionDetail.isIsChaplainRequired() ? "Y" : "N";
		if(doAdmissionDetail.getEstDischargeDate() != null)
			rec.Eddt = DTOHelper.convertToDtoDate(doAdmissionDetail.getEstDischargeDate());

		//WDEV-8012
		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getSourceOfReferral() != null)
			rec.Rfcd = DTOHelper.getPasMapping(doAdmissionDetail.getPasEvent().getSourceOfReferral());

		rec.Amen = "N";
		rec.Conf = "N";

		//WDEV-7827
		rec.Webadt = "Y";

		//wdev-12661
		if(doAdmissionDetail.getPatientStatus() != null)
		{
			inpatRec.EditFilter.IncludeStat = true; //WDEV-12661
			rec.Stat = DTOHelper.getPasMapping(doAdmissionDetail.getPatientStatus());
		}		
		//WDEV-12587
		if(doAdmissionDetail.getReferringConsultant() != null)
		{
			inpatRec.EditFilter.IncludeRefr = true; //WDEV-12587

			rec.Refr = getPasMapping(doAdmissionDetail.getReferringConsultant());
		}
	}

	private void copyHomeLeaveToDto(Homeleave homeLeaveRec, AdmissionDetail doAdmissionDetail, HomeLeaveVo voHomeLeave) 
	{		
		HomeleaveRecord hlRec = homeLeaveRec.DataCollection.get(0);

		hlRec.Pkey = getPatientIdValue(doAdmissionDetail, PatIdType.PKEY);
		hlRec.Hospnum = getPatientIdValue(doAdmissionDetail, PatIdType.HOSPNUM);

		hlRec.Leavedt = voHomeLeave.getDateOnHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateOnHomeLeave().getDate()) : "";
		hlRec.Leavetm =  voHomeLeave.getTimeOnHomeLeaveIsNotNull() ? voHomeLeave.getTimeOnHomeLeave().toString(TimeFormat.FLAT4) : "";

		hlRec.Exdt = voHomeLeave.getExpectedDateOfReturnIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getExpectedDateOfReturn().getDate()) : "";
		hlRec.Extm = voHomeLeave.getExpectedTimeOfReturnIsNotNull() ? voHomeLeave.getExpectedTimeOfReturn().toString(TimeFormat.FLAT4) : "";

		hlRec.Rescode = doAdmissionDetail.getWard() != null ? doAdmissionDetail.getWard().getExtCode(TaxonomyType.PAS.getID()) : null;
		hlRec.Mors = DTOHelper.getPasMapping(doAdmissionDetail.getWardType());
		if(hlRec.Mors.equals("M"))
		{
			if(doAdmissionDetail.getPasEvent().getPatient().getSex() != null)
			{
				if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.MALE)))
					hlRec.Btyp = "M";
				else if(doAdmissionDetail.getPasEvent().getPatient().getSex().equals(getDomLookup(Sex.FEMALE)))
					hlRec.Btyp = "F";
				else
					//defaulting Male for unknown sex
					hlRec.Btyp = "M";
			}
			else
				//defaulting Male for unknown sex
				hlRec.Btyp = "M";	
		}
		else if(hlRec.Mors.equals("S"))
			hlRec.Btyp = "S";

		hlRec.Returndt = voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? DTOHelper.convertToDtoDate(voHomeLeave.getDateReturnedFromHomeLeave().getDate()) : "";
		hlRec.Returntm = voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString(TimeFormat.FLAT4) : "";

		//		if(ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
		//			hlRec.Cflup = rec.Rescode;

		if (voHomeLeave.getID_HomeLeaveIsNotNull())
			hlRec.Hlfl = "N"; //"N" on an update
		else
			hlRec.Hlfl = "Y"; //"Y" on an insert
		hlRec.Webadt = "Y";				
	}

	private String getPasMapping(Medic consultant) 
	{
		if(consultant == null || consultant.getMos() == null || consultant.getMos().getCodeMappings() == null || consultant.getMos().getCodeMappings().size() == 0)
			return null;

		Iterator it = consultant.getMos().getCodeMappings().iterator();
		while(it.hasNext())
		{
			TaxonomyMap map = (TaxonomyMap) it.next();
			if(map.getTaxonomyName().equals(getDomLookup(TaxonomyType.PAS)))
				return map.getTaxonomyCode();
		}

		return null;
	}

	private String getPatientIdValue(AdmissionDetail doAdmissionDetail, PatIdType type) 
	{
		if(doAdmissionDetail == null)
			return null;

		if(doAdmissionDetail.getPasEvent() != null && doAdmissionDetail.getPasEvent().getPatient() != null && doAdmissionDetail.getPasEvent().getPatient().getIdentifiers() != null)
		{
			Iterator it = doAdmissionDetail.getPasEvent().getPatient().getIdentifiers().iterator();
			while(it.hasNext())
			{
				PatientId patId = (PatientId) it.next();
				if(patId.getType().equals( getDomLookup(type)))
					return patId.getValue();
			}
		}

		return null;
	}

	public TrackingForPendingEmergencyAdmitVoCollection listEmergencyAdmission(LocationRefVo ward) 
	{
		if(ward == null)
			throw new CodingRuntimeException("voLocation is null in method listEmergencyAdmission");

		DomainFactory factory = getDomainFactory();

		// Old query for comparison
		//		List pendingEmergencies = factory.find("from PendingEmergencyAdmission pea where pea.allocatedWard.id = :idWard and ( pea.admissionStatus = :discharged or  pea.admissionStatus = :dta )", new String[]{"idWard", "discharged", "dta"}, new Object[]{voLocation.getID_Location(), getDomLookup(EmergencyAdmissionStatus.DISCHARGED), getDomLookup(EmergencyAdmissionStatus.DTA)});

		StringBuilder query = new StringBuilder("SELECT tracking FROM Tracking AS tracking ");
		query.append(" LEFT JOIN tracking.associatedPendingEmergencyAdmission AS pendEmergency ");
		query.append(" LEFT JOIN pendEmergency.pasEvent AS pas LEFT JOIN pas.patient AS patient ");

		query.append(" WHERE pendEmergency.allocatedWard.id = :WARD_ID ");
		query.append(" AND (pendEmergency.admissionStatus.id = :DISCHARGE_STATUS OR pendEmergency.admissionStatus.id = :DTA_STATUS)");

		query.append(" ORDER BY patient.name.upperSurname, patient.name.upperForename");

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		paramNames.add("WARD_ID");				paramValues.add(ward.getID_Location());
		paramNames.add("DISCHARGE_STATUS");		paramValues.add(EmergencyAdmissionStatus.DISCHARGED.getID());	
		paramNames.add("DTA_STATUS");			paramValues.add(EmergencyAdmissionStatus.DTA.getID());

		//WDEV-21119
		List<?> results = factory.find(query.toString(), paramNames, paramValues);
		if (results == null || results.isEmpty())
			return null;
		TrackingForPendingEmergencyAdmitVoCollection recordsList = TrackingForPendingEmergencyAdmitVoAssembler.createTrackingForPendingEmergencyAdmitVoCollectionFromTracking(results);
		for (TrackingForPendingEmergencyAdmitVo item :recordsList)
		{
			item.setLOS(item.getIntLengthOfStay());
		}
		return recordsList;
	}

	public PendingElectiveAdmissionAdmitVoCollection listPlannedElectiveAdmission(Date dateFrom, Date dateTo, LocationRefVo ward)
	{
		if(dateFrom == null)
			throw new CodingRuntimeException("dateFrom is mandatory in method listPlannedElectiveAdmission");	
		if(dateTo == null)
			throw new CodingRuntimeException("dateTo is mandatory in method listPlannedElectiveAdmission");
		if(ward == null)
			throw new CodingRuntimeException("ward is null in method listPlannedElectiveAdmission");

		DomainFactory factory = getDomainFactory();
		List pendingElectives = factory.find("from PendingElectiveAdmission pea where pea.tCIDate >= :dateFrom and pea.tCIDate <= :dateTo and pea.allocatedWard.id = :idWard and pea.electiveAdmissionStatus = :status and pea.tCIType = :tciType ", new String[]{"dateFrom","dateTo","idWard","status", "tciType"}, new Object[]{dateFrom.getDate(), dateTo.getDate(), ward.getID_Location(), getDomLookup(ElectiveAdmissionStatus.TCI), getDomLookup(TCIType.PLANNED)});
		return PendingElectiveAdmissionAdmitVoAssembler.createPendingElectiveAdmissionAdmitVoCollectionFromPendingElectiveAdmission(pendingElectives);
	}

	public PatientLite_IdentifiersVoCollection searchPatients(PatientFilter filter) throws DomainInterfaceException
	{
		if (filter == null)
			throw new CodingRuntimeException("filter cannot be null in method searchPatients");

		PatientSearch impl = (PatientSearch) getDomainImpl(PatientSearchImpl.class);
		PatientShortCollection patients = impl.searchPatients(filter);

		PatientLite_IdentifiersVoCollection results = new PatientLite_IdentifiersVoCollection();
		for (PatientShort patient : patients)
		{
			results.add(patient.toPatientLite_IdentifiersVo());
		}

		return results;
	}

	public InpatientEpisodeLiteVoCollection listWaitingAreaPatientsByWard(LocationRefVo ward)
	{
		WardView impl = (WardView) getDomainImpl(WardViewImpl.class);
		return impl.listWaitingAreaPatientsByWard(ward);
	}

	public AdmissionDetailVo getAdmissionDetailByPasEvent(PASEventRefVo pasEvent)
	{
		if (pasEvent == null || pasEvent.getID_PASEvent() == null)
			throw new CodingRuntimeException("pasEvent is null or id not provided in method getAdmissionDetailByPasEvent");

		List lstAdmissions = getDomainFactory().find("from AdmissionDetail admDet where admDet.pasEvent.id = " + pasEvent.getID_PASEvent());
		if(lstAdmissions != null && lstAdmissions.size() == 1)
			return AdmissionDetailVoAssembler.create((AdmissionDetail) lstAdmissions.get(0));

		return null;
	}

	public void allocateBed(BedSpaceStateLiteVo bedSpace, InpatientEpisodeLiteVo inpatientEpisode, AdmissionDetailVo admissionDetail, HomeLeaveVo voHomeLeave, AdmissionReasonVo admissionReasonVo, WardMixedSexBreachVo wardMixedBreachVo) throws StaleObjectException, DomainInterfaceException 
	{
		if (inpatientEpisode == null)
			throw new CodingRuntimeException("inpatientEpisode is null in method allocateBed");

		if (admissionDetail == null)
			throw new CodingRuntimeException("admissionDetail is null in method allocateBed");

		BedSpaceState doBedSpaceState = null;
		Sex tempGenderToSet = null;
		WardBayConfig wardBayConfig = null;

		if (bedSpace != null)
		{	
			doBedSpaceState = BedSpaceStateLiteVoAssembler.extractBedSpaceState(getDomainFactory(), bedSpace);
			tempGenderToSet = bedSpace.getProvisionalBayGender();

			if (bedSpace.getWard() != null && bedSpace.getWard().getID_Location() != null)
			{
				wardBayConfig = getWardBayConfigurationByWard(bedSpace.getWard());
			}
		}
		InpatientEpisode doInpatEpis = InpatientEpisodeLiteVoAssembler.extractInpatientEpisode(getDomainFactory(), inpatientEpisode);
		AdmissionDetail doAdmissionDetail = AdmissionDetailVoAssembler.extractAdmissionDetail(getDomainFactory(), admissionDetail);

		DomainFactory factory = getDomainFactory();
		if (doBedSpaceState != null) //WDEV-22380
		{
			doBedSpaceState.setInpatientEpisode(doInpatEpis);	
			doInpatEpis.setBed(doBedSpaceState);
			doInpatEpis.setBedNo(doBedSpaceState.getBedSpace() != null ? doBedSpaceState.getBedSpace().getBedNumber() : null);

			// Set Bed and Bay in current Ward Stay
			WardStay latestWardStay = getLatestWardStay(doInpatEpis);
			if (latestWardStay != null)
			{
				latestWardStay.setBedSpace(doBedSpaceState.getBedSpace());
				latestWardStay.setBay(doBedSpaceState.getBay());
			}
		}
		else if (voHomeLeave != null)
		{
			doInpatEpis.setBedNo(null);
			if (doInpatEpis.getBed() != null)
			{	
				String currentBedNo = doInpatEpis.getBed().getBedSpace() != null ? doInpatEpis.getBed().getBedSpace().getBedNumber() : null;
				doInpatEpis.setVacatedBedNumber(currentBedNo);
				doInpatEpis.setBed(null);
			}
		}

		if(voHomeLeave != null)
		{
			for(int i = 0 ; doInpatEpis.getHomeLeaves().size() > 0 && i < doInpatEpis.getHomeLeaves().size() ; i++)
			{
				HomeLeave doHL = (HomeLeave)doInpatEpis.getHomeLeaves().get(i);
				if (doHL != null
						&& doHL.getDateReturnedFromHomeLeave() == null)
				{
					doHL.setDateReturnedFromHomeLeave(voHomeLeave.getDateReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getDateReturnedFromHomeLeave().getDate() : null);
					doHL.setTimeReturnedFromHomeLeave(voHomeLeave.getTimeReturnedFromHomeLeaveIsNotNull() ? voHomeLeave.getTimeReturnedFromHomeLeave().toString() : null);

					doInpatEpis.getHomeLeaves().set(i, doHL);
				}
			}
			doInpatEpis.setIsOnHomeLeave(false);
			doInpatEpis.setDateOnHomeLeave(null);
			doInpatEpis.setTimeOnHomeLeave(null);
			doInpatEpis.setExpectedDateOfReturn(null);
			doInpatEpis.setExpectedTimeOfReturn(null);
			doInpatEpis.setVacatedBedNumber(null);

			//UPDATE PAS THAT NO LONGER ON HOME LEAVE 
			if (ConfigFlag.UI.BED_INFO_UI_TYPE.getValue().equals("CCO"))
			{
				Homeleave hlRec = (Homeleave)getDTOInstance(Homeleave.class);
				hlRec.DataCollection.add();

				copyHomeLeaveToDto(hlRec, doAdmissionDetail, voHomeLeave);

				Result res = hlRec.update();
				if (res != null && res.getId() < 0 )
				{
					if (res.getId() == -5)
						throw new DomainInterfaceException("Error occurred saving Home Leave record to PAS " + res.getMessage());
					else 
						throw new DTODomainInterfaceException(res.getId(), "Error occurred saving Home Leave record to PAS " + res.getMessage());	
				}
			}

			//WDEV-20405 - Trigger creation of A21 PATIENT GOES ON A LEAVE OF ABSENCE HL7 message
			InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpatEpis);
			if(inpatEpisodeVo != null
					&& inpatEpisodeVo.getPasEvent() != null)
			{
				ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
				adtimpl.triggerReturnFromLeaveOfAbsenceEvent(inpatEpisodeVo.getPasEvent());
			} //WDEV-20405
		}

		//WDEV-21619 Ensure that an ADT^A08 UPDATE PATIENT INFORMATION message is generated when the PAS event is
		//			 the allocation of a bed, that is not for HomeLeave event
		// NOTE! This will only occur is the bed space has been assigned a bed number
		if (voHomeLeave == null
				&& doBedSpaceState != null
				&& doBedSpaceState.getBedSpace() != null
				&& doBedSpaceState.getBedSpace().getBedNumber() != null)
		{
			InpatientEpisodeVo inpatEpisodeVo = InpatientEpisodeVoAssembler.create(doInpatEpis);
			if(inpatEpisodeVo != null
					&& inpatEpisodeVo.getPasEvent() != null)
			{
				ADT adtimpl = (ADT) getDomainImpl(ADTImpl.class);
				adtimpl.triggerUpdateAdmissionEvent(inpatEpisodeVo.getPasEvent(),MsgUpdateType.ADMISSION);//http://jira/browse/WDEV-22831
			}
		} //WDEV-21619

		factory.save(doInpatEpis);

		if(doBedSpaceState != null)
			doAdmissionDetail.setBed(doBedSpaceState.getBedSpace());

		factory.save(doAdmissionDetail);


		//WDEV-20217
		try
		{
			updateOccupiedBedsValue(wardBayConfig, bedSpace);
		}
		catch (StaleObjectException ex)
		{
			ex.printStackTrace(); //just for test - remove
			try
			{
				if (bedSpace.getWard() != null && bedSpace.getWard().getID_Location() != null)
				{
					wardBayConfig = getWardBayConfigurationByWard(bedSpace.getWard());
				}
				updateOccupiedBedsValue(wardBayConfig, bedSpace);
			}
			catch (StaleObjectException ex1)
			{
				ex1.printStackTrace(); // just for testing - remove 
			}
		}


		//WDEV-20224
		if (admissionReasonVo != null)
		{
			if (Boolean.TRUE.equals(admissionReasonVo.getIsPrivateBedAllocationValidated()))
			{				
				if (Boolean.TRUE.equals(doBedSpaceState.getBedSpace().isPrivateBed()))
				{
					InpatientEpisode doInpatEpisode = (InpatientEpisode) getDomainFactory().getDomainObject(InpatientEpisode.class, inpatientEpisode.getID_InpatientEpisode());
					WardStay cws = getCurrentWardStay(doInpatEpisode.getWardStays());
					if (cws != null)
					{
						cws.setReasonPrivateBedAllocated(admissionReasonVo.getReasonForPrivateBedAllocation() != null ? getDomLookup(admissionReasonVo.getReasonForPrivateBedAllocation()) : null);
						cws.setReasonPrivateBedAllocatedComment(admissionReasonVo.getReasonForPrivateBedAllocationComment());
					}
					factory.save(doInpatEpisode);
				}			
			}			
			if (Boolean.TRUE.equals(admissionReasonVo.getIsGenderSpecificBayValidated()))
			{
				if (bedSpace != null)
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpace.getBay());
					if (bayConfig != null)
					{		
						bayConfig.setTemporaryBayGender(tempGenderToSet);

						BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(getDomainFactory(), bayConfig);

						factory.save(bayConfigDO);
					}				
				}							
			}
			if (Boolean.TRUE.equals(admissionReasonVo.getIsMixingGenderBayValidated()))
			{				
				if (wardMixedBreachVo != null)
				{	
					WardMixedSexBreach wardMixedAdmissionDO = WardMixedSexBreachVoAssembler.extractWardMixedSexBreach(factory, wardMixedBreachVo);

					if (getDomLookup(Sex.MALE).equals(doAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setMalePatients(wardMixedBreachVo.getMalePatientsIsNotNull() ? wardMixedBreachVo.getMalePatients().intValue() + 1 : 1);
					if (getDomLookup(Sex.FEMALE).equals(doAdmissionDetail.getPasEvent().getPatient().getSex()))
						wardMixedAdmissionDO.setFemalePatients(wardMixedBreachVo.getFemalePatientsIsNotNull() ? wardMixedBreachVo.getFemalePatients().intValue() + 1 : 1);

					factory.save(wardMixedAdmissionDO);
				}
				if (bedSpace != null && inpatientEpisode.getPasEventIsNotNull() && (voHomeLeave == null ||  !Boolean.TRUE.equals(voHomeLeave.getBedRetained())))
				{	
					BayConfigLiteVo bayConfig = getBayConfig(bedSpace.getBay());
					if (bayConfig != null)
					{		
						if ((bayConfig.getTemporaryBayGender() == null || !bayConfig.getTemporaryBayGender().equals(tempGenderToSet)) && !Sex.UNKNOWN.equals(tempGenderToSet))
						{
							bayConfig.setTemporaryBayGender(tempGenderToSet);

							BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);

							factory.save(bayConfigDO);
						}				
					}
				}
			}
		}		
	}
	private void checkAndUpdateBayConfig(DomainFactory factory, BedSpaceStateLiteVo voBedSpacState, Sex tempGenderToSet) throws StaleObjectException
	{
		if (voBedSpacState.getBay() == null || voBedSpacState.getWard() == null)
			return;

		BayConfigLiteVo bayConfig =  getBayConfig(voBedSpacState.getBay());		

		if (bayConfig != null && bayConfig.getTemporaryBayGenderIsNotNull())
		{
			if (bayConfig.getNumOfOccupiedBeds() == null || bayConfig.getNumOfOccupiedBeds() == 0)
				bayConfig.setTemporaryBayGender(null);

			else if (allPatientsGenderMatchBayGender(bayConfig))
			{
				bayConfig.setTemporaryBayGender(Sex.MALE.equals(tempGenderToSet) ? Sex.FEMALE : Sex.MALE);				
			}
			else if (!tempGenderToSet.equals(bayConfig.getTemporaryBayGender()))
			{
				bayConfig.setTemporaryBayGender(tempGenderToSet);
			}
			if (!bayConfig.isValidated())
			{
				String[] err = bayConfig.validate();
				if (err != null)
				{	
					BayConfig bayConfigDO = BayConfigLiteVoAssembler.extractBayConfig(factory, bayConfig);				
					factory.save(bayConfigDO);
				}
			}			
		}
	}

	private boolean allPatientsGenderMatchBayGender(BayConfigLiteVo bayConfig)
	{
		Sex genderToCheck = bayConfig.getTemporaryBayGender();

		if (genderToCheck != null)
		{		
			String hql = "select count(bedspacest.id) from BedSpaceState as bedspacest left join bedspacest.inpatientEpisode as inpat left join inpat.pasEvent as pasEv left join pasEv.patient as pat where bedspacest.bay.id = :BAY and pat.sex.id = :GENDER";

			long count = getDomainFactory().countWithHQL(hql, new String[]{"BAY", "GENDER"}, new Object[] {bayConfig.getBay().getID_Location(), genderToCheck.getID()});

			return (bayConfig.getNumOfOccupiedBedsIsNotNull() && new Integer((int)count).equals(bayConfig.getNumOfOccupiedBeds()));			
		}
		return false;
	}
	private WardStay getCurrentWardStay(Set wardStays)
	{
		if (wardStays == null)
			return null;

		Iterator<?> it = wardStays.iterator();

		while (it.hasNext())
		{
			Object ws = it.next();

			if(ws instanceof WardStay)
			{
				if(((WardStay) ws).getTransferOutDateTime() == null)
					return (WardStay) ws;
			}
		}
		return null;	
	}
	private WardStay getLatestWardStay(InpatientEpisode doInpatEpis)
	{
		if (doInpatEpis.getWardStays() == null)
			return null;

		WardStay latestWardStay = null;

		Iterator iterator = doInpatEpis.getWardStays().iterator();
		while (iterator.hasNext())
		{
			WardStay wardStay = (WardStay) iterator.next();

			if (latestWardStay == null)
			{
				latestWardStay = wardStay;
			}
			else
			{
				if (latestWardStay.getTransferDateTime() != null && wardStay.getTransferDateTime() != null)
				{
					if (latestWardStay.getTransferDateTime().before(wardStay.getTransferDateTime()))
					{
						latestWardStay = wardStay;
					}
				}
			}
		}

		return latestWardStay;
	}

	/**
	 * HEARTS Service Call to Conspc
	 */
	public SpecialtyCollection listSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
	{
		if (consultantMapping == null || consultantMapping.equals(""))
			throw new CodingRuntimeException("consultantMapping cannot be null in method listSpecialtiesFromConSpc");

		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();

		SpecialtyCollection specColl = new SpecialtyCollection();

		Conspc conspc = (Conspc) getDTOInstance(Conspc.class);
		conspc.Filter.clear();
		conspc.Filter.Cons = consultantMapping;
		conspc.list();

		ConspcRecord rec;
		StringBuilder recordMappings = new StringBuilder("");
		int count = conspc.DataCollection.count();
		for (int i = 0; i < count; i++)
		{
			rec = conspc.DataCollection.get(i);
			recordMappings.append("'").append(rec.Spcd).append("'");
			recordMappings.append(((count - (i+1)) > 0 ? "," : ""));			
		}

		if(count > 0)
		{
			List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + Specialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode in (" + recordMappings + ")");
			specColl = constructSpecialtyLookupCollection(specs);
		}

		return specColl;
	}

	public PASSpecialtyCollection listCCOSpecialtiesFromConSpc(String consultantMapping) throws DomainInterfaceException
	{
		if (consultantMapping == null || consultantMapping.equals(""))
			throw new CodingRuntimeException("consultantMapping cannot be null in method listCCOSpecialtiesFromConSpc");

		if (Boolean.TRUE.equals(ConfigFlag.GEN.USE_ELECTIVE_LIST_FUNCTIONALITY.getValue()))
			return null;

		String extSystem = ConfigFlag.DOM.DEMOGRAPHICS_EXT_SYSTEM.getValue();

		PASSpecialtyCollection specColl = new PASSpecialtyCollection();

		Conspc conspc = (Conspc) getDTOInstance(Conspc.class);
		conspc.Filter.clear();
		conspc.Filter.Cons = consultantMapping;
		conspc.list();

		ConspcRecord rec;
		StringBuilder recordMappings = new StringBuilder("");
		int count = conspc.DataCollection.count();
		for (int i = 0; i < count; i++)
		{
			rec = conspc.DataCollection.get(i);
			recordMappings.append("'").append(rec.Spcd).append("'");
			recordMappings.append(((count - (i+1)) > 0 ? "," : ""));			
		}

		if(count > 0)
		{
			List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + PASSpecialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode in (" + recordMappings + ")");
			specColl = constructCCOSpecialtyLookupCollection(specs);
		}
		return specColl;
	}

	private SpecialtyCollection constructSpecialtyLookupCollection(List specs)
	{
		if (specs == null)
			throw new CodingRuntimeException("specs cannot be null in method constructSpecialtyLookupCollection");

		SpecialtyCollection collSpec = new SpecialtyCollection();
		for(java.util.Iterator iterator = specs.iterator(); iterator.hasNext(); ) 
		{
			ims.framework.utils.ImagePath img = null;
			ims.framework.utils.Color color = null;

			ims.domain.lookups.LookupInstance instance = 
				(ims.domain.lookups.LookupInstance) iterator.next();
			if (instance.getImage() != null) 
			{
				img = new ims.framework.utils.ImagePath(instance.getImage().getImageId(), instance.getImage().getImagePath());
			}
			else 
			{
				img = null;
			}
			color = instance.getColor();
			if (color != null) 
				color.getValue();


			Specialty voInstance = new Specialty(instance.getId(),instance.getText(), instance.isActive(), null, img, color);
			Specialty parentVoInstance = voInstance;
			ims.domain.lookups.LookupInstance parent = instance.getParent();
			while (parent != null)
			{
				if (parent.getImage() != null) 
				{
					img = new ims.framework.utils.ImagePath(parent.getImage().getImageId(), parent.getImage().getImagePath());
				}
				else 
				{
					img = null;
				}
				color = parent.getColor();
				if (color != null) 
					color.getValue();

				parentVoInstance.setParent(new Specialty(parent.getId(),parent.getText(), parent.isActive(), null, img, color));
				parentVoInstance = parentVoInstance.getParent();
				parent = parent.getParent();
			}
			LookupMappingVoCollection voMapColl = new LookupMappingVoCollection();
			for(java.util.Iterator iteratorMap = instance.getMappings().iterator(); iteratorMap.hasNext(); ) 
			{
				LookupMapping instanceMap = (LookupMapping) iteratorMap.next();

				voMapColl.add(new LookupMappingVo(instanceMap.getExtSystem(), instanceMap.getExtCode()));
			}

			voInstance.setMappings(voMapColl);

			collSpec.add(voInstance);
		}

		return collSpec;
	}

	private PASSpecialtyCollection constructCCOSpecialtyLookupCollection(List specs)
	{
		if (specs == null)
			throw new CodingRuntimeException("specs cannot be null in method constructCCOSpecialtyLookupCollection");

		PASSpecialtyCollection collSpec = new PASSpecialtyCollection();
		for(java.util.Iterator iterator = specs.iterator(); iterator.hasNext(); ) 
		{
			ims.framework.utils.ImagePath img = null;
			ims.framework.utils.Color color = null;

			ims.domain.lookups.LookupInstance instance = 
				(ims.domain.lookups.LookupInstance) iterator.next();
			if (instance.getImage() != null) 
			{
				img = new ims.framework.utils.ImagePath(instance.getImage().getImageId(), instance.getImage().getImagePath());
			}
			else 
			{
				img = null;
			}
			color = instance.getColor();
			if (color != null) 
				color.getValue();


			PASSpecialty voInstance = new PASSpecialty(instance.getId(),instance.getText(), instance.isActive(), null, img, color);
			PASSpecialty parentVoInstance = voInstance;
			ims.domain.lookups.LookupInstance parent = instance.getParent();
			while (parent != null)
			{
				if (parent.getImage() != null) 
				{
					img = new ims.framework.utils.ImagePath(parent.getImage().getImageId(), parent.getImage().getImagePath());
				}
				else 
				{
					img = null;
				}
				color = parent.getColor();
				if (color != null) 
					color.getValue();

				parentVoInstance.setParent(new PASSpecialty(parent.getId(),parent.getText(), parent.isActive(), null, img, color));
				parentVoInstance = parentVoInstance.getParent();
				parent = parent.getParent();
			}			

			LookupMappingVoCollection voMapColl = new LookupMappingVoCollection();
			for(java.util.Iterator iteratorMap = instance.getMappings().iterator(); iteratorMap.hasNext(); ) 
			{
				LookupMapping instanceMap = (LookupMapping) iteratorMap.next();

				voMapColl.add(new LookupMappingVo(instanceMap.getExtSystem(), instanceMap.getExtCode()));
			}

			voInstance.setMappings(voMapColl);
			collSpec.add(voInstance);
		}

		return collSpec;
	}

	public String getPasMappingFromConsultant(IMos mos)
	{
		//WDEV-9946 undo of changes
		if (mos == null || mos.getIMosId() == null)
			throw new CodingRuntimeException("mos is null or id not provided in method getPasMappingFromConsultant");

		//WDEV-9946 undo of changes
		MemberOfStaff doMos = (MemberOfStaff) getDomainFactory().getDomainObject(MemberOfStaff.class, mos.getIMosId());
		return MemberOfStaffMappingsLiteVoAssembler.create(doMos).getPasCode();
	}

	//WDEV-10908 for replicating if needed
	public Patient getPatient(PatientShort patient) throws StaleObjectException, DomainInterfaceException
	{
		Demographics demographicsImpl = (Demographics) getDomainImpl(DemographicsImpl.class);

		Patient pat = null;
		try
		{
			pat = demographicsImpl.getPatient(patient);
		}
		catch (DomainRuntimeException e)
		{
			throw new DomainInterfaceException(e.getMessage());
		}

		return pat;
	}
	//WDEV-20349 
	private Boolean hasActiveSelfAdmitAlert(PatientRefVo patientRefVo)
	{
		if (patientRefVo == null || patientRefVo.getID_Patient() == null)
			return false;

		String hql = "select count(alert.id) from PatientAlert as alert left join alert.patient as pat left join alert.alertType as aType left join aType.parent as aCategory WHERE (alert.isRIE is null OR alert.isRIE = 0) and aCategory.id = :SELF_ADMIT_ALERT and alert.isCurrentlyActiveAlert = :ACTIVE_ALERT and pat.id = :PATIENT";

		long count = getDomainFactory().countWithHQL(hql, new String[]{"SELF_ADMIT_ALERT","ACTIVE_ALERT", "PATIENT" }, new Object[]{AlertType.SELF_ADMIT_PATIENT.getID(), Boolean.TRUE, patientRefVo.getID_Patient()});

		return count > 0;
	}

	//get all open active episodes and then get the primary diagnosis associated with each
	public EpisodeOfCareWithPrimaryDiagnosisVoCollection listOpenEpisodesForPatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient is null or id not provided in method listOpenEpisodesForPatient");

		EpisodeOfCareWithPrimaryDiagnosisVoCollection  voCollEpisodes = null;

		String hql = "from EpisodeOfCare as epis left join fetch epis.responsibleHCP as hcp left join fetch hcp.mos as mos left join fetch epis.careSpell as cs where epis.endDate is null and cs.patient.id = " + patient.getID_Patient();
		List episodes = getDomainFactory().find(hql);
		if(episodes != null)
		{
			voCollEpisodes = EpisodeOfCareWithPrimaryDiagnosisVoAssembler.createEpisodeOfCareWithPrimaryDiagnosisVoCollectionFromEpisodeOfCare(episodes);
			for(EpisodeOfCareWithPrimaryDiagnosisVo voEpis : voCollEpisodes)
			{

				//get the primary diagnosis if it exists
				String primaryHql = "select distinct primary.diagnosisDescription from CsPrimaryDiagnosis as csp left join csp.diagnosis as primary where (csp.episodeOfCare.id = :episId and csp.isActive = :status)";
				List diagnosisNames = getDomainFactory().find(primaryHql, new String[]{"episId", "status"}, new Object[]{ voEpis.getID_EpisodeOfCare(), Boolean.TRUE});
				if(diagnosisNames != null && diagnosisNames.size() > 0)
				{
					StringBuilder strDisplay = new StringBuilder("");
					int i=0;
					Iterator it = diagnosisNames.iterator();
					while(it.hasNext())
					{
						if(i > 0)
							strDisplay.append(",");	

						strDisplay.append((String)it.next());
						i++;
					}

					if (strDisplay.toString().equals(""))
						strDisplay.append("unknown");

					voEpis.setPrimaryDiagnosisName(" - " + strDisplay + " - ");
				}
				else
					voEpis.setPrimaryDiagnosisName(" - unknown - ");
			}
		}

		return voCollEpisodes;
	}

	public Specialty getSpecialtyMappingFromPASSpecialty(String szMapping) 
	{
		if (szMapping == null || szMapping.equals(""))
			return null;

		List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + Specialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode = '" + szMapping + "'");
		SpecialtyCollection specColl = constructSpecialtyLookupCollection(specs);
		return specColl.size() > 0 ? specColl.get(0) : null;
	}

	public PASSpecialty getPASSpecialtyMappingFromSpecialty(String szMapping) 
	{
		if (szMapping == null || szMapping.equals(""))
			return null;

		List specs = getDomainFactory().find("from LookupInstance lkp join lkp.mappings as map where type = " + PASSpecialty.TYPE_ID + " and map.extSystem = 'PAS' and map.extCode = '" + szMapping + "'");
		PASSpecialtyCollection specColl = constructCCOSpecialtyLookupCollection(specs);
		return specColl.size() > 0 ? specColl.get(0) : null;
	}

	public Specialty getCCOSpecialtyMappingFromPASSpecialty(PASSpecialty pasSpecialty) 
	{
		if (pasSpecialty == null)
			return null;

		String szMapping = null;
		for (int i = 0 ; pasSpecialty.getMappings() != null && i < pasSpecialty.getMappings().size() ; i++)
		{
			if (pasSpecialty.getMappings().get(i).getExtSystem().equals("PAS"))
				szMapping = pasSpecialty.getMappings().get(i).getExtCode();
		}
		if (szMapping != null)
			return getSpecialtyMappingFromPASSpecialty(szMapping);
		else
			return null;
	}

	public InpatientEpisodeLiteVoCollection listHomeLeavesByWard(LocationRefVo ward) 
	{
		if(ward == null || ward.getID_Location() == null)
			throw new CodingRuntimeException("ward is null or id not provide in method listInpatientEpisodeByWard");

		String hql = getHomeLeavesQuery(false, true);//	WDEV-14563

		List<?> inpatEpis = getDomainFactory().find(hql, new String[]{"idWard", "bTRUE","idWard2", "status"}, new Object[]{ward.getID_Location(), Boolean.TRUE, ward.getID_Location(),getDomLookup(TransferStatus.PENDING) });
		return InpatientEpisodeLiteVoAssembler.createInpatientEpisodeLiteVoCollectionFromInpatientEpisode(inpatEpis);
	}

	//	WDEV-14563
	public Boolean hasHomeLeavesByWard(LocationRefVo ward) 
	{
		if(ward == null || ward.getID_Location() == null)
			throw new CodingRuntimeException("ward is null or id not provide in method listInpatientEpisodeByWard");

		String hql = getHomeLeavesQuery(true, true);

		List<?> inpatEpis = getDomainFactory().find(hql, new String[]{"idWard", "bTRUE","idWard2", "status"}, new Object[]{ward.getID_Location(), Boolean.TRUE, ward.getID_Location(),getDomLookup(TransferStatus.PENDING) });

		if(inpatEpis != null && inpatEpis.size() > 0)
		{
			if(((Long) inpatEpis.get(0)) > 0)
				return true;
		}

		return false;
	}

	//	WDEV-14563 //  WDEV-20363
	private String getHomeLeavesQuery(boolean count, boolean withoutBed) 
	{
		String hql = "select " + (count ? "count(inpat.id)" : "inpat")  + " from InpatientEpisode inpat "+ (withoutBed ? "left join inpat.bed as bedsp " : "") +  (!count ? "left join inpat.pasEvent as pasev left join pasev.patient as pat " :  "") + "WHERE (inpat.pasEvent.location.id = :idWard and inpat.isOnHomeLeave = :bTRUE" + (withoutBed ? " and bedsp is null" : "") + 
		" and inpat.pasEvent.patient not in ( select pend.inpatientEpisode.pasEvent.patient from PendingTransfers pend where pend.inpatientEpisode.pasEvent.location.id = :idWard2 and pend.currentStatus = :status ))";

		return hql + (!count ? " order by pat.name.upperSurname asc,pat.name.upperForename asc" : "");
	}

	//WDEV-16062
	public InpatientEpisodeLiteVo getInpatientEpisode(InpatientEpisodeRefVo inpatientRef)
	{
		if(inpatientRef == null)
		{
			throw new CodingRuntimeException("Cannot get InpatientEpisode on null Id.");
		}

		return InpatientEpisodeLiteVoAssembler.create((InpatientEpisode) getDomainFactory().getDomainObject(InpatientEpisode.class, inpatientRef.getID_InpatientEpisode()));
	}

	public BedSpaceStateLiteVo getBedSpaceState(BedSpaceStateRefVo bedRef)
	{
		if(bedRef == null || bedRef.getID_BedSpaceState() == null)
			throw new CodingRuntimeException("Cannot get BedSpaceState on null Id.");

		return BedSpaceStateLiteVoAssembler.create(	(BedSpaceState)	getDomainFactory().getDomainObject(BedSpaceState.class, bedRef.getID_BedSpaceState()));
	}


	public PatientElectiveListBedInfoVoCollection listPatientElective(LocationRefVo ward, Date fromDate, Date toDate,LocationRefVo hospital)
	{
		StringBuilder query = new StringBuilder();
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		query.append("SELECT pel FROM PatientElectiveList AS pel ");
		query.append("LEFT JOIN pel.electiveListStatus AS els LEFT JOIN els.electiveListStatus AS elStatus ");
		query.append("LEFT JOIN pel.tCIDetails AS tci LEFT JOIN tci.tCIWard AS ward ");
		query.append("LEFT JOIN pel.patient AS patient ");

		query.append("WHERE elStatus.id = :TCI_GIVEN AND tci.isActive = 1 AND tci.currentOutcome is null ");
		//paramNames.add("WARD");
		//paramValues.add(ward.getID_Location());
		paramNames.add("TCI_GIVEN");
		paramValues.add(WaitingListStatus.TCI_GIVEN.getId());
		//wdev-19361
		if( hospital != null )
		{
			query.append(" AND tci.tCIHospital.id = :hospitalID");
			paramNames.add("hospitalID");
			paramValues.add(hospital.getID_Location());

		}
		if( ward != null )
		{
			query.append(" AND ward.id = :WARD");
			paramNames.add("WARD");
			paramValues.add(ward.getID_Location());
		}
		//----------
		if (fromDate != null)
		{
			query.append(" AND tci.tCIDate >= :FROM_DATE");
			paramNames.add("FROM_DATE");
			paramValues.add(fromDate.getDate());
		}

		if (toDate != null)
		{
			query.append(" AND tci.tCIDate <= :TO_DATE");
			paramNames.add("TO_DATE");
			paramValues.add(toDate.getDate());
		}

		query.append(" ORDER BY patient.name.surname, patient.name.forename");

		return PatientElectiveListBedInfoVoAssembler.createPatientElectiveListBedInfoVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public PatientElectiveListBedAdmissionVo getPatientElectiveAdmission(PatientElectiveListRefVo patientElectiveList)
	{
		if (patientElectiveList == null || patientElectiveList.getID_PatientElectiveList() == null)
			return null;

		return PatientElectiveListBedAdmissionVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
	}

	public PatientShort getPatientShort(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;

		return PatientShortAssembler.create((ims.core.patient.domain.objects.Patient) getDomainFactory().getDomainObject(ims.core.patient.domain.objects.Patient.class, patient.getID_Patient()));
	}


	public MedicVo getMedic(HcpRefVo hcp)
	{
		if (hcp == null || hcp.getID_Hcp() == null)
			return null;

		String query = "SELECT medic FROM Medic AS medic WHERE medic.id = :ID";

		return MedicVoAssembler.create((Medic) getDomainFactory().findFirst(query, "ID", hcp.getID_Hcp()));
	}

	public Boolean hasPatientElectiveListToCancel(PatientRefVo patient, PatientElectiveListRefVo electiveElist, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return Boolean.FALSE;

		if (service == null || service.getID_Service() == null)
			return Boolean.FALSE;

		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");

		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveElist.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());

		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));

		if (count > 0)
			return Boolean.TRUE;

		return Boolean.FALSE;
	}

	public PatientElectiveListBedAdmissionVoCollection getPatientElectiveListToCancel(PatientRefVo patient, PatientElectiveListRefVo electiveElist, ServiceRefVo service)
	{
		if (patient == null || patient.getID_Patient() == null)
			return null;

		if (service == null || service.getID_Service() == null)
			return null;

		StringBuilder query = new StringBuilder("SELECT pel FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service LEFT JOIN pel.patient AS patient LEFT JOIN pel.tCIDetails AS tci");
		query.append(" WHERE pel.id <> :PEL_ID AND patient.id = :PAT_ID AND service.id = :SERVICE_ID AND tci.isActive = 0");

		ArrayList<String> paramNames = new ArrayList<String>();							ArrayList<Object> paramValues = new ArrayList<Object>();
		paramNames.add("PEL_ID");														paramValues.add(electiveElist.getID_PatientElectiveList());
		paramNames.add("PAT_ID");														paramValues.add(patient.getID_Patient());
		paramNames.add("SERVICE_ID");													paramValues.add(service.getID_Service());

		return PatientElectiveListBedAdmissionVoAssembler.createPatientElectiveListBedAdmissionVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public Boolean isPatientAnInpatient(PatientRefVo patient)
	{
		if (patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("Can not check if patient is an inpatient for invalid record.");

		String query = "SELECT COUNT (ipEp.id) FROM InpatientEpisode AS ipEp LEFT JOIN ipEp.pasEvent AS pas LEFT JOIN pas.patient AS pat WHERE pat.id = :PAT_ID";

		long count = getDomainFactory().countWithHQL(query, new String[] {"PAT_ID"}, new Object[] {patient.getID_Patient()});

		if (count > 0)
			return Boolean.TRUE;

		return Boolean.FALSE;
	}


	public HcpLiteVo getHcpFromIMos(ims.vo.interfaces.IMos iMos)
	{
		if (iMos == null || iMos.getIMosHcpId() == null)
			return null;

		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().getDomainObject(Hcp.class, iMos.getIMosHcpId()));
	}


	public ContractConfigShortVo getContractByCCG(String codeCCG)
	{
		if (codeCCG == null || codeCCG.length() == 0)
			return null;

		String query = "SELECT contract FROM ContractConfig AS contract LEFT JOIN contract.cCGsForContract AS ccgContract WHERE ccgContract.cCGCode = :CCG_CONTRACT AND ccgContract.isActive = 1";

		return ContractConfigShortVoAssembler.create((ContractConfig) getDomainFactory().findFirst(query, "CCG_CONTRACT", codeCCG));
	}


	public String getCodeCCGFromPostalCode(String postCode)
	{
		if (postCode == null || postCode.length() == 0)
			return null;

		postCode = postCode.replace(" ","");	//wdev-18655
		String query = "SELECT ccg FROM CCGPCTPCCodes AS ccg WHERE ccg.postcode = :POST_CODE";
		CCGPCTPCCodes ccgCode = (CCGPCTPCCodes) getDomainFactory().findFirst(query, "POST_CODE", postCode);

		if (ccgCode != null)
			return ccgCode.getCCGCode();

		return null;
	}


	public ServiceLiteVoCollection getServicesBySpecialty(Specialty specialty)
	{
		if (specialty == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		String query = "SELECT serv FROM Service AS serv LEFT JOIN serv.specialty AS serviceSpecialty WHERE serviceSpecialty.id = :SPECIALTY_ID AND serv.isActive = 1";
		paramNames.add("SPECIALTY_ID");
		paramValues.add(specialty.getID());

		return ServiceLiteVoAssembler.createServiceLiteVoCollectionFromService(getDomainFactory().find(query, paramNames, paramValues));
	}

	//wdev-19361
	public LocationRefVo getHospitalLoc(LocationRefVo locRef)
	{
		if( locRef == null || locRef.getID_Location() == null )
			return null;

		DomainFactory factory = getDomainFactory();
		Location doLocation = (Location)factory.getDomainObject(Location.class, locRef.getID_Location());
		return getHospital(doLocation);
	}
	private LocationRefVo getHospital(Location doLocation)
	{
		if( doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return LocationListVoAssembler.create(doLocation);

		while(doLocation.getParentLocation() != null)
		{
			doLocation = doLocation.getParentLocation();
			if( doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return LocationListVoAssembler.create(doLocation);
		}

		return null;
	}
	//---------------------

	//WDEV-19507
	public Boolean hasPatientAppointmentsWithinNextMonth(PatientRefVo patient)
	{
		if(patient == null || patient.getID_Patient() == null)
			throw new CodingRuntimeException("patient parameter is null or id not supplied ");

		DomainFactory factory = getDomainFactory();
		long count = factory.countWithHQL("select COUNT(bookingAppt.id) from Booking_Appointment as bookingAppt where (bookingAppt.patient.id = :idPatient and bookingAppt.apptStatus.id= :statusID and bookingAppt.appointmentDate >= :apptDate1 and bookingAppt.appointmentDate <= :apptDate2 )", 
				new String[]{"idPatient","statusID","apptDate1","apptDate2"}, new Object[]{patient.getID_Patient(), Status_Reason.BOOKED.getID(), new Date().getDate(), new Date().addMonth(1).getDate()});

		if (count > 0)
			return Boolean.TRUE;

		return Boolean.FALSE;
	}

	public void createCaseNoteRequests(PatientElectiveListRefVo patientElectiveList)
	{
		if (patientElectiveList == null || patientElectiveList.getID_PatientElectiveList() == null)
			return;

		PatientElectiveList domPatientElectiveList = (PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList());

		if (domPatientElectiveList.getTCIDetails() == null)
			return;

		TCIForPatientElectiveList domTciDetails = (TCIForPatientElectiveList) getDomainFactory().getDomainObject(TCIForPatientElectiveList.class, domPatientElectiveList.getTCIDetails().getId());

		if (domTciDetails == null)
			return;

		PatientElectiveListTCIVo tci = PatientElectiveListTCIVoAssembler.create(domTciDetails);

		//WDEV-20064
		ElectiveListConfiguration domElectiveListConf = domPatientElectiveList.getElectiveList();

		LocationLiteVo caseNoteFolderLoc=null;

		if (domElectiveListConf!=null)
		{
			ElectiveListConfigurationVo electiveListConf = ElectiveListConfigurationVoAssembler.create(domElectiveListConf);
			caseNoteFolderLoc=getCaseNoteLocAssociatedWithHospital(electiveListConf, tci.getTCIHospital());	
		}



		if (caseNoteFolderLoc!=null && tci.getTCIDate() != null && tci.getTCITime() != null)
		{
			if (tci.getTCIDate().isGreaterThan(new Date()) || (tci.getTCIDate().equals(new Date()) && tci.getTCITime().isGreaterOrEqualThan(new Time())))
			{
				saveAutomatedCaseNoteRequests(domPatientElectiveList.getPatient(), tci, caseNoteFolderLoc);//WDEV-20064
			}
		}
	}

	//WDEV-20064
	private LocationLiteVo getCaseNoteLocAssociatedWithHospital(ElectiveListConfigurationVo electiveList, LocationLiteVo tciHospital)
	{
		if (electiveList==null || electiveList.getListLocations()==null )
			return null;

		for (int i=0;i<electiveList.getListLocations().size();i++)
		{
			if (tciHospital.equals(electiveList.getListLocations().get(i).getListLocation()))
			{
				return electiveList.getListLocations().get(i).getCaseNoteFolderLocation();
			}
		}

		return null;
	}

	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequests(ims.core.patient.domain.objects.Patient patient, PatientElectiveListTCIVo tci, LocationLiteVo caseNoteFolderLoc) //WDEV-20064
	{
		PatientCaseNoteRequestVoCollection savedCaseNotesRequests = null;

		DateTime dateTimeRequired = new DateTime();

		dateTimeRequired.setDateTime(tci.getTCIDate(), tci.getTCITime());

		PatientLiteVo patientLite = new PatientLiteVo(patient.getId(),patient.getVersion());

		MemberOfStaffLiteVo mos = tci.getTCIConsultant() != null && tci.getTCIConsultant().getMos() != null ?  tci.getTCIConsultant().getMos() : (MemberOfStaffLiteVo) getMosUser();

		try
		{
			savedCaseNotesRequests = saveAutomatedCaseNoteRequest(patientLite, mos, caseNoteFolderLoc, dateTimeRequired, tci); //WDEV-20064
		}
		catch (StaleObjectException e)
		{
			e.printStackTrace();
		}
		catch (UniqueKeyViolationException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		catch (DomainInterfaceException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return savedCaseNotesRequests;
	}

	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequest(PatientLiteVo patient, MemberOfStaffLiteVo mos, LocationLiteVo location, DateTime requiredByDate, PatientElectiveListTCIVo tci) throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.saveAutomaticCaseNoteRequests(patient, mos, location, requiredByDate, null, tci);
	}

	//WDEV-19507
	public Boolean hasPatientTCIForSameService(PatientRefVo patientRef, ServiceRefVo serviceRef)
	{

		if (patientRef == null || patientRef.getID_Patient() == null)
			return Boolean.FALSE;

		if (serviceRef == null || serviceRef.getID_Service() == null)
			return Boolean.FALSE;

		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service  LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus LEFT JOIN pel.tCIDetails AS tci ");
		query.append(" WHERE patient.id = :PAT_ID AND service.id = :SERVICE_ID AND eleListStatus.id <> :STATUS_ID AND tci.isActive = 1 ");

		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();

		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("SERVICE_ID");		
		paramValues.add(serviceRef.getID_Service());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());

		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));

		if (count > 0)
			return Boolean.TRUE;

		return Boolean.FALSE;
	}

	//WDEV-20234
	public Boolean hasPatientTCIWithinNextMonth(PatientRefVo patientRef)
	{
		if (patientRef == null || patientRef.getID_Patient() == null)
			return Boolean.FALSE;

		StringBuilder query = new StringBuilder("SELECT COUNT(pel.id) FROM PatientElectiveList AS pel LEFT JOIN pel.electiveList AS el LEFT JOIN el.service AS service  LEFT JOIN pel.patient AS patient LEFT JOIN pel.electiveListStatus AS elStatus LEFT JOIN elStatus.electiveListStatus as eleListStatus LEFT JOIN pel.tCIDetails AS tci ");
		query.append(" WHERE patient.id = :PAT_ID AND eleListStatus.id <> :STATUS_ID AND tci.isActive = 1 AND  tci.tCIDate >= :tciDateFrom and tci.tCIDate <= :tciDateTo ");

		ArrayList<String> paramNames = new ArrayList<String>();	
		ArrayList<Object> paramValues = new ArrayList<Object>();

		paramNames.add("PAT_ID");	
		paramValues.add(patientRef.getID_Patient());
		paramNames.add("STATUS_ID");		
		paramValues.add(WaitingListStatus.REMOVED.getID());

		paramNames.add("tciDateFrom");		
		paramValues.add(new Date().getDate());
		paramNames.add("tciDateTo");		
		paramValues.add(new Date().addMonth(1).getDate());

		long count = getDomainFactory().countWithHQL(query.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray(new Object[paramValues.size()]));

		if (count > 0)
			return Boolean.TRUE;

		return Boolean.FALSE;
	}

	//WDEV-20181
	public ContractServiceLocationsConfigVo getContractServiceLocConf(ContractConfigRefVo contractRef, ServiceRefVo serviceRef)
	{
		if (contractRef==null || serviceRef==null)
		{
			return null;
		}

		String sql="select serviceLoc from ContractConfig as contractConf left join contractConf.serviceLocations as serviceLoc where contractConf.id = :ContractID and serviceLoc.service.id = :ServiceID" ;

		List <?>  listServiceLoc=getDomainFactory().find(sql,new String[]{"ContractID", "ServiceID"}, new Object[]{contractRef.getID_ContractConfig(), serviceRef.getID_Service()}) ;

		if (listServiceLoc!=null && listServiceLoc.size()>0)
			return ContractServiceLocationsConfigVoAssembler.create((ContractServiceLocationsConfig)listServiceLoc.get(0));

		return null;
	}



	public BayConfigLiteVo getBayConfig(LocationRefVo bayRef)
	{
		if (bayRef == null || bayRef.getID_Location() == null)
			throw new CodingRuntimeException("The LocationRefVo argument cannot be null" );

		String hql = "select cfg from BayConfig as cfg where cfg.isActive = :ACTIVE and cfg.bay.id = :BAY ";

		BayConfig bayDO = (BayConfig) getDomainFactory().findFirst(hql, new String[]{"ACTIVE",  "BAY"}, new Object[] {Boolean.TRUE, bayRef.getID_Location()});

		if (bayDO == null)
			return null;

		return BayConfigLiteVoAssembler.create(bayDO);
	}


	public PendingEmergencyAdmissionAdmitVo automaticDischarge(PendingEmergencyAdmissionRefVo pendingEmergencyAdmission, DateTime admissionDateTime, HcpLiteVo consultant) throws StaleObjectException
	{
		if (pendingEmergencyAdmission == null || pendingEmergencyAdmission.getID_PendingEmergencyAdmission() == null)
			return null;

		try
		{
			Class<?> emergencyHelper = Class.forName("ims.emergency.helper.EmergencyHelper");
			IEmergencyHelper implEmergencyHelper = (IEmergencyHelper) getDomainImpl(emergencyHelper);
			return implEmergencyHelper.autoDischargeFromEmergencyTracking(pendingEmergencyAdmission, admissionDateTime, consultant);
		}
		catch (ClassNotFoundException e)
		{
			createSystemLogEntry(SystemLogType.APPLICATION, SystemLogLevel.INFORMATION, "Class 'Emergency Helper' not found when attempting to auto-discharge a PendingEmergencyAdmission form ED. This functionality might not be available in the application");

			return PendingEmergencyAdmissionAdmitVoAssembler.create((PendingEmergencyAdmission) getDomainFactory().getDomainObject(PendingEmergencyAdmission.class, pendingEmergencyAdmission.getID_PendingEmergencyAdmission()));
		}
	}


	public TrackingRefVo getTrackingForPendingEmergency(PendingEmergencyAdmissionRefVo pendingEmergency)
	{
		if (pendingEmergency == null || pendingEmergency.getID_PendingEmergencyAdmission() == null)
			return null;

		StringBuilder query = new StringBuilder("SELECT track FROM Tracking AS track LEFT JOIN track.associatedPendingEmergencyAdmission AS pendEmer ");
		query.append(" WHERE ");
		query.append(" pendEmer.id = :EMER_ID ");

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>(); 

		paramNames.add("EMER_ID");			paramValues.add(pendingEmergency.getID_PendingEmergencyAdmission());

		Tracking tracking = (Tracking) getDomainFactory().findFirst(query.toString(), paramNames, paramValues);

		return new TrackingRefVo(tracking.getId(), tracking.getVersion());
	}

	//WDEV-20563
	public BookAppointmentForWardAttendersVoCollection listWardAttenders(LocationRefVo ward, Date date)
	{
		if (ward == null || ward.getID_Location() == null)
			return null;

		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String hql = "select app from Booking_Appointment as app left join app.patient as pat left join app.apptStatus as appStatus left join app.session as sess " +
		"left join sess.schLocation as location where app.isWardAttendance = :wardAttendance  and appStatus.id = :appointmentStatusID and location.id = :locationID" +
		" and pat.id not in ( select pati.id from InpatientEpisode as inpEp left join inpEp.pasEvent as pasEv left join pasEv.patient as pati )" ;

		markers.add("wardAttendance");
		values.add(Boolean.TRUE);

		markers.add("appointmentStatusID");
		values.add(Status_Reason.SEEN.getID());

		markers.add("locationID");
		values.add(ward.getID_Location());

		if (date != null)
		{
			hql += " and app.appointmentDate = :appointmentDate ";
			markers.add("appointmentDate");
			values.add(date.getDate());
		}

		hql += " order by app.apptStartTime asc ";

		return BookAppointmentForWardAttendersVoAssembler.createBookAppointmentForWardAttendersVoCollectionFromBooking_Appointment(factory.find(hql, markers, values));
	}
	//WDEV-20349 
	public Boolean hasPatientActiveSelfAdmitAlert(PatientRefVo patientRefVo)
	{		
		return hasActiveSelfAdmitAlert(patientRefVo);
	}

	public ServiceLiteVoCollection listServices(String name) //WDEV-21581
	{
		ServiceConfiguration domainImpl = (ServiceConfiguration) getDomainImpl(ServiceConfigurationImpl.class);
		return domainImpl.listServices(name, ServiceCategory.CLINICAL, null, true);
	}


	public MedicVoCollection listMedicsForService(ServiceRefVo service, String name)
	{
		if (service == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();


		StringBuilder query = new StringBuilder("SELECT medic FROM Medic AS medic ");
		query.append(" LEFT JOIN medic.mos AS mos LEFT JOIN medic.serviceFunction AS function LEFT JOIN medic.grade AS medicGrade ");
		query.append(" LEFT JOIN function.service AS service ");

		query.append(" WHERE ");

		query.append(" mos.name.surname LIKE :NAME AND service.id = :SERVICE_ID ");

		paramNames.add("NAME");					paramValues.add(name != null ? name + "%" : "%");
		paramNames.add("SERVICE_ID");			paramValues.add(service.getID_Service());


		return MedicVoAssembler.createMedicVoCollectionFromMedic(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public CatsReferralPendingEmergencyNonEDAdmissionListVoCollection listPendingEmergencies(Date dateFrom, Date dateTo, LocationRefVo ward,LocationRefVo hospital)
	{
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT cats FROM CatsReferral AS cats ");
		query.append(" LEFT JOIN cats.repatriationRequest AS repat LEFT JOIN repat.ward AS ward LEFT JOIN repat.hospital AS hospital ");
		query.append(" LEFT JOIN repat.currentStatus AS currentStatus LEFT JOIN currentStatus.status AS status ");
		query.append(" WHERE repat is not null AND status.id = :CREATED ");

		paramNames.add("CREATED");
		paramValues.add(PendingAdmissionStatus.CREATED.getID());

		if (hospital != null && hospital.getID_Location() != null)
		{
			query.append(" AND hospital.id = :HOSP "); 

			paramNames.add("HOSP");
			paramValues.add(hospital.getID_Location());
		}
		if (ward != null && ward.getID_Location() != null)
		{
			query.append(" AND ward.id = :WARD "); 

			paramNames.add("WARD");
			paramValues.add(ward.getID_Location());
		}
		//WDEV-21085
		if (dateFrom != null)
		{
			query.append(" AND (" + (dateFrom != null && dateTo != null ? "(" : "") +  "repat.proposedTransferDate >= :DATEFROM ");
			paramNames.add("DATEFROM");
			paramValues.add(dateFrom.getDate());
		}
		if (dateTo != null)
		{
			query.append(" AND " + (dateFrom == null ? "(" : "") +  "repat.proposedTransferDate < :DATETO ");
			paramNames.add("DATETO");
			Date searchToDate = ((Date) dateTo.clone()).addDay(1);
			paramValues.add(searchToDate.getDate());			
		}
		if (dateFrom != null || dateTo != null)
		{
			query.append((dateFrom != null && dateTo != null ? ")" : "") + " OR repat.proposedTransferDate IS NULL)");
		}
		//WDEV-21085

		return CatsReferralPendingEmergencyNonEDAdmissionListVoAssembler.createCatsReferralPendingEmergencyNonEDAdmissionListVoCollectionFromCatsReferral(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	public CatsReferralPendingAdmissionAdmitVo getPendingEmergencyAdmission(CatsReferralRefVo pendingEmergency)
	{
		if (pendingEmergency == null || pendingEmergency.getID_CatsReferral() == null)
			return null;

		return CatsReferralPendingAdmissionAdmitVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, pendingEmergency.getID_CatsReferral()));
	}
	//WDEV-20669
	public void cancelHomeLeave(BedSpaceStateLiteVo voBedSpaceState,InpatientEpisodeLiteVo voInpEpis) throws DomainInterfaceException,	StaleObjectException
	{
		BedInfoDialog impl = (BedInfoDialog) getDomainImpl(BedInfoDialogImpl.class);
		impl.cancelHomeLeave(null, voInpEpis);
	}

	public PendingEmergencyTheatreForAdmitVoCollection listPendingEmergencyTheatreRecords(Date dateFrom, Date dateTo, LocationRefVo ward,LocationRefVo hospital)
	{

		DomainFactory factory = getDomainFactory();

		String hql = "select PET from PendingEmergencyTheatre as PET left join PET.currentStatus as status left join PET.patient as pat left join PET.expectedHospital as hospital left join PET.expectedWard as ward" +
		" where pat.ward is null and (status.id = :slotToBeBookedStatusID or status.id = :slotBookedStatusID) ";

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Serializable> values = new ArrayList<Serializable>();

		markers.add("slotToBeBookedStatusID");
		values.add(PendingEmergencyTheatreStatus.THEATRE_SLOT_TO_BE_BOOKED.getID());

		markers.add("slotBookedStatusID");
		values.add(PendingEmergencyTheatreStatus.THEATRE_SLOT_BOOKED.getID());

		if (hospital != null)
		{
			hql += (" and hospital.id = :hospitalID ");			
			markers.add("hospitalID");
			values.add(hospital.getID_Location());
		}

		if (ward != null)
		{
			hql += (" and ward.id = :wardID ");

			markers.add("wardID");
			values.add(ward.getID_Location());
		}
		//WDEV-21085
		if (dateFrom != null)
		{
			hql += (" and PET.expectedDateTime >= :DATEFROM");

			markers.add("DATEFROM");
			values.add(new DateTime(dateFrom,new Time(00, 00, 00)).getJavaDate());

		}
		if (dateTo != null)
		{
			hql += (" and PET.expectedDateTime < :DATETO");

			markers.add("DATETO");
			values.add(((Date)dateTo.clone()).addDay(1).getDate());

		}
		//WDEV-21085
		hql += (" order by PET.systemInformation.creationDateTime asc ");			

		return PendingEmergencyTheatreForAdmitVoAssembler.createPendingEmergencyTheatreForAdmitVoCollectionFromPendingEmergencyTheatre(factory.find(hql, markers, values));
	}


	public CareSpellAdmitVo getCareSpellForAdmission(CareContextRefVo careContext)
	{
		if (careContext == null || careContext.getID_CareContext() == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT careSpell ");
		query.append(" FROM CareSpell AS careSpell ");
		query.append(" LEFT JOIN careSpell.episodes AS episode ");
		query.append(" LEFT JOIN episode.careContexts AS carecontext ");

		query.append(" WHERE ");

		query.append(" carecontext.id = :CONTEXT_ID ");

		paramNames.add("CONTEXT_ID");
		paramValues.add(careContext.getID_CareContext());

		return CareSpellAdmitVoAssembler.create((CareSpell) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}


	public CareSpellAdmitVo getCareSpellForAdmission(CatsReferralRefVo referral)
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT carespell ");
		query.append(" FROM CatsReferral AS referral LEFT JOIN referral.careContext AS carecontext ");
		query.append(" LEFT JOIN carecontext.episodeOfCare AS episodeofcare LEFT JOIN episodeofcare.careSpell AS carespell ");

		query.append(" WHERE ");

		query.append(" referral.id = :REFERRAL_ID ");

		paramNames.add("REFERRAL_ID");
		paramValues.add(referral.getID_CatsReferral());

		return CareSpellAdmitVoAssembler.create((CareSpell) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}



	public CatsReferralEmergencyAdmissionVo getReferralForAdmission(CatsReferralRefVo referral)
	{
		if (referral == null || referral.getID_CatsReferral() == null)
			return null;

		return CatsReferralEmergencyAdmissionVoAssembler.create((CatsReferral) getDomainFactory().getDomainObject(CatsReferral.class, referral.getID_CatsReferral()));
	}


	public CareSpellAdmitVo getCareSpellForAdmission(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT careSpell ");
		query.append(" FROM CatsReferral AS referral LEFT JOIN referral.appointments AS appointment ");
		query.append(" LEFT JOIN referral.careContext AS carecontext ");
		query.append(" LEFT JOIN carecontext.episodeOfCare AS episodeofcare ");
		query.append(" LEFT JOIN episodeofcare.careSpell AS careSpell ");

		query.append(" WHERE ");

		query.append(" appointment.id = :APPOINTMENT_ID ");

		paramNames.add("APPOINTMENT_ID");
		paramValues.add(appointment.getID_Booking_Appointment());

		return CareSpellAdmitVoAssembler.create((CareSpell) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}


	public CatsReferralEmergencyAdmissionVo getReferralForAdmission(Booking_AppointmentRefVo appointment)
	{
		if (appointment == null || appointment.getID_Booking_Appointment() == null)
			return null;

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();

		StringBuilder query = new StringBuilder("SELECT referral ");
		query.append(" FROM CatsReferral AS referral LEFT JOIN referral.appointments AS appointment");

		query.append(" WHERE ");

		query.append(" appointment.id = :APPOINTMENT_ID ");

		paramNames.add("APPOINTMENT_ID");
		paramValues.add(appointment.getID_Booking_Appointment());

		return CatsReferralEmergencyAdmissionVoAssembler.create((CatsReferral) getDomainFactory().findFirst(query.toString(), paramNames, paramValues));
	}
	//WDEV-20585
	public PatientWithGPForCCGVo getPatientForCCG(PatientRefVo patientRef)
	{
		if (patientRef == null)
			return null;
		DomainFactory domainFactory = getDomainFactory();

		ims.core.patient.domain.objects.Patient record = (ims.core.patient.domain.objects.Patient) domainFactory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patientRef.getID_Patient());

		if (record != null && Boolean.TRUE.equals(record.isIsActive()))
		{	 
			return PatientWithGPForCCGVoAssembler.create(record);
		}
		return null;
	}

	@Override
	public PatientLite_IdentifiersVo getPatient(PatientRefVo patientRef)
	{
		if (patientRef == null)
			return null;

		DomainFactory domainFactory = getDomainFactory();

		ims.core.patient.domain.objects.Patient record = (ims.core.patient.domain.objects.Patient) domainFactory.getDomainObject(ims.core.patient.domain.objects.Patient.class, patientRef.getID_Patient());

		if (record != null)
		{	 
			return PatientLite_IdentifiersVoAssembler.create(record);
		}

		return null;
	}

	//wdev-21464
	public CareContextShortVo getCareContextShort(PatientRefVo patRef)
	{
		if (patRef == null)
			return null;


		String query = "select p1_1 from InpatientEpisode as i1_1 left join i1_1.pasEvent as p1_1 left join p1_1.patient as p2_1 where (p2_1.id = :patientId)";

		List<?> pasEv = getDomainFactory().find(query, new String[] {"patientId"}, new Object[] {patRef.getID_Patient()});

		if( pasEv != null && pasEv.size() > 0 && pasEv.get(0) instanceof PASEvent)
		{						
			query = "select c1_1 from CareContext as c1_1 left join c1_1.pasEvent as pas_1 where (pas_1.id = :pasEventId)";

			List<?> careContext = getDomainFactory().find(query, new String[] {"pasEventId"}, new Object[] {((PASEvent)pasEv.get(0)).getId()});

			if( careContext != null && careContext.size() > 0 )
			{
				CareContextShortVoCollection tempCol = CareContextShortVoAssembler.createCareContextShortVoCollectionFromCareContext(careContext);
				if( tempCol != null && tempCol.size() > 0)
				{					
					for(int i = 0 ; i < tempCol.size();i++)
					{
						if( tempCol.get(i).getContextIsNotNull() && ContextType.INPATIENT.equals(tempCol.get(i).getContext()))
							return tempCol.get(i);
					}
				}
			}

		}

		return null;
	}

	//WDEV-21767 
	public String getCCGCodeForCurrentLocationOrg(ILocation iCurrentLoc)
	{
		if (iCurrentLoc == null)
		{
			return null;
		}

		Location locationDom = (Location)getDomainFactory().getDomainObject(Location.class, iCurrentLoc.getID());

		Location parentLocation = locationDom.getParentLocation();
		while (parentLocation != null) //Recurse to parent location
		{
			locationDom = parentLocation;
			parentLocation = parentLocation.getParentLocation();
		}

		String ccgCode = null;
		Organisation userOrg = getOrganisationFromLoc(locationDom.getId());

		if (userOrg != null)
		{
			ccgCode = userOrg.getMappingValueOfType(getDomLookup(TaxonomyType.CCG));
		}

		return ccgCode != null ? ccgCode : null;
	}
	private Organisation getOrganisationFromLoc(Integer parentLocationId)
	{
		if (parentLocationId == null)
			return null;

		String query = "select org from Organisation as org left join org.locationSites as loc where loc.id = :locid";
		List<Organisation> orgList = getDomainFactory().find(query, new String[] {"locid"}, new Object[] {parentLocationId});

		if (orgList != null && orgList.size() > 0)
		{
			Organisation org = orgList.get(0);

			return getRootOrg(org);
		}

		return null;
	}

	private Organisation getRootOrg(Organisation org) 
	{
		if (org == null)
			return null;

		if (org.getParentOrganisation() != null)
		{
			return getRootOrg(org.getParentOrganisation());
		}

		return org;
	}

	//WDEV-21973
	public void createCaseNoteFolderIfNone(PatientRefVo patient)
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		impl.createCaseNoteFolderIfNone(patient);
	}

	//WDEV-22380
	public void returnFromHomeLeaveToWardWaitingArea(InpatientEpisodeLiteVo inpatientEpisode, AdmissionDetailVo admissionDetail, HomeLeaveVo voHomeLeave) throws DomainInterfaceException, StaleObjectException
	{
		allocateBed(null, inpatientEpisode, admissionDetail, voHomeLeave, null, null);		
	}

	//http://jira/browse/WDEV-22615
	public AdmissionDetailVo getAdmissionDetails(AdmissionDetailRefVo admissionDetailsRef)
	{
		if(admissionDetailsRef!=null)
		{
			AdmissionDetail admissionDom = (AdmissionDetail)getDomainFactory().getDomainObject(admissionDetailsRef);
			return AdmissionDetailVoAssembler.create(admissionDom);
		}
		return null;
	}

	//WDEV-22735
	public AdmissionDetailVo updateAdmissionDetailWithHealthyLodgerInfo(AdmissionDetailVo admissionDetailToSave,HealthyLodgerVo healthyLodgerDetails) throws StaleObjectException 
	{
		BedInfoDialog impl = (BedInfoDialog) getDomainImpl(BedInfoDialogImpl.class);
		return impl.updateAdmissionDetailWithHealthyLodgerInfo(admissionDetailToSave, healthyLodgerDetails);
	}
	//WDEV-22735 ends here

	@Override
	public Boolean isCaseNoteFolderLocation(PatientRefVo patientRef)
	{
		if(patientRef== null)
			return false;

		AdmitToWard impl = (AdmitToWard)getDomainImpl(AdmitToWardImpl.class);

		return impl.isCaseNoteFolderLocation(patientRef);
	}


	@Override
	public void updateOccupiedBedsForWardAndBay(LocationRefVo ward, LocationRefVo bayOne, LocationRefVo bayTwo) throws StaleObjectException
	{
		WardView implWardView = (WardView) getDomainImpl(WardViewImpl.class);
		implWardView.updateOccupiedBedsForWardAndBay(ward, bayOne, bayTwo);
	}

	private WardBayConfig getWardBayConfigurationByWard(LocationRefVo ward) //WDEV-20328
	{
		if (ward == null || ward.getID_Location() == null)
			throw new CodingRuntimeException("ward is null or id not provided in method getWardBayConfigByWard");

		DomainFactory factory = getDomainFactory();
		WardBayConfig lstWbc = (WardBayConfig) factory.findFirst("from WardBayConfig wbc where wbc.ward.id = '" + ward.getID_Location() + "'");

		return lstWbc;
	}
}
