//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by George Cristian Josan using IMS Development Environment (version 1.80 build 5443.18271)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.core.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.ServiceConfiguration;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.domain.impl.ServiceConfigurationImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.CareSpell;
import ims.core.admin.pas.domain.objects.PASEvent;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.domain.BedAdmissionComponent;
import ims.core.domain.base.impl.BasePendingEmergencyAdmissionRequestImpl;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.resource.people.vo.MemberOfStaffRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareSpellRepatriationVo;
import ims.core.vo.CatsReferralRepatriationRequestVo;
import ims.core.vo.GpToPracticesVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.MemberOfStaffLiteVoCollection;
import ims.core.vo.PasEventRepatriationVo;
import ims.core.vo.PatientWithGPForCCGVo;
import ims.core.vo.ServiceLiteVoCollection;
import ims.core.vo.domain.CareSpellRepatriationVoAssembler;
import ims.core.vo.domain.CatsReferralRepatriationRequestVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.MemberOfStaffLiteVoAssembler;
import ims.core.vo.domain.PasEventRepatriationVoAssembler;
import ims.core.vo.domain.PatientWithGPForCCGVoAssembler;
import ims.core.vo.lookups.MedicGrade;
import ims.core.vo.lookups.ServiceCategory;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;

import java.util.ArrayList;
import java.util.HashMap;


public class PendingEmergencyAdmissionRequestImpl extends BasePendingEmergencyAdmissionRequestImpl
{
	private static final long serialVersionUID = 1L;
	
	//WDEV-21767
	private static final String RESIDENCE_NOT_KNOWN_CCG = "Q99";
	private static final String OVERSEAS_VISITOR_CCG = "X98";


	
	public CatsReferralRepatriationRequestVo save(PasEventRepatriationVo pasEvent, CareSpellRepatriationVo careSpell, CatsReferralRepatriationRequestVo repatriationReferral) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.ForeignKeyViolationException, ims.domain.exceptions.UniqueKeyViolationException
	{
		if (pasEvent == null || careSpell == null || repatriationReferral == null)
			throw new CodingRuntimeException("Cannot save null records.");
		
		if (!pasEvent.isValidated() || !careSpell.isValidated() || !repatriationReferral.isValidated())
			throw new CodingRuntimeException("Records to save are not validated.");
		
		@SuppressWarnings("rawtypes")
		HashMap hashMap = new HashMap();
		
		PASEvent domPasEvent = PasEventRepatriationVoAssembler.extractPASEvent(getDomainFactory(), pasEvent, hashMap);
		getDomainFactory().save(domPasEvent);
		
		CareSpell domCareSpell = CareSpellRepatriationVoAssembler.extractCareSpell(getDomainFactory(), careSpell, hashMap);
		getDomainFactory().save(domCareSpell);
		
		CatsReferral domCatsReferral = CatsReferralRepatriationRequestVoAssembler.extractCatsReferral(getDomainFactory(), repatriationReferral, hashMap);

		//WDEV-21767 Pending Emergency Admissions - Ensure referral has a valid CCG Code (PCT)
		if (domCatsReferral.getReferralDetails().getPCT() == null)
		{
			PatientWithGPForCCGVo patientWithGP = PatientWithGPForCCGVoAssembler.create(domCatsReferral.getPatient());
			String ccgCode = getCCGCode(patientWithGP);
			if (ccgCode != null)
			{
				domCatsReferral.getReferralDetails().setPCT(ccgCode);
			}
		}

		getDomainFactory().save(domCatsReferral);

		return CatsReferralRepatriationRequestVoAssembler.create(domCatsReferral);
	}

	
	public ims.core.vo.CatsReferralRepatriationRequestVo save(ims.core.vo.CatsReferralRepatriationRequestVo repatriationReferral) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.StaleObjectException, ims.domain.exceptions.ForeignKeyViolationException, ims.domain.exceptions.UniqueKeyViolationException
	{
		if (repatriationReferral == null)
			throw new CodingRuntimeException("Cannot save null record.");

		
		if (!repatriationReferral.isValidated())
			throw new CodingRuntimeException("Record to save is not validated.");
		
		
		@SuppressWarnings("rawtypes")
		HashMap map = new HashMap();
		CatsReferral domCats = CatsReferralRepatriationRequestVoAssembler.extractCatsReferral(getDomainFactory(), repatriationReferral, map);
		
		//WDEV-21767 Pending Emergency Admissions - Ensure referral has a valid CCG Code (PCT)
		if (domCats.getReferralDetails().getPCT() == null)
		{
			PatientWithGPForCCGVo patientWithGP = PatientWithGPForCCGVoAssembler.create(domCats.getPatient());
			String ccgCode = getCCGCode(patientWithGP);
			if (ccgCode != null)
			{
				domCats.getReferralDetails().setPCT(ccgCode);
			}
		}
		
		getDomainFactory().save(domCats);
		
		return CatsReferralRepatriationRequestVoAssembler.create(domCats);
	}

	
	//WDEV-21767 Ensure referral has a valid CCG Code ////WDEV-21767 - MAXIMS_10.5.1.0
	public String getCCGCode(PatientWithGPForCCGVo patient)
	{
		if (patient == null)
			return null;

		BedAdmissionComponent bedAdmComponentDomainImpl = (BedAdmissionComponent) getDomainImpl(BedAdmissionComponentImpl.class);
		
		if (!Boolean.TRUE.equals(ConfigFlag.DOM.GP_USE_SURGERIES.getValue()))
		{
			// 1 - Patient.Gp.practices.practice (with isDefault).PCTCode (this is a CCG so no lookup of CCGPCTPCCodes needed) 
			if (patient.getGp() != null && patient.getGp().getPractices() != null)
			{
				for (GpToPracticesVo gpToPractice : patient.getGp().getPractices())
				{
					if (Boolean.TRUE.equals(gpToPractice.getIsPrimaryPractice()))
					{
						if (gpToPractice.getPractice() != null && gpToPractice.getPractice().getPctCode() != null)
							return gpToPractice.getPractice().getPctCode();
					}
				}
			}
		}

		// 2 - Patient.gpSurgery.address.PctCode
		/* This code is actually superfluous 
			If no PCT code is defined for the practice, 
			then there is no PCT code defined for the surgery as well.
			There is currently no way to define a CCG (PCT) code for a surgery.
			Code is being left here in case something about this setup changes in the future
		 */
		if (patient.getGpSurgery() != null 
				&& patient.getGpSurgery().getAddress() != null)
		{
			String codeCCG = patient.getGpSurgery().getAddress().getPctCode() != null ?  patient.getGpSurgery().getAddress().getPctCode() : bedAdmComponentDomainImpl.getCodeCCGFromPostalCode(patient.getGpSurgery().getAddress().getPostCode());
			
			if (codeCCG != null) return codeCCG;
		}

		// 3 - If overseas visitor, use X98
		if (Boolean.TRUE.equals(patient.getOverseasVisitor()))
			return OVERSEAS_VISITOR_CCG;
		
		// 4 -  Patient.Address.PCT(CCG) or Post code - if no post code on record use default codes for CCG // //WDEV-20585
		if (patient.getAddress() != null)
		{
			String codeCCG =  null;
			
			if (patient.getAddress().getPctCode() != null)
			{	
				codeCCG = patient.getAddress().getPctCode();
			}			
			else
			{
				codeCCG = bedAdmComponentDomainImpl.getCodeCCGFromPostalCode(patient.getAddress().getPostCode());
			}
			
			if (codeCCG != null) 
				return codeCCG;
		}
		
		// 5 - Current user's organisation
		if (getCurrentLocation() != null)
		{			
			String codeCCG = bedAdmComponentDomainImpl.getCCGCodeForCurrentLocationOrg(getCurrentLocation());
			if (codeCCG != null)
				return codeCCG;
		}

		// 6 - No condition satisfied, use Q99
		return RESIDENCE_NOT_KNOWN_CCG;

	}
		
	public LocationLiteVoCollection listHospitals()
	{
		OrganisationAndLocation domainImpl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return domainImpl.listActiveHospitalsLite();
	}


	public LocationLiteVoCollection listWards(LocationRefVo hospital, String name)
	{
		OrganisationAndLocation domainImpl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return domainImpl.listActiveWardsForHospitalByNameLite(hospital, name);
	}


	public ServiceLiteVoCollection listServices(String name)
	{
		ServiceConfiguration domainImpl = (ServiceConfiguration) getDomainImpl(ServiceConfigurationImpl.class);
		return domainImpl.listServices(name, ServiceCategory.CLINICAL, null, true);
	}


	public MemberOfStaffLiteVo getMemberOfStaffLite(MemberOfStaffRefVo mos)
	{
		if (mos == null || mos.getID_MemberOfStaff() == null)
			return null;
		
		return MemberOfStaffLiteVoAssembler.create((MemberOfStaff) getDomainFactory().getDomainObject(MemberOfStaff.class, mos.getID_MemberOfStaff()));
	}


	public MemberOfStaffLiteVoCollection listMosUsers(String name)
	{
		if (name == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT mos FROM MemberOfStaff AS mos WHERE mos.isActive = 1 AND mos.name.upperSurname LIKE :NAME");
		query.append(" ORDER BY mos.name.upperSurname ");
		
		return MemberOfStaffLiteVoAssembler.createMemberOfStaffLiteVoCollectionFromMemberOfStaff(getDomainFactory().find(query.toString(), "NAME", name.toUpperCase() + "%"));
	}

	//WDEV-21422
	public HcpLiteVoCollection listConsultants(ServiceRefVo service, String name)
	{
		if (name == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT medic FROM Medic AS medic LEFT JOIN medic.mos AS mos LEFT JOIN medic.grade AS grade ");
		if (service != null) //WDEV-21422
		{
			query.append(" LEFT JOIN medic.serviceFunction as servf LEFT JOIN servf.service as service" );
		}
		
		query.append(" WHERE mos.name.upperSurname LIKE :NAME AND medic.isActive = 1 AND grade.id = :CONSULTANT" + (service != null ? " AND service.id = :SERVICE_ID" : "") +  
				" ORDER BY mos.name.upperSurname ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		paramNames.add("NAME");					paramValues.add(name.toUpperCase() + "%");
		paramNames.add("CONSULTANT");			paramValues.add(MedicGrade.CONS.getID());
		if (service != null)
		{
			paramNames.add("SERVICE_ID");			paramValues.add(service.getID_Service());
		}
		
		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}


	public HcpLiteVo getHcpForMos(MemberOfStaffRefVo mos)
	{
		if (mos == null || mos.getID_MemberOfStaff() == null)
			return null;
		
		String query = "SELECT hcp FROM Hcp AS hcp LEFT JOIN hcp.mos AS mos WHERE mos.id = :MOS_ID";
		
		return HcpLiteVoAssembler.create((Hcp) getDomainFactory().findFirst(query, "MOS_ID", mos.getID_MemberOfStaff()));
	}	
	
	//WDEV-22230 
	public LocationLiteVo getHospitalForLocation(ILocation currentLoc)
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.getHospitalLiteForLocation((ILocation) currentLoc);
	}
}
