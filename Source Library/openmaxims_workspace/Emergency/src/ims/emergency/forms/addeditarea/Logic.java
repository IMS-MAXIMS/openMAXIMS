//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 4342.23748)
// Copyright (C) 1995-2012 IMS MAXIMS. All rights reserved.

package ims.emergency.forms.addeditarea;

import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.emergency.forms.addeditarea.GenForm.grpWorkflowMandatoryEnumeration;
import ims.emergency.vo.TrackingAreaVo;
import ims.emergency.vo.TrackingStatusWorkflowLightVoCollection;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.FormMode;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Color;

import java.util.ArrayList;
import java.util.List;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		open();
	}

	private void open()
	{
		initialize();
		populateScreenFromData(form.getGlobalContext().Emergency.getTrackingArea());
	}

	private void initialize()
	{
		form.cmbStatus().setValue(PreActiveActiveInactiveStatus.PREACTIVE);	
		loadTrackingWorkflowStatusCombo();
	}

	//WDEV-19091 
	private void loadTrackingWorkflowStatusCombo()
	{
		TrackingStatusWorkflowLightVoCollection trackingWorkflowStatusItems = domain.loadTrackingConfiguredStatuses();
		
		if (trackingWorkflowStatusItems != null && trackingWorkflowStatusItems.size() > 0)
		{
			for (int i = 0; i < trackingWorkflowStatusItems.size(); i++ )
			{
				if (trackingWorkflowStatusItems.get(i) != null && trackingWorkflowStatusItems.get(i).getTrackingStatus() != null && Boolean.TRUE.equals(trackingWorkflowStatusItems.get(i).getTrackingStatus().isActive()))
					form.cmbTrackingStatus().newRow(trackingWorkflowStatusItems.get(i), trackingWorkflowStatusItems.get(i).getTrackingStatus().getText());
			}
		}
		
	}

	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		engine.close(DialogResult.CANCEL);
	}

	@Override
	protected void onBtnOKClick() throws ims.framework.exceptions.PresentationLogicException
	{
		if (add())
			engine.close(DialogResult.OK);
	}

	private boolean add()
	{
		
		TrackingAreaVo trackingAreaToSave=form.getGlobalContext().Emergency.getTrackingArea();
		
		if (trackingAreaToSave==null)
			trackingAreaToSave=new TrackingAreaVo();

		String[] errors = validateUIRules();
		if (errors != null && errors.length > 0)
		{
			engine.showErrors(errors);
			return false;
		}
		
		trackingAreaToSave.setAreaDisplayName(form.txtAreaName().getValue());
		trackingAreaToSave.setAreaNameDescription(form.txtAreaDescription().getValue());
		//trackingAreaToSave.setPatientRefreshRate(form.intRefreshRate().getValue());
		trackingAreaToSave.setStatus(form.cmbStatus().getValue());
		trackingAreaToSave.setAreaType(form.cmbAreaType().getValue());
		
		//WDEV-19091
		trackingAreaToSave.setWorkflowConfig(form.cmbTrackingStatus().getValue());
		if (grpWorkflowMandatoryEnumeration.rdoYes.equals(form.grpWorkflowMandatory().getValue()))
			trackingAreaToSave.setAssociatedWorkflowMandatory(true);
		else
			trackingAreaToSave.setAssociatedWorkflowMandatory(false);
		
		form.getGlobalContext().Emergency.setTrackingArea(trackingAreaToSave);
		return true;

	}

	private void populateScreenFromData(TrackingAreaVo trackingAreaToSave)
	{
		
		if (trackingAreaToSave==null)
		{  
			updateControlsState(); // WDEV-19091 
			return;
		}
	
		form.txtAreaName().setValue(trackingAreaToSave.getAreaDisplayName());
		form.txtAreaDescription().setValue(trackingAreaToSave.getAreaNameDescription());
		//form.intRefreshRate().setValue(trackingAreaToSave.getPatientRefreshRate());

		if (trackingAreaToSave.getStatus().equals(PreActiveActiveInactiveStatus.ACTIVE))
		{
			form.cmbStatus().removeRow(PreActiveActiveInactiveStatus.PREACTIVE);
		}
		else if (trackingAreaToSave.getStatus().equals(PreActiveActiveInactiveStatus.INACTIVE))
		{
			form.cmbStatus().removeRow(PreActiveActiveInactiveStatus.PREACTIVE);
			form.cmbStatus().removeRow(PreActiveActiveInactiveStatus.ACTIVE);
		}
			
		form.cmbStatus().setValue(trackingAreaToSave.getStatus());
		form.cmbAreaType().setValue(trackingAreaToSave.getAreaType());
		
		//WDEV-19091 
		if (trackingAreaToSave.getWorkflowConfigIsNotNull())
		{
			//WDEV-19150
			if (trackingAreaToSave.getWorkflowConfig().getTrackingStatus() != null && !Boolean.TRUE.equals(trackingAreaToSave.getWorkflowConfig().getTrackingStatus().isActive()))
			{
				form.cmbTrackingStatus().newRow(trackingAreaToSave.getWorkflowConfig(), trackingAreaToSave.getWorkflowConfig().getTrackingStatus().getText(), Color.Red);
			}
			
			form.cmbTrackingStatus().setValue(trackingAreaToSave.getWorkflowConfig());
			form.grpWorkflowMandatory().setValue(setGrpWorkflowMandatoryValue(trackingAreaToSave.getAssociatedWorkflowMandatory()));
		}
		
		updateControlsState();
	}

	private grpWorkflowMandatoryEnumeration setGrpWorkflowMandatoryValue(Boolean associatedWorkflowMandatory)
	{
		if (Boolean.TRUE.equals(associatedWorkflowMandatory))
			return grpWorkflowMandatoryEnumeration.rdoYes;
		return grpWorkflowMandatoryEnumeration.rdoNo;
	}

	private void updateControlsState()
	{ 
		//WDEV-19091 - start //WDEV-21479 changed to boolean primitive type
		boolean previousSavedArea = form.getGlobalContext().Emergency.getTrackingAreaIsNotNull();
		boolean notOverallArea = previousSavedArea && !Boolean.TRUE.equals(form.getGlobalContext().Emergency.getTrackingArea().getIsOverallView());
		boolean notRegistrationArea = previousSavedArea && !Boolean.TRUE.equals(form.getGlobalContext().Emergency.getTrackingArea().getIsRegistrationArea());
		
		form.txtAreaName().setEnabled(!previousSavedArea || (notOverallArea && notRegistrationArea));
		form.txtAreaDescription().setEnabled(!previousSavedArea || (notOverallArea && notRegistrationArea));
		form.cmbStatus().setEnabled(!previousSavedArea || (notOverallArea && notRegistrationArea));
		form.cmbAreaType().setEnabled(!previousSavedArea || (notOverallArea && notRegistrationArea));
		
		form.lblTrackingStatus().setVisible(!previousSavedArea || (notOverallArea && notRegistrationArea));
		form.cmbTrackingStatus().setVisible(!previousSavedArea || (notOverallArea && notRegistrationArea));
		
		form.lblWorkflowMandatory().setVisible(form.cmbTrackingStatus().getValue() != null);
		form.grpWorkflowMandatory().setVisible(form.cmbTrackingStatus().getValue() != null);
		form.txtMandatory().setRequired(form.cmbTrackingStatus().getValue() != null);
		//WDEV-21479 - Overall and Registration areas cannot be changed
		form.btnOK().setVisible(FormMode.EDIT.equals(form.getMode()) && (!previousSavedArea || (notOverallArea && notRegistrationArea)));
		form.btnCancel().setText((!previousSavedArea || (notOverallArea && notRegistrationArea)) ? "Cancel" : "Close");
		//WDEV-19091 - end
	}
	
	private String[] validateUIRules()
	{
		List<String> uiErrors = new ArrayList<String>();

		if (form.txtAreaName().getValue() == null)
		{
			uiErrors.add("Area Name is mandatory");
		}

		if (form.txtAreaDescription().getValue() == null)
		{
			uiErrors.add("Area Description is mandatory");
		}

		/*if (form.intRefreshRate().getValue() == null)
		{
			uiErrors.add("Patient refresh rate is mandatory");
		}*/

		if (form.cmbStatus().getValue() == null)
		{
			uiErrors.add("Status is mandatory");
		}
		
		//WDEV-19091
		if (form.txtMandatory().isRequired() && 
			!(grpWorkflowMandatoryEnumeration.rdoNo.equals(form.grpWorkflowMandatory().getValue()) || grpWorkflowMandatoryEnumeration.rdoYes.equals(form.grpWorkflowMandatory().getValue())))
		{
			uiErrors.add("Answering 'Will the associated workflow be mandatory?' question is mandatory");
		}

		String[] uiResults = new String[uiErrors.size()];
		uiErrors.toArray(uiResults);

		return uiResults;
	}

	// WDEV-19091
	@Override
	protected void onCmbTrackingStatusValueChanged() throws PresentationLogicException
	{
		form.grpWorkflowMandatory().setValue(null);
		updateControlsState();
	}
}
