//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Mara Iroaie using IMS Development Environment (version 1.80 build 5127.24028)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.clinical.domain.impl;


import java.util.ArrayList;
import java.util.List;

import ims.clinical.configuration.domain.objects.InternalReferralSettings;
import ims.clinical.domain.base.impl.BaseInternalReferralsBookedListComponentImpl;
import ims.clinical.domain.objects.ClinicalReferralStatus;
import ims.clinical.domain.objects.ClinicalReferrals;
import ims.clinical.vo.ClinicalReferralForOutpatientBookingWorklistVo;
import ims.clinical.vo.ClinicalReferralForOutpatientBookingWorklistVoCollection;
import ims.clinical.vo.OutpatientBookingWorklistSearchCriteriaVo;
import ims.clinical.vo.domain.ClinicalReferralForOutpatientBookingWorklistVoAssembler;
import ims.clinical.vo.domain.ServiceShortForClinicalInternalReferralsVoAssembler;
import ims.clinical.vo.lookups.ClinicalReferralType;
import ims.clinical.vo.lookups.InternalReferralStatusChangeReason;
import ims.clinicaladmin.vo.InternalReferralSettingsForBookingWorklistVo;
import ims.clinicaladmin.vo.domain.InternalReferralSettingsForBookingWorklistVoAssembler;
import ims.core.clinical.domain.objects.RecordingUserInformation;
import ims.core.resource.people.domain.objects.MemberOfStaff;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.lookups.InternalReferralStatus;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;

public class InternalReferralsBookedListComponentImpl extends BaseInternalReferralsBookedListComponentImpl
{

	private static final long serialVersionUID = 1L;
	private static final Integer APPOINTMENT_BOOKED_AND_REQUIRED 	= 2;
	private static final Integer APPOINTMENT_REQUIRED 				= 1;
	private static final Integer APPOINTMENT_BOOKED					= 0;

	public ims.clinical.vo.ServiceShortForClinicalInternalReferralsVoCollection listServices(String text)
	{
		if (text == null || text.length() == 0)
			throw new DomainRuntimeException("Cannot search after a null text");
		
		StringBuilder hqlBuilder = new StringBuilder("select service from ServiceConfigIntReferral as intservice left join intservice.service as service where intservice.active = :isTRUE and service.upperName like :servName and service.isActive = :isTRUE order by service.upperName asc "); //WDEV-20219 UPPER(service.serviceName)
		
		List <?> services = getDomainFactory().find(hqlBuilder.toString(),new String[] {"isTRUE", "servName"}, new Object[] {Boolean.TRUE, "%" + text.toUpperCase() + "%"});
		
		if (services == null || services.size() == 0)
			return null;
		
		return ServiceShortForClinicalInternalReferralsVoAssembler.createServiceShortForClinicalInternalReferralsVoCollectionFromService(services);
	}

	public ClinicalReferralForOutpatientBookingWorklistVoCollection listReferrals(OutpatientBookingWorklistSearchCriteriaVo searchCriteria) 
	{	
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		String andStr = " and ";
		
		StringBuffer hql = new StringBuffer(" select referrals from ClinicalReferrals as referrals left join referrals.referralType as refType ");
		StringBuffer hqlConditions = new StringBuffer(" (referrals.isRIE is null or referrals.isRIE = 0) and ( refType.id =:IPSeenAsOutpatient or refType.id =:OPSeenAsOutpatient ) ");
		
		markers.add("IPSeenAsOutpatient");
		values.add(ClinicalReferralType.IP_TO_BE_SEEN_AS_OUTPATIENT.getID());
		markers.add("OPSeenAsOutpatient");
		values.add(ClinicalReferralType.OP_TO_BE_SEEN_AS_OUTPATIENT.getID());
		
		Boolean currentStatusAdded = false;
		if (searchCriteria.getReferralStatusIsNotNull())
		{
			hql.append(" left join referrals.currentReferralStatus as currentStatus left join currentStatus.referralStatus as status ");
			hqlConditions.append(andStr);
			hqlConditions.append(" status.id =:referralStatus");
			markers.add("referralStatus");
			values.add(searchCriteria.getReferralStatus().getID());
			andStr = " and ";	
			currentStatusAdded = true;
		}
				
		if (searchCriteria.getRequiredAppointmentIsNotNull())
		{	
			if (Boolean.FALSE.equals(currentStatusAdded))
			{
				hql.append(" left join referrals.currentReferralStatus as currentStatus left join currentStatus.referralStatus as status ");	
				hqlConditions.append(andStr);
				hqlConditions.append(" status.id =:referralStatus");
				markers.add("referralAcceptedStatus");
				values.add(InternalReferralStatus.ACCEPTED.getID());
				andStr = " and ";
			}
			
			if (APPOINTMENT_REQUIRED.equals(searchCriteria.getRequiredAppointment()))
			{
				hqlConditions.append(andStr);
				hqlConditions.append(" currentStatus.appointmentRequired =:apptRequired ");
				markers.add("apptRequired");
				values.add(Boolean.TRUE);
				andStr = " and ";
			}
			
			if (APPOINTMENT_BOOKED.equals(searchCriteria.getRequiredAppointment()))
			{
				hqlConditions.append(andStr);
				hqlConditions.append(" currentStatus.appointmentBooked =:apptBooked and currentStatus.appointmentRequired =:apptRequired");
				markers.add("apptBooked");
				values.add(Boolean.TRUE);
				markers.add("apptRequired");
				values.add(Boolean.FALSE);
				andStr = " and ";
			}
			
			if (APPOINTMENT_BOOKED_AND_REQUIRED.equals(searchCriteria.getRequiredAppointment()))
			{
				hqlConditions.append(andStr);
				hqlConditions.append(" ((currentStatus.appointmentBooked =:apptBooked and currentStatus.appointmentRequired =:apptRequiredNew) or currentStatus.appointmentRequired =:apptRequired) ");

				markers.add("apptBooked");
				values.add(Boolean.TRUE);
				markers.add("apptRequiredNew");
				values.add(Boolean.FALSE);
				markers.add("apptRequired");
				values.add(Boolean.TRUE);			
				andStr = " and ";		
			}
		}
		
		if (searchCriteria.getServiceIsNotNull())
		{
			hql.append(" left join referrals.referToService as intrefservice left join intrefservice.service as serv ");
			hqlConditions.append(andStr);
			hqlConditions.append(" intrefservice.active = :isActive and serv.id = :serviceID ");
			markers.add("isActive");
			values.add(Boolean.TRUE);
			markers.add("serviceID");
			values.add(searchCriteria.getService().getID_Service());
			andStr = " and ";			
		}
		
		if (searchCriteria.getHCPIsNotNull())
		{
			hql.append(" left join referrals.referToHCP as hcp ");
			hqlConditions.append(andStr);
			hqlConditions.append(" hcp.id = :mosID ");
			markers.add("mosID");
			values.add(searchCriteria.getHCP().getIMosHcpId());
			andStr = " and ";
		}
		
		if (searchCriteria.getFromDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" referrals.dateDecisionToRefer >= :fromDate ");
			markers.add("fromDate");
			DateTime fromDateTime = new DateTime( searchCriteria.getFromDate(), new Time(0, 0));
			values.add(fromDateTime.getJavaDate());
			andStr = " and ";
		}
		
		if (searchCriteria.getToDateIsNotNull())
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" referrals.dateDecisionToRefer <= :toDate ");
			markers.add("toDate");
			DateTime toDateTime = new DateTime( searchCriteria.getToDate(), new Time(0, 0));
			values.add(toDateTime.getJavaDate());
			values.add(searchCriteria.getToDate());
			andStr = " and ";
		}

		if (hqlConditions != null && hqlConditions.length() > 0)
		{
			hqlConditions.insert(0, " where ");
		}
		
		hqlConditions.append(" order by referrals.urgentReferral desc, referrals.dateDecisionToRefer desc ");	
		List<?> list = getDomainFactory().find(hql.append(hqlConditions.toString()).toString(), markers, values);
				
		return ClinicalReferralForOutpatientBookingWorklistVoAssembler.createClinicalReferralForOutpatientBookingWorklistVoCollectionFromClinicalReferrals(list);
	}

	public ClinicalReferralForOutpatientBookingWorklistVo markReferralAsAppointmentBooked(ClinicalReferralForOutpatientBookingWorklistVo referral) throws StaleObjectException {
		
		if (referral == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		ClinicalReferrals doClinicalReferral = ClinicalReferralForOutpatientBookingWorklistVoAssembler.extractClinicalReferrals(factory, referral);
		
		if (doClinicalReferral ==  null)
			return null;
		
		ClinicalReferralStatus newStatus = getNewStatus();
		doClinicalReferral.setCurrentReferralStatus(newStatus);
		doClinicalReferral.getHistoryOfReferralStatus().add(newStatus);
				
		factory.save(doClinicalReferral);

		return ClinicalReferralForOutpatientBookingWorklistVoAssembler.create(doClinicalReferral);
	}

	private ClinicalReferralStatus getNewStatus() 
	{
		DomainFactory factory = getDomainFactory();
		ClinicalReferralStatus newStatus = new ClinicalReferralStatus();
		
		newStatus.setReferralStatus(getDomLookup(InternalReferralStatus.ACCEPTED));
		
		RecordingUserInformation userInformation = new RecordingUserInformation();

		if (getMosUser() != null)
			userInformation.setRecordingUser((MemberOfStaff) factory.getDomainObject(MemberOfStaff.class,((MemberOfStaffLiteVo) getMosUser()).getID_MemberOfStaff()));
		userInformation.setRecordingDateTime(new java.util.Date());
		
		newStatus.setRecordingInfo(userInformation);
		
		newStatus.setAppointmentBooked(true);
		newStatus.setAppointmentRequired(false);
		newStatus.setInternalReferralStatusChangeReason(getDomLookup(InternalReferralStatusChangeReason.BOOKING_MADE));

		return newStatus;
	}
	public InternalReferralSettingsForBookingWorklistVo getInternalReferralSettingsConfig()
	{
		StringBuilder hqlBuilder = new StringBuilder("select irs from InternalReferralSettings irs where ( irs.isRIE is null  or irs.isRIE = :isFALSE ) ");
		
		List <?> urgentReferralConfig = getDomainFactory().find(hqlBuilder.toString(),"isFALSE", Boolean.FALSE);
		
		if (urgentReferralConfig == null || urgentReferralConfig.size() == 0)
			return null;
		
		return InternalReferralSettingsForBookingWorklistVoAssembler.create((InternalReferralSettings) urgentReferralConfig.get(0));
	}

	public HcpLiteVoCollection listHCP(String text) 
	{
		if (text == null || (text != null && text.length() == 0))
			throw new DomainRuntimeException("Cannot search on null name.");

		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String hql = "select h from Hcp h ";

		hql += "where h.isActive = :isActive and (h.mos.name.upperSurname like :hcpSname or h.mos.name.upperForename like :hcpFname)";

		markers.add("isActive");
		values.add(Boolean.TRUE);
		markers.add("hcpSname");
		values.add(text.toUpperCase() + "%");
		markers.add("hcpFname");
		values.add(text.toUpperCase() + "%");

		hql += " order by h.mos.name.upperSurname,h.mos.name.upperForename";

		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(factory.find(hql, markers, values));
	}

}
