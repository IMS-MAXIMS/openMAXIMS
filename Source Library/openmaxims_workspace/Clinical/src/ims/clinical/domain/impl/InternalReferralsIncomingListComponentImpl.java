//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cristian Belciug using IMS Development Environment (version 1.80 build 5127.24028)
// Copyright (C) 1995-2014 IMS MAXIMS. All rights reserved.

package ims.clinical.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.clinical.configuration.domain.objects.InternalReferralSettings;
import ims.clinical.domain.base.impl.BaseInternalReferralsIncomingListComponentImpl;
import ims.clinical.domain.objects.ClinicalReferrals;
import ims.clinical.vo.ClinicalReferralsForIncomingReferralListVo;
import ims.clinical.vo.ClinicalReferralsForIncomingReferralListVoCollection;
import ims.clinical.vo.ClinicalReferralsRefVo;
import ims.clinical.vo.ClinicalReferralsSaveForIncomingReferralListVo;
import ims.clinical.vo.IncomingReferralListCriteriaVo;
import ims.clinical.vo.ServiceConfigIntReferralForIncomingListVo;
import ims.clinical.vo.ServiceConfigIntReferralForIncomingListVoCollection;
import ims.clinical.vo.domain.ClinicalReferralsForIncomingReferralListVoAssembler;
import ims.clinical.vo.domain.ClinicalReferralsSaveForIncomingReferralListVoAssembler;
import ims.clinical.vo.domain.ServiceConfigIntReferralForIncomingListVoAssembler;
import ims.clinical.vo.lookups.ClinicalReferralType;
import ims.clinicaladmin.helper.IInternalReferralActionsHelper;
import ims.clinicaladmin.helper.InternalReferralActionsHelper;
import ims.clinicaladmin.vo.InternalReferralSettingsVo;
import ims.clinicaladmin.vo.domain.InternalReferralSettingsVoAssembler;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.vo.HcpLiteVoCollection;
import ims.core.vo.LocSiteLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocSiteLiteVoAssembler;
import ims.core.vo.lookups.InternalReferralStatus;
import ims.core.vo.lookups.LocationType;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;

import java.util.ArrayList;
import java.util.List;

public class InternalReferralsIncomingListComponentImpl extends BaseInternalReferralsIncomingListComponentImpl
{
	private static final long serialVersionUID = 1L;
	
	private static final String INPATIENT_REFERRAL = "I/P";
	private static final String OUTPATIENT_REFERRAL = "O/P";

	public ims.clinical.vo.ClinicalReferralsForIncomingReferralListVoCollection listClinicalReferrals(ims.clinical.vo.IncomingReferralListCriteriaVo criteria)
	{
		if(criteria == null && new IncomingReferralListCriteriaVo().equals(criteria))
			throw new CodingRuntimeException("At least one search criteria must be provided");
		
		String statusesIds = getStatusesIds(criteria);
		
		StringBuilder hqlJoins = new StringBuilder("select clinicReferral from ClinicalReferrals as clinicReferral left join clinicReferral.currentReferralStatus as clinicReferralStatus left join clinicReferralStatus.referralStatus as status ");
		StringBuilder hqlConditions = new StringBuilder(" where status.id not in (" + InternalReferralStatus.ABANDONED.getID() + ") and (clinicReferral.isRIE is null or clinicReferral.isRIE = 0) ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		String and = " and ";
		String or = " ";
		
		if((statusesIds != null && statusesIds.length() > 0) || Boolean.TRUE.equals(criteria.getAppointmentBooked()) || Boolean.TRUE.equals(criteria.getRequiringAppointment()))
		{
			hqlConditions.append(and);
			hqlConditions.append("(");
		}
		
		if(statusesIds != null && statusesIds.length() > 0)
		{
			hqlConditions.append(" status.id in ( " + statusesIds + " ) ");
			and = " and ";
			or = " or ";
		}
		
		if(!Boolean.TRUE.equals(criteria.getAccepted()))
		{
			if(Boolean.TRUE.equals(criteria.getAppointmentBooked()))
			{
				if(statusesIds != null && statusesIds.length() > 0)
				{
					hqlConditions.append(or);
				}
				
				hqlConditions.append(" (status.id = :AcceptedId and clinicReferralStatus.appointmentBooked = 1) ");
				paramNames.add("AcceptedId");
				paramValues.add(InternalReferralStatus.ACCEPTED.getID());
				
				and = " and ";
				or = " or ";
			}
			
			if(Boolean.TRUE.equals(criteria.getRequiringAppointment()))
			{
				if((statusesIds != null && statusesIds.length() > 0) || Boolean.TRUE.equals(criteria.getAppointmentBooked()))
				{
					hqlConditions.append(or);
				}
				
				hqlConditions.append(" (status.id = :AcceptedId and clinicReferralStatus.appointmentRequired = 1) ");
				paramNames.add("AcceptedId");
				paramValues.add(InternalReferralStatus.ACCEPTED.getID());
				
				and = " and ";
			}
		}
		
		if((statusesIds != null && statusesIds.length() > 0) || Boolean.TRUE.equals(criteria.getAppointmentBooked()) || Boolean.TRUE.equals(criteria.getRequiringAppointment()))
		{
			hqlConditions.append(") ");
		}
		
		if(criteria.getReferralToService() != null || (criteria.getServices() != null) && criteria.getServices().size() > 0)
		{
			hqlJoins.append("  left join clinicReferral.referToService as refToService ");
			hqlConditions.append(and);
			hqlConditions.append(" refToService.id in (" + getServicesIds(criteria) + ") ");
			
			and = " and ";
		}
		
		if(criteria.getReferralToHcp() != null)
		{
			hqlJoins.append(" left join clinicReferral.referToHCP as refToHcp ");
			hqlConditions.append(and);
			hqlConditions.append(" refToHcp.id = :ReferralToHCP ");
			
			paramNames.add("ReferralToHCP");
			paramValues.add(criteria.getReferralToHcp().getIMosHcpId());
			and = " and ";
		}
		
		if(criteria.getReferralDateFrom() != null)
		{
			hqlConditions.append(and);
			hqlConditions.append(" clinicReferral.dateDecisionToRefer >= :DateFrom ");
			
			paramNames.add("DateFrom");
			paramValues.add(criteria.getReferralDateFrom().getDate());
			and = " and ";
		}
		
		if(criteria.getReferralDateTo() != null)
		{
			hqlConditions.append(and);
			hqlConditions.append(" clinicReferral.dateDecisionToRefer <= :DateTo ");
			
			paramNames.add("DateTo");
			paramValues.add(criteria.getReferralDateTo().getDate());
			and = " and ";
		}
		
		or = " ";
		if(Boolean.TRUE.equals(criteria.getInpatient()) || (Boolean.TRUE.equals(criteria.getOutpatient())))
		{
			hqlJoins.append(" left join clinicReferral.referralType as refType ");
			hqlConditions.append(and);
			hqlConditions.append("(");
			
			if(Boolean.TRUE.equals(criteria.getInpatient()))
			{
				hqlConditions.append(" (refType.id = :ReferralTypeId ");

				paramNames.add("ReferralTypeId");
				paramValues.add(ClinicalReferralType.IP_TO_BE_SEEN_AS_INPATIENT.getID());
				and = " and ";
				
				if(criteria.getWard() != null)
				{
					hqlJoins.append(" left join clinicReferral.patient as pat left join pat.ward as wrd ");
					hqlConditions.append(and);
					hqlConditions.append(" wrd.id = :WardId ");
					paramNames.add("WardId");
					paramValues.add(criteria.getWard().getID());
				}
				hqlConditions.append(") ");
				
				or = " or ";
			}
			
			if((Boolean.TRUE.equals(criteria.getOutpatient())))
			{
				hqlConditions.append(or);
				hqlConditions.append(" (refType.id = :ReferralTypeId1 or  refType.id = :ReferralTypeId2) ");

				paramNames.add("ReferralTypeId1");
				paramValues.add(ClinicalReferralType.IP_TO_BE_SEEN_AS_OUTPATIENT.getID());
				paramNames.add("ReferralTypeId2");
				paramValues.add(ClinicalReferralType.OP_TO_BE_SEEN_AS_OUTPATIENT.getID());
				and = " and ";
			}
			
			hqlConditions.append(")");
			and = " and ";
		}
		
		DomainFactory factory = getDomainFactory();
		
		List<?> referralsList = factory.find(hqlJoins.append(hqlConditions.toString()).toString(), paramNames, paramValues);
		
		ClinicalReferralsForIncomingReferralListVoCollection referrals = ClinicalReferralsForIncomingReferralListVoAssembler.createClinicalReferralsForIncomingReferralListVoCollectionFromClinicalReferrals(referralsList);
		
		if(referrals == null)
			return null;
		
		for(ClinicalReferralsForIncomingReferralListVo referral : referrals)
		{
			if(referral == null)
				continue;
			
			referral.setReferralTypeText(getReferralType(referral.getReferralType()));
		}
		
		return referrals;
	}
	
	private String getServicesIds(IncomingReferralListCriteriaVo criteria) 
	{
		if(criteria == null)
			return null;
		
		if(criteria.getReferralToService() == null && criteria.getServices() == null)
			return null;
		
		StringBuffer ids = new StringBuffer();
		
		if(criteria.getReferralToService() != null)
		{
			ids.append(criteria.getReferralToService().getID_ServiceConfigIntReferral());
		}
		else if(criteria.getServices() != null)
		{
			for(ServiceConfigIntReferralForIncomingListVo cfg : criteria.getServices())
			{
				if(cfg == null)
					continue;
				
				if(ids.length() > 0)
					ids.append(",");
				
				ids.append(cfg.getID_ServiceConfigIntReferral());
			}
		}
		
		return ids.toString();
	}

	private String getReferralType(ClinicalReferralType clinicalReferralType) 
	{
		if(clinicalReferralType == null)
			return null;
		
		if(ClinicalReferralType.IP_TO_BE_SEEN_AS_INPATIENT.equals(clinicalReferralType))
			return INPATIENT_REFERRAL;
		
		return OUTPATIENT_REFERRAL;
	}

	private String getStatusesIds(IncomingReferralListCriteriaVo criteria) 
	{
		if(criteria == null)
			return null;
		
		StringBuilder statusesIds = new StringBuilder();
		
		if(Boolean.TRUE.equals(criteria.getAwaitingAcceptance()))
		{
			statusesIds.append(InternalReferralStatus.AWAITING_ACCEPTANCE.getID());
		}
		if(Boolean.TRUE.equals(criteria.getRequires2ndOpinion()))
		{
			if(statusesIds.length() > 0)
				statusesIds.append(",");
			
			statusesIds.append(InternalReferralStatus.SECOND_OPINION_REQUIRED.getID());
		}
		if(Boolean.TRUE.equals(criteria.getAccepted()))
		{
			if(statusesIds.length() > 0)
				statusesIds.append(",");
			
			statusesIds.append(InternalReferralStatus.ACCEPTED.getID());
		}
		if(Boolean.TRUE.equals(criteria.getRejected()))
		{
			if(statusesIds.length() > 0)
				statusesIds.append(",");
			
			statusesIds.append(InternalReferralStatus.REJECTED.getID());
		}
		if(Boolean.TRUE.equals(criteria.getCompleted()))
		{
			if(statusesIds.length() > 0)
				statusesIds.append(",");
			
			statusesIds.append(InternalReferralStatus.COMPLETED.getID());
		}
		
		return statusesIds.toString();
	}

	public ServiceConfigIntReferralForIncomingListVoCollection listServices(String serviceSearchText) 
	{
		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		StringBuffer hql = new StringBuffer("select serviceC from ServiceConfigIntReferral as serviceC left join serviceC.service as s where serviceC.active = :isActive ");

		markers.add("isActive");
		values.add(Boolean.TRUE);
		
		if(serviceSearchText != null)
		{
			hql.append(" and s.upperName like :ServiceName "); //WDEV-20219 upper(s.serviceName)
			markers.add("ServiceName");
			values.add(serviceSearchText.toUpperCase() + "%");
		}

		hql.append(" order by s.upperName asc");//WDEV-20219 upper(s.serviceName)

		return ServiceConfigIntReferralForIncomingListVoAssembler.createServiceConfigIntReferralForIncomingListVoCollectionFromServiceConfigIntReferral(factory.find(hql.toString(), markers, values));
	}

	public ClinicalReferralsSaveForIncomingReferralListVo getClinicalReferral(ClinicalReferralsRefVo clinicalReferralRef) 
	{
		if(clinicalReferralRef == null || clinicalReferralRef.getID_ClinicalReferrals() == null)
			throw new CodingRuntimeException("Cannor get ClinicalReferrals for a null ClinicalReferralsId.");
		
		DomainFactory factory = getDomainFactory();
		ClinicalReferrals doClinicalReferrals = (ClinicalReferrals) factory.getDomainObject(ClinicalReferrals.class, clinicalReferralRef.getID_ClinicalReferrals());
		
		return ClinicalReferralsSaveForIncomingReferralListVoAssembler.create(doClinicalReferrals);
	}

	public ClinicalReferralsForIncomingReferralListVo save(ClinicalReferralsSaveForIncomingReferralListVo clinicalReferral)	throws StaleObjectException 
	{
		if(clinicalReferral == null)
			throw new CodingRuntimeException("Cannot save a null ClinicalReferralForRejectionVo");
		
		if(!clinicalReferral.isValidated())
			throw new CodingRuntimeException("ClinicalReferralForRejectionVo is not validated");
		
		DomainFactory factory = getDomainFactory();
		
		ClinicalReferrals doClinicalReferral = ClinicalReferralsSaveForIncomingReferralListVoAssembler.extractClinicalReferrals(factory, clinicalReferral);
		factory.save(doClinicalReferral);
		
		return ClinicalReferralsForIncomingReferralListVoAssembler.create(doClinicalReferral);
	}

	public InternalReferralActionsHelper getInternalReferralHelper() 
	{
		ims.clinicaladmin.helper.IInternalReferralActionsHelper iInterface = (IInternalReferralActionsHelper) getDomainImpl(InternalReferralActionsHelper.class);
		return iInterface.initializeInternalReferralActionsHelper();
	}

	public LocationLiteVoCollection listWards(ILocation loggedLocation) 
	{
		LocSiteLiteVo hospital = getCurrentHospital(loggedLocation);
		
		if(hospital == null)
			return null;
		
		OrganisationAndLocation implLoc = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return implLoc.listActiveWardsForHospitalByNameLite(hospital, null);
	}
	
	private LocSiteLiteVo getCurrentHospital(ILocation location) 
	{
		if(location == null)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, location.getID()));
		
		if(currentHospital instanceof LocSite)
			return LocSiteLiteVoAssembler.create((LocSite) currentHospital);
		
		return null;
	}
	
	private Location getHospital(Location doLocation)
	{
		if(doLocation == null)
			return null;
		
		if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;
	
		while(doLocation.getParentLocation() != null) 
		{
			doLocation = doLocation.getParentLocation();
			if(doLocation instanceof Location && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}
		
		return null;
	}

	public InternalReferralSettingsVo getInternalReferralSettings() 
	{
		DomainFactory factory = getDomainFactory();

		List<?> list = factory.find("select settings from InternalReferralSettings as settings");

		if (list != null && list.size() > 0)
		{
			return InternalReferralSettingsVoAssembler.create((InternalReferralSettings) list.get(0));
		}
		
		return null;
	}

	public HcpLiteVoCollection listHCPs(String name) 
	{
		if (name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Cannot search on null name.");

		DomainFactory factory = getDomainFactory();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String hql = "select h from Hcp h where h.isActive = :isActive and (h.mos.name.upperSurname like :hcpSname or h.mos.name.upperForename like :hcpFname)";

		markers.add("isActive");
		values.add(Boolean.TRUE);
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");

		hql += " order by h.mos.name.upperSurname,h.mos.name.upperForename";

		return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(factory.find(hql, markers, values));
	}
}
