//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Bogdan Tofei using IMS Development Environment (version 1.80 build 5465.13953)
// Copyright (C) 1995-2015 IMS MAXIMS. All rights reserved.

package ims.scheduling.forms.moveandbooktheatreslot;

import ims.configuration.AppRight;
import ims.configuration.gen.ConfigFlag;
import ims.core.vo.LocationLiteVo;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.Control;
import ims.framework.FormName;
import ims.framework.enumerations.DialogResult;
import ims.framework.enumerations.SortOrder;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Color;
import ims.framework.utils.Time;
import ims.framework.utils.TimeFormat;
import ims.scheduling.forms.moveandbooktheatreslot.GenForm.grdTheatreSessionsRow;
import ims.scheduling.forms.moveandbooktheatreslot.GenForm.grdTheatreSlotsRow;
import ims.scheduling.vo.AppointmentForTheatreMoveVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.SessionEmergencyTheatreVo;
import ims.scheduling.vo.SessionEmergencyTheatreVoCollection;
import ims.scheduling.vo.SessionListOwnerLiteVo;
import ims.scheduling.vo.SessionListOwnerLiteVoCollection;
import ims.scheduling.vo.SessionParentChildSlotRefVoCollection;
import ims.scheduling.vo.SessionParentChildSlotVo;
import ims.scheduling.vo.SessionParentChildSlotVoCollection;
import ims.scheduling.vo.SessionTheatreVo;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.scheduling.vo.lookups.TheatreType;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

public class Logic extends BaseLogic
{
	private static final long serialVersionUID = 1L;

	@Override
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.PresentationLogicException
	{
		AppointmentForTheatreMoveVo appointment = domain.getAppointmentToMove(form.getGlobalContext().Clinical.getTheatreAppointmentRef());

		form.getLocalContext().setSelectedAppointment(appointment);
		
		//this is so the slot will have a version for the session  
		if (appointment != null && appointment.getParentChildSlot() != null)
			form.getLocalContext().getSelectedAppointment().getParentChildSlot().setSession(appointment.getSession());

		open();
	}

	private void open()
	{
		AppointmentForTheatreMoveVo appointment = form.getLocalContext().getSelectedAppointment();

		if (appointment == null || appointment.getSession() == null)
			return;

		LocationLiteVo hospital = domain.getHospitalForLocation(appointment.getSession().getSchLocation());

		form.lblDateValue().setValue(appointment.getAppointmentDate() != null ? appointment.getAppointmentDate().toString() : "");
		form.lblHospitalValue().setValue(hospital != null ? hospital.getName() : "");

		populateSessions(domain.listSessions(appointment.getAppointmentDate(), hospital, appointment.getCustomProcedureDuration(), engine.hasRight(AppRight.CAN_OVERBOOK_THEATRE_APPTS)));

		updateControlsState();

	}

	private void populateSessions(SessionEmergencyTheatreVoCollection listSessions)
	{
		clearGrids();

		if (listSessions == null || listSessions.size() == 0)
		{
			engine.showMessage("No recods found");
			return;
		}

		for (int i = 0; i < listSessions.size(); i++)
		{
			SessionEmergencyTheatreVo session = listSessions.get(i);

			if (session == null)
				continue;

			grdTheatreSessionsRow row = form.grdTheatreSessions().getRows().newRow();

			row.setColDate(session.getSessionDate());

			String consultantDisplayString = getConsultantsListString(session);

			row.setColConsultant(consultantDisplayString);
			row.setCellColConsultantTooltip(consultantDisplayString);

			row.setColListType(session.getListType() != null ? session.getListType().getText() : "");
			row.setCellColListTypeTooltip(session.getListType() != null ? session.getListType().getText() : "");

			row.setColLocation(session.getSchLocation() != null ? session.getSchLocation().getName() : "");
			row.setCellColLocationTooltip(session.getSchLocation() != null ? session.getSchLocation().getName() : "");

			row.setColNoBooked(session.getNoOfAppointments() != null ? session.getNoOfAppointments().toString() : "");
			row.setColTimeRemaining(session.getTheatreProceduresRemaining() != null && session.getTheatreProceduresRemaining().getRemainingTimeInMins() != null ? session.getTheatreProceduresRemaining().formatTimeRemaining() : "");

			row.setValue(session);
			
			if (TheatreType.EMERGENCY.equals(session.getTheatreType()) || TheatreType.EMERGENCY_NON_TO.equals(session.getTheatreType()))
				row.setBackColor(Color.DarkSalmon);
		}
		
	}

	private String getConsultantsListString(SessionEmergencyTheatreVo session)
	{
		if (session == null || session.getListOwners() == null)
			return "";

		String strConsultant = "";

		SessionListOwnerLiteVoCollection collListOwners = session.getListOwners().sort(new ListOwnerNameComparator(SortOrder.ASCENDING));

		for (int i = 0; i < collListOwners.size(); i++)
		{
			SessionListOwnerLiteVo voCons = collListOwners.get(i);

			if (voCons.getHcp() != null)
				strConsultant += strConsultant.length() > 0 ? ", " + voCons.getHcp().toString() : voCons.getHcp().toString();
		}

		return strConsultant;
	}

	private void clearGrids()
	{
		form.grdTheatreSessions().getRows().clear();
		form.grdTheatreSlots().getRows().clear();

	}

	@Override
	protected void onBtnMoveClick() throws ims.framework.exceptions.PresentationLogicException
	{
		SessionTheatreVo session = domain.getSession(form.grdTheatreSlots().getValue().getSession());

		SessionParentChildSlotRefVoCollection slots = session.calculateChildSlots(form.grdTheatreSlots().getValue(), form.getLocalContext().getSelectedAppointment().getCustomProcedureDuration(), form.getLocalContext().getSelectedAppointment());

		if (!engine.hasRight(AppRight.CAN_OVERBOOK_THEATRE_APPTS))
		{
			if (slots == null)
			{
				engine.showMessage("Not enough Slots available to Book into");
				return;
			}
		}
		
		try
		{
			domain.moveAppointment(form.getLocalContext().getSelectedAppointment().getParentChildSlot(), form.grdTheatreSlots().getValue());
		}
		catch (StaleObjectException e)
		{
			engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
		}

		engine.close(DialogResult.OK);
	}

	@Override
	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		engine.close(DialogResult.CANCEL);
	}

	@Override
	protected void onGrdTheatreSlotsSelectionChanged()
	{
		updateControlsState();
	}

	@Override
	protected void onGrdTheatreSessionsSelectionChanged()
	{
		grdSessionSelectionChanged();
		
	}

	private void grdSessionSelectionChanged()
	{
		form.txtSessionComments().setValue(form.grdTheatreSessions().getValue() != null ? form.grdTheatreSessions().getValue().getSessionComment() : null);

		SessionTheatreVo session = domain.getSession(form.grdTheatreSessions().getValue());
		populateSlotsGrid(session != null && session.getParentChildSlots() != null ? session.getParentChildSlots().sort() : null);
		updateControlsState();
		
	}

	private void populateSlotsGrid(SessionParentChildSlotVoCollection sessionSlots)
	{
		form.grdTheatreSlots().getRows().clear();

		if (sessionSlots == null || sessionSlots.size() == 0)
			return;

		boolean hasBookingRights = doesRoleHaveBookingRightsForSession(form.grdTheatreSessions().getValue());

		for (int i = 0; i < sessionSlots.size(); i++)
		{
			SessionParentChildSlotVo slot = sessionSlots.get(i);

			if (slot == null)
				continue;

			if (slot.getAppointment() == null && Status_Reason.BOOKED.equals(slot.getStatus()))
				continue;

			grdTheatreSlotsRow row = form.grdTheatreSlots().getRows().newRow();

			if (slot.getAppointment() != null)
			{
				// slot with an appointment
				row.setColStartTime(slot.getAppointment().getApptStartTime());
				row.setColMins(slot.getAppointment().getCustomProcedureDuration() != null ? slot.getAppointment().getCustomProcedureDuration().toString() : "");

				if (slot.getAppointment().getPatient() != null)
				{
					row.setColPatient(slot.getAppointment().getPatient().toString());

					String apptComment = domain.getBookingCommentForAppt(slot.getAppointment());

					row.setTooltipForColPatient(apptComment != null ? slot.getAppointment().getPatient().toString() + "<br>Booking Comments: <b>" + apptComment + "</b>" : slot.getAppointment().getPatient().toString());
				}

				if (slot.getAppointment().getTheatreBooking() != null)
				{
					if (slot.getAppointment().getTheatreBooking().getProcedure() != null)
					{
						row.setColProcedure(slot.getAppointment().getTheatreBooking().getProcedure());
						row.setTooltipForColProcedure(slot.getAppointment().getTheatreBooking().getProcedure().toString());
					}
				}

				row.setSelectable(false);
			}
			else
			{
				// add empty slots
				row.setColStartTime(slot.getStartTime());

				if (Status_Reason.CANCELLED.equals(slot.getStatus()))
					row.setTooltip("Slot Cancelled");
				else if (Status_Reason.BLOCKED.equals(slot.getStatus()))
					row.setTooltip("Slot Blocked");

				row.setSelectable(hasBookingRights);
			}

			// Suspended Slots
			if (Status_Reason.SUSPENDED.equals(slot.getStatus()))
			{
				row.setBackColor(Color.Bisque);
				row.setColPatient("Suspended for: " + (slot.getStatusReason() != null ? slot.getStatusReason().getText() : ""));
			}
			else if (Status_Reason.CLOSED.equals(slot.getStatus()))
			{
				row.setBackColor(Color.Bisque);
				row.setTooltip("Slot Closed");
			}

			row.setValue(slot);

			// colour overlapping appointments
			grdTheatreSlotsRow previousRow;

			if (form.grdTheatreSlots().getRows().size() > 1)
			{
				previousRow = form.grdTheatreSlots().getRows().get(form.grdTheatreSlots().getRows().size() - 2);

				if (previousRow.getValue() != null && previousRow.getValue().getAppointmentIsNotNull())
				{
					if (previousRow.getValue().getAppointment().getApptEndTimeIsNotNull() && previousRow.getValue().getAppointment().getApptEndTime().isGreaterThan(slot.getStartTime()))
						previousRow.setBackColor(Color.Red);
				}
			}

			if (!hasBookingRights)
				row.setTooltip("Role does not have rights to book in this Session");

			// flagging current appointment
			if (form.getLocalContext().getSelectedAppointment().getParentChildSlot() != null && form.getLocalContext().getSelectedAppointment().getParentChildSlot().equals(row.getValue()))
				row.setBackColor(Color.LightBlue);
		}

		fillGridUntilMidnightWithEmptySlots();

	}

	private boolean doesRoleHaveBookingRightsForSession(SessionEmergencyTheatreVo voSession)
	{
		Map map = form.getLocalContext().getSessionBookingRights();
		if (map == null)
			map = new HashMap();

		Object entry = map.get(voSession.getID_Sch_Session());

		if (entry == null)
		{
			map.put(voSession.getID_Sch_Session(), domain.hasBookingRights(engine.getLoggedInRole(), voSession));
			entry = map.get(voSession.getID_Sch_Session());
		}

		form.getLocalContext().setSessionBookingRights(map);

		return (Boolean) entry;
	}

	private void fillGridUntilMidnightWithEmptySlots()
	{
		SessionEmergencyTheatreVo voSession = form.grdTheatreSessions().getValue();

		if (voSession == null)
			return;

		// Get the last appointment end time
		Time sessionEndTm = voSession.getEndTm().copy();

		if (form.grdTheatreSlots().getRows().size() > 0)
		{
			grdTheatreSlotsRow row = form.grdTheatreSlots().getRows().get(form.grdTheatreSlots().getRows().size() - 1);

			if (row.getValue() != null)
			{
				if (row.getValue().getStartTimeIsNotNull() && row.getValue().getDurationIsNotNull())
					sessionEndTm = Booking_AppointmentVo.calculateEndTime(row.getValue().getStartTime(), row.getValue().getDuration());

				if (row.getValue().getAppointmentIsNotNull() && row.getValue().getAppointment().getApptEndTimeIsNotNull())
					sessionEndTm = row.getValue().getAppointment().getApptEndTime();

				// Colour last row red if it is over-booked
				if (row.getValue().getAppointmentIsNotNull())
				{
					if (row.getValue().getAppointment().getApptEndTimeIsNotNull())
					{
						if (row.getValue().getAppointment().getApptEndTime().isGreaterThan(voSession.getEndTm()))
							row.setBackColor(Color.Red);
					}
				}
			}
		}

		if (sessionEndTm != null)
		{
			int fillerDuration = 0;

			if (voSession.getParentChildSlots() != null && voSession.getParentChildSlots().size() > 0)
			{
				if (voSession.getParentChildSlots().get(0).getDurationIsNotNull())
				{
					fillerDuration = voSession.getParentChildSlots().get(0).getDuration();
				}
			}

			if (fillerDuration == 0)
				fillerDuration = 5; // default fill slots to 5 mins

			Time midNight = new Time(23, 59);

			// need to fill this time period with multiple dummy slots of
			// 'fillerDuration' size
			int timeFillRequired = (midNight.getTotalMinutes() + 1) - sessionEndTm.getTotalMinutes();

			Time tmDummySlot = (Time) sessionEndTm.clone();
			while (timeFillRequired > 0)
			{
				tmDummySlot = roundTimeIfRequired(tmDummySlot);

				grdTheatreSlotsRow row = form.grdTheatreSlots().getRows().newRow();
				row.setColStartTime((Time) tmDummySlot.clone());
				row.setBackColor(Color.Bisque);
				row.setSelectable(false);
				timeFillRequired -= fillerDuration;
				tmDummySlot.addMinutes(fillerDuration);
			}
		}

	}

	private Time roundTimeIfRequired(Time tmDummySlot)
	{
		int round = 5;
		int intTime = Integer.parseInt(tmDummySlot.toString(TimeFormat.FLAT4));

		// check for remainder if there is a remainder rounding is required
		if (!(intTime % round == 0))
		{
			double result = Math.round((intTime + 5) / round) * round;
			String prepend = "";

			// WDEV-13221
			// Reversed conditions to correctly prepend
			if (intTime < 1)
				prepend = "0000";
			else if (intTime < 10)
				prepend = "000";
			else if (intTime < 100)
				prepend = "00";
			else if (intTime < 1000)
				prepend = "0";

			int res = (int) result;

			String timeVal = prepend + res;
			timeVal = correctSixtyMinHourIfNeeded(timeVal);

			timeVal = timeVal.substring(0, 2) + ":" + timeVal.substring(2, 4);

			tmDummySlot = new Time(String.valueOf(timeVal));
		}
		return tmDummySlot;
	}

	private String correctSixtyMinHourIfNeeded(String res)
	{
		if (res == null)
			throw new CodingRuntimeException("res cannot be null in method correctSixtyMinHourIfNeeded");

		if (res.length() >= 2)
		{
			String last2Digits = res.substring((res.length() - 2), res.length());
			if (last2Digits.equals("60"))
			{

				last2Digits = "00";
				String first2Digits = res.substring(0, 2);
				int val = Integer.parseInt(first2Digits);
				if (val < 23)
					val += 1;
				else
					val = 0;

				first2Digits = String.valueOf(val);
				if (first2Digits.length() == 1)
					first2Digits = "0" + first2Digits;

				return first2Digits + last2Digits;
			}
		}

		return res;
	}

	private void updateControlsState()
	{
		form.btnMove().setVisible(form.grdTheatreSlots().getValue() != null);
		
		form.getContextMenus().Scheduling.hideAllBookTheatreSlotMenuItems();
		form.getContextMenus().Scheduling.getBookTheatreSlotADDItem().setVisible(form.grdTheatreSessions().getValue() != null && engine.hasRight(AppRight.CAN_OVERBOOK_THEATRE_APPTS));

	}

	@Override
	protected void onFormDialogClosed(FormName formName, DialogResult result) throws PresentationLogicException
	{
		if (form.getForms().Scheduling.SessionParentChildSlotDialog.equals(formName) && DialogResult.OK.equals(result))
		{
			try
			{
				domain.addSlotToSession(form.grdTheatreSessions().getValue(), form.getGlobalContext().Scheduling.getSessionParentChildSlot());
			}
			catch (StaleObjectException e)
			{
				engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			}
			
			//a slot was added to the current appointment session -> refresh the appointment
			if (form.grdTheatreSessions().getValue() != null && form.getLocalContext().getSelectedAppointment() != null && form.getLocalContext().getSelectedAppointment().getSession() != null && form.grdTheatreSessions().getValue().getID_Sch_Session().equals(form.getLocalContext().getSelectedAppointment().getSession().getID_Sch_Session()))
			{
				AppointmentForTheatreMoveVo appointment = domain.getAppointmentToMove(form.getGlobalContext().Clinical.getTheatreAppointmentRef());
				
				form.getLocalContext().setSelectedAppointment(appointment);
				
				//this is so the slot will have a version for the session  
				if (appointment != null && appointment.getParentChildSlot() != null)
					form.getLocalContext().getSelectedAppointment().getParentChildSlot().setSession(appointment.getSession());
			}
				
			grdSessionSelectionChanged();

		}
		
	}

	@Override
	protected void onContextMenuItemClick(int menuItemID, Control sender) throws PresentationLogicException
	{
		switch (menuItemID)
		{
			case GenForm.ContextMenus.SchedulingNamespace.BookTheatreSlot.ADD:
				form.getGlobalContext().Scheduling.setSessionParentChildSlot(new SessionParentChildSlotVo());
				engine.open(form.getForms().Scheduling.SessionParentChildSlotDialog, "Insert Theatre Slot");
			break;
		}
		
	}
}

class ListOwnerNameComparator implements Comparator<Object>
{
	private int order = 1;

	public ListOwnerNameComparator()
	{
		order = 1;
	}

	public ListOwnerNameComparator(SortOrder order)
	{
		this.order = SortOrder.DESCENDING.equals(order) ? -1 : 1;
	}

	public int compare(Object o1, Object o2)
	{
		{
			SessionListOwnerLiteVo o1Vo = (SessionListOwnerLiteVo) o1;
			SessionListOwnerLiteVo o2Vo = (SessionListOwnerLiteVo) o2;

			if (o1Vo != null && o1Vo.getHcp() != null && o1Vo.getHcp().getMosIsNotNull() && o1Vo.getHcp().getMos().getName() != null && o1Vo.getHcp().getMos().getName().getSurnameIsNotNull() && o2 != null && o2Vo != null && o2Vo.getHcp() != null && o1Vo.getHcp().getMosIsNotNull() && o2Vo.getHcp().getMos().getName() != null && o2Vo.getHcp().getMos().getName().getSurnameIsNotNull())
				return order * o1Vo.getHcp().getMos().getName().getSurname().compareToIgnoreCase(o2Vo.getHcp().getMos().getName().getSurname());

			if (o1Vo == null || !(o1Vo.getHcp() != null) || !o1Vo.getHcp().getMosIsNotNull())
				return -1 * order;

			if (o2Vo == null || !(o2Vo.getHcp() != null) || !o2Vo.getHcp().getMosIsNotNull())
				return order;
		}

		return 0;
	}
}
