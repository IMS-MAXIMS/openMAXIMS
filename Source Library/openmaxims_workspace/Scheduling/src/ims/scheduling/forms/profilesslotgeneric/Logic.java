//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Barbara Worwood using IMS Development Environment (version 1.22 build 50307.1630)
// Copyright (C) 1995-2005 IMS MAXIMS plc. All rights reserved.

package ims.scheduling.forms.profilesslotgeneric;

import ims.configuration.gen.ConfigFlag;
import ims.core.clinical.vo.ServiceFunctionRefVo;
import ims.core.clinical.vo.ServiceFunctionRefVoCollection;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.ActivityVoCollection;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.ServiceFunctionLiteVo;
import ims.core.vo.ServiceFunctionLiteVoCollection;
import ims.core.vo.lookups.ServiceFunction;
import ims.core.vo.lookups.ServiceFunctionCollection;
import ims.domain.exceptions.StaleObjectException;
import ims.framework.enumerations.DialogResult;
import ims.framework.exceptions.PresentationLogicException;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.scheduling.forms.profilesslotgeneric.GenForm.grdClinicTypesRow;
import ims.scheduling.forms.profilesslotgeneric.GenForm.grdDOSRow;
import ims.scheduling.vo.DirectoryOfServiceVoCollection;
import ims.scheduling.vo.DirectoryofServiceRefVoCollection;
import ims.scheduling.vo.ProfileForProfileRippleVo;
import ims.scheduling.vo.ProfileRippleVo;
import ims.scheduling.vo.Profile_ListOwnerVo;
import ims.scheduling.vo.Profile_ListOwnerVoCollection;
import ims.scheduling.vo.Profile_SlotGenericVo;
import ims.scheduling.vo.Profile_SlotGenericVoCollection;
import ims.scheduling.vo.SlotDirectoryOfServiceVo;
import ims.scheduling.vo.SlotDirectoryOfServiceVoCollection;
import ims.scheduling.vo.domain.Profile_SlotGenericVoAssembler;
import ims.scheduling.vo.lookups.SchedCABSlotType;

import java.util.ArrayList;
import java.util.List;


public class Logic extends BaseLogic
{
	protected void onFormOpen(Object[] args) throws ims.framework.exceptions.FormOpenException		//wdev-20262
	{	
		//WDEV-20931
		if(args != null && args.length > 1 && args[0] instanceof LocationLiteVo && args[1] instanceof Boolean)
		{
			form.getLocalContext().setLocation((LocationRefVo) args[0]);
			form.getLocalContext().setIsFlexible((Boolean) args[1]);
		}
		
		if (args != null && args.length > 2 && args[2] instanceof Boolean)
		{
			form.getLocalContext().setProfileHasCBActivity((Boolean) args[2]);
		}
		
		if(form.getGlobalContext().Scheduling.getProfileEndTimeIsNotNull())
			form.lblProfileEndTime().setValue(form.getGlobalContext().Scheduling.getProfileEndTime().toString());
		//wdev-20074
		if( form.getGlobalContext().Scheduling.getProfileStartTimeIsNotNull())
			form.lbllblProfileStartTime().setValue(form.getGlobalContext().Scheduling.getProfileStartTime().toString());
	
		Profile_SlotGenericVo voSlot = form.getGlobalContext().Scheduling.getProfileSlotGeneric();
		
		//WDEV-12039
		form.getLocalContext().setProfileSlotVo(new Profile_SlotGenericVo());
		Profile_SlotGenericVoAssembler.copy(form.getLocalContext().getProfileSlotVo(), voSlot);
		
		loadActivities();

		if(ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Choose and Book"))
			loadDosGrid(form.getGlobalContext().Scheduling.getDirectoryofServicesCollection());
		
		loadListownerCombo();

		setControlStateByConfig();
		
		if (voSlot != null)
		{
			
			populateClinicTypeGridByServiceFunctionsGlobalContext(form.getGlobalContext().Scheduling.getServiceFunctions(), false);	//wdev-20262
			
			this.populateScreenFromData(voSlot);
			//wdev-20262
			if( voSlot.getID_Profile_Slot() == null && voSlot.getIsActive() == null && voSlot.getActivity() == null && voSlot.getPriority() == null )
			{
				
				form.intNoInst().setValue(1);
			
			}
			//wdev-20074
			if( !form.getGlobalContext().Scheduling.getServiceFunctionsIsNotNull() || form.getGlobalContext().Scheduling.getServiceFunctions().size() == 0)
			{
				form.lbl7().setVisible(false);
				form.grdClinicTypes().setVisible(false);
			}
			else
			{
				form.lbl7().setVisible(true);
				form.grdClinicTypes().setVisible(true);
								
			}
			
			
			
			// ------ end of wdev-20074
			
			if(voSlot.getID_Profile_Slot() == null && voSlot.getIsActive() == null)
				form.chkActive().setValue(true);
			

		}
		
		//WDEV-20804
		if (!Boolean.TRUE.equals(form.getLocalContext().getProfileHasCBActivity()))
		{
			form.cmbType().removeRow(SchedCABSlotType.CAB);
			form.cmbType().removeRow(SchedCABSlotType.BOTH);
		}
		
		//WDEV-21166
		form.getLocalContext().setSelectedProfile(form.getGlobalContext().Scheduling.getProfileForProfileRippleVo()); 
		form.dteEffectiveFromDate().setVisible(form.getLocalContext().getSelectedProfileIsNotNull());
		form.lblEffectiveFromDate().setVisible(form.getLocalContext().getSelectedProfileIsNotNull());
	}
	//wdev-20074
	private void populateClinicTypeGridByServiceFunctionsGlobalContext(ServiceFunctionCollection ServiceFunctionsColl, boolean bSelectAll)
	{
		form.grdClinicTypes().getRows().clear();
		
		if(ServiceFunctionsColl == null || ServiceFunctionsColl.size() == 0)
			return;
	
		ServiceFunctionLiteVoCollection voCollServiceFunctions = domain.listServiceFunctionByService(form.getGlobalContext().Scheduling.getProfileService());
		if( voCollServiceFunctions == null || voCollServiceFunctions.size() == 0)
			return;
		
		form.grdClinicTypes().setReadOnly(false);
		for(int i = 0; i < ServiceFunctionsColl.size();i++)
		{
			
			
			ServiceFunction serviceFunction = ServiceFunctionsColl.get(i);
			ServiceFunctionLiteVo tempVo =  getServiceFunctionByFunction(voCollServiceFunctions,serviceFunction);
			
			grdClinicTypesRow row = form.grdClinicTypes().getRows().newRow();
			row.setColClinicType(serviceFunction != null  ? serviceFunction.getText() : null);
			row.setColSelect(bSelectAll);
			row.setValue(tempVo);
		}
	}
	
	private ServiceFunctionLiteVo getServiceFunctionByFunction(ServiceFunctionLiteVoCollection voCollServiceFunctions,ServiceFunction serviceFunction)
	{
		if( voCollServiceFunctions == null || voCollServiceFunctions.size() == 0)
			return null;
		if( serviceFunction == null )
			return null;
		for(int i = 0; i < voCollServiceFunctions.size();i++)
		{
			ServiceFunctionLiteVo tenmpVo = voCollServiceFunctions.get(i); 
			if( tenmpVo != null && serviceFunction.equals(tenmpVo.getFunction()))
			{
				return tenmpVo;
			}
		}
		return null;
	}
	//---------
	
	private void setControlStateByConfig()
	{
		if(ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Local Only"))
		{
			form.cmbType().setValue(SchedCABSlotType.LOCAL);
			form.lblType().setVisible(false);
			form.cmbType().setVisible(false);
			cmbTypeValueChanged();
			
			form.lblDos().setVisible(false);
			form.grdDOS().setVisible(false);
		}
		else
		{			
			form.grdDOS().setReadOnly(false);
		}
		
		updateControlsState();
	}
	
	
	private void updateControlsState()
	{
		form.chkShowAllDos().setVisible(!(ConfigFlag.DOM.SCHEDULING_SLOTS_CREATION.getValue().equals("Local Only")) && (SchedCABSlotType.BOTH.equals(form.cmbType().getValue()) || SchedCABSlotType.CAB.equals(form.cmbType().getValue())) && hasAtLeastOneFunctionSelected());
		
	}
	
	private boolean hasAtLeastOneFunctionSelected()
	{
		for (int i = 0; i < form.grdClinicTypes().getRows().size(); i++)
		{
			grdClinicTypesRow row = form.grdClinicTypes().getRows().get(i);
			
			if (Boolean.TRUE.equals(row.getColSelect()))
				return true;
		}
		
		return false;
	}
	
	private void loadActivities()
	{
		ActivityVoCollection activities = domain.listActivitiesByService(form.getGlobalContext().Scheduling.getProfileService(),form.getLocalContext().getIsFlexible());	// wdev-20074domain.listActivities();	
		for (int i=0; i< activities.size(); i++)
			form.cmbActivity().newRow(activities.get(i),activities.get(i).getName());			
	}

	private void loadDosGrid(DirectoryOfServiceVoCollection dosColl) 
	{
		form.grdDOS().getRows().clear();
		DirectoryOfServiceVoCollection voCollDirService = dosColl;
		if(voCollDirService == null)
			return;
		
		for(int i=0;i<voCollDirService.size();i++)
		{
			grdDOSRow row = form.grdDOS().getRows().newRow();
			row.setColDOS(voCollDirService.get(i));
		}
	}

	private void loadListownerCombo() 
	{
		if (!form.getGlobalContext().Scheduling.getListOwnerCollectionIsNotNull())
			return;
		Profile_ListOwnerVoCollection voColl = form.getGlobalContext().Scheduling.getListOwnerCollection();
		
		for(int i=0;i<voColl.size();i++)
		{
			Profile_ListOwnerVo vo = voColl.get(i);
			if(vo.getHCP() != null && vo.getHCP().getName() != null)
				form.cmbSlotResp().newRow(vo, vo.getHCP().getName().toString());
		}
	}

	protected void onBtnOkClick() throws ims.framework.exceptions.PresentationLogicException
	{
		Profile_SlotGenericVo voSlot = form.getGlobalContext().Scheduling.getProfileSlotGeneric();
		voSlot = this.populateDataFromScreen(voSlot);					
		String[] arrErrors = voSlot.validate(getUIValidation(voSlot));
		if(arrErrors != null)
		{
			engine.showErrors("Validation Errors", arrErrors);
			return;
		}
		
		if(!validateUI())
			return;
		
		form.getGlobalContext().Scheduling.setProfileSlotGeneric(voSlot);
		
		//WDEV-21166
		if (form.getLocalContext().getSelectedProfileIsNotNull())
		{
			if (saveProfileRipple())
			{
				engine.close(DialogResult.OK);
			}
		}
		else
		{
			engine.close(DialogResult.OK);
		}
	}
	
	//WDEV-21166
	private boolean saveProfileRipple()
	{
		ProfileRippleVo profileRippleToSave=populateProfileRippleDataFromScreen();
		
		String[] errors = profileRippleToSave.validate();
		
		if (errors!=null && errors.length>0)
		{
			engine.showErrors(errors);
			return false;
		}
		
		try
		{
			domain.saveProfileRipple(profileRippleToSave); 
		}
		catch (StaleObjectException e)
		{
			engine.showMessage(ConfigFlag.UI.STALE_OBJECT_MESSAGE.getValue());
			return false;
		}
		
		return true;
	}
	
	private ProfileRippleVo populateProfileRippleDataFromScreen()
	{
		ProfileRippleVo profileRipple = new ProfileRippleVo();
		ProfileForProfileRippleVo profile = (ProfileForProfileRippleVo)form.getLocalContext().getSelectedProfile().clone();
		profile.getProfileSlots().add(form.getGlobalContext().Scheduling.getProfileSlotGeneric());
		
		profileRipple.setDateTimeRequested(new DateTime());
		profileRipple.setEffectiveFromDate(form.dteEffectiveFromDate().getValue());
		profileRipple.setProfile(profile);
		profileRipple.setActive(true);
		
		Profile_SlotGenericVoCollection collNewSlots = new Profile_SlotGenericVoCollection();
		collNewSlots.add(form.getGlobalContext().Scheduling.getProfileSlotGeneric());
		profileRipple.setNewSlots(collNewSlots);
		
		return profileRipple;
	}
	
	
	private String[] getUIValidation(Profile_SlotGenericVo voSlot)
	{
		List<String> errors = new ArrayList<String>();
		
		if(voSlot.getTypeIsNotNull())
		{
			if(!voSlot.getType().equals(SchedCABSlotType.LOCAL))
			{
				if(voSlot.getDirectoryOfService() == null || voSlot.getDirectoryOfService().size() == 0)
					errors.add("Directory of Service must be selected for a non-local slot.");
			}
		}
			
		return errors.size() > 0 ? errors.toArray(new String[0]) : null;
	}

	private boolean validateUI()
	{
		List<String> errors = new ArrayList<String>();
		
		if(form.timStart().getValue() != null)
		{
			if (form.getGlobalContext().Scheduling.getProfileStartTimeIsNotNull() && form.timStart().getValue().isLessThan(form.getGlobalContext().Scheduling.getProfileStartTime()))
			 errors.add("Start Time of slots ( " + form.timStart().getValue().toString() +  " ) cannot be earlier than Profile Start Time ( " + form.getGlobalContext().Scheduling.getProfileStartTime() + " )");
			if  (form.getGlobalContext().Scheduling.getProfileEndTimeIsNotNull() && form.timStart().getValue().isGreaterThan(form.getGlobalContext().Scheduling.getProfileEndTime()))
			 errors.add("Start Time of slots ( " + form.timStart().getValue().toString() +  " ) cannot exceed Profile End Time ( " + form.getGlobalContext().Scheduling.getProfileEndTime() + " )");
			if (form.timEnd().getValue() != null && form.timEnd().getValue().isLessOrEqualThan(form.timStart().getValue()))
				errors.add("End Time of slots ( " + form.timEnd().getValue().toString() + " ) cannot be earlier or the same as Start Time of slots.");
		}
		if (!isSlotEndTimeLessThanProfileEndTime())
		{
			Time endTimeToValidate =  calculateEndTime();
			int availableMinutes;
			if (endTimeToValidate == null)
				errors.add("Invalid set of values entered for No. of Slots and/or Slot Duration fields.\nThe resulted end time cannot exceed Profile End Time.");
			else if (endTimeToValidate != null)
			{
				availableMinutes = endTimeToValidate.getTotalMinutes() - form.timStart().getValue().getTotalMinutes();
			
				if (form.intSlotInterval().getValue() != null &&  form.timStart().getValue() != null &&
					((form.intNoSlots().getValue() != null && form.intNoSlots().getValue() * form.intSlotInterval().getValue() > availableMinutes) ||
							( form.intSlotInterval().getValue()  > availableMinutes)))						
					errors.add("Invalid set of values entered for No. of Slots and/or Slot Duration fields. The resulted End Time cannot exceed Profile End Time.");
				if  (endTimeToValidate.isGreaterThan(form.getGlobalContext().Scheduling.getProfileEndTime()))
					errors.add("End Time of slots ( " + form.timEnd().getValue() +  " ) cannot exceed Profile End Time ( " + form.getGlobalContext().Scheduling.getProfileEndTime() + " )");
			}
		}
		
		//WDEV-21166
		if (form.dteEffectiveFromDate().isVisible() &&  form.dteEffectiveFromDate().getValue()==null)
		{
			errors.add("'Effective From Date' is mandatory.");
		}
		
		if (form.dteEffectiveFromDate().isVisible() &&  form.dteEffectiveFromDate().getValue()!=null && form.dteEffectiveFromDate().getValue().isLessThan(new Date()))
		{
			errors.add("'Effective From Date' should be greater than today's date.");
		}
		
		if (form.dteEffectiveFromDate().getValue()!=null && form.getLocalContext().getSelectedProfile()!=null && form.getLocalContext().getSelectedProfile().getLastGenDate()!=null && form.dteEffectiveFromDate().getValue().isGreaterThan(form.getLocalContext().getSelectedProfile().getLastGenDate())) //WDEV-21450
		{
			errors.add("'Effective From Date' is greater than the last generation date for sessions on the profile. In this case no ripple out is required and the profile should be cloned on the Profile Configuration screen and the relevant changes made there.");
		}
		
		String[] arrErrors = errors.toArray(new String[0]);
		if(arrErrors.length > 0)
		{
			engine.showErrors(arrErrors);
			return false;
		}
		
		return true;
	}

	private Time calculateEndTime()
	{
		Time endTime = new Time();
		if (Boolean.TRUE.equals(form.getLocalContext().getbWasEndTimeUserSet()) && form.timEnd().getValue() != null)
			return form.timEnd().getValue();
		if (form.intNoSlots().getValue() * form.intSlotInterval().getValue() > form.getGlobalContext().Scheduling.getProfileEndTime().getTotalMinutes() - form.timStart().getValue().getTotalMinutes())
			return null;
		endTime = (Time) form.timStart().getValue().clone();
		endTime.addMinutes(form.intNoSlots().getValue() * form.intSlotInterval().getValue());
		return endTime;
	}

	private boolean isSlotEndTimeLessThanProfileEndTime()
	{	
		int availableMins = 0;
		if(form.getGlobalContext().Scheduling.getProfileEndTimeIsNotNull() && form.timEnd().getValue() == null)
		{
			if (form.getGlobalContext().Scheduling.getProfileEndTime().isGreaterThan(form.timStart().getValue()))
				availableMins = form.getGlobalContext().Scheduling.getProfileEndTime().getTotalMinutes() - form.timStart().getValue().getTotalMinutes();
		}			
		int requiredMins =  form.timEnd().getValue() == null ?  form.intNoSlots().getValue() * form.intSlotInterval().getValue() : form.timEnd().getValue().getTotalMinutes() - form.timStart().getValue().getTotalMinutes();		
		return requiredMins <= availableMins;
	}

	protected void onBtnCancelClick() throws ims.framework.exceptions.PresentationLogicException
	{
		//WDEV-12039 undo the changes
		form.getGlobalContext().Scheduling.setProfileSlotGeneric(Profile_SlotGenericVoAssembler.copy( form.getGlobalContext().Scheduling.getProfileSlotGeneric() , form.getLocalContext().getProfileSlotVo()));
		engine.close(DialogResult.CANCEL);
	}
	
	protected void clearScreen()
	{
		//form.intDeallocateNumber().setValue(null);		//wdev-20074
		form.chkActive().setValue(false);
		form.intSlotInterval().setValue(null);
		form.timStart().setValue(null);
		form.timEnd().setValue(null);
		form.cmbActivity().setValue(null);
		form.intNoSlots().setValue(null);
		form.cmbPriority().setValue(null);
		form.intNoInst().setValue(null);
	}

	protected void onCmbTypeValueChanged() throws PresentationLogicException
	{
		form.chkShowAllDos().setValue(Boolean.FALSE);
		
		cmbTypeValueChanged();
	}

	private void cmbTypeValueChanged()
	{
			
		if(form.cmbType().getValue() != null)
		{
			if(form.cmbType().getValue().equals(SchedCABSlotType.LOCAL))
			{
				form.grdDOS().setVisible(false);
				form.lblDos().setVisible(false);
				//ServiceFunctionLiteVoCollection voCollServiceFunctions = domain.listServiceFunctionByService(form.getGlobalContext().Scheduling.getProfileService());
				//prepopulateClinicTypeGrid(voCollServiceFunctions, false);		
				form.grdDOS().getRows().clear();
			}
			else if(form.cmbType().getValue().equals(SchedCABSlotType.BOTH) || form.cmbType().getValue().equals(SchedCABSlotType.CAB))
			{
				form.grdDOS().setVisible(true);
				form.lblDos().setVisible(true);
				//loadDos(form.getGlobalContext().Scheduling.getProfileService());	//wdev-20262
				
				if (hasAtLeastOneFunctionSelected() && !Boolean.TRUE.equals(form.chkShowAllDos().getValue()))
					loadDos(form.getGlobalContext().Scheduling.getProfileService());
				else
					loadDosGrid(form.getGlobalContext().Scheduling.getDirectoryofServicesCollection());
				
			}
		}
		else
		{
			//prepopulateClinicTypeGrid(null, false);
			form.chkShowAllDos().setVisible(false);
			form.grdDOS().setVisible(false);
			form.lblDos().setVisible(false);
			form.grdDOS().getRows().clear();
		}
		
		updateControlsState();
		
		//populateSelectedClinicTypesFromData(form.getGlobalContext().Scheduling.getProfileSlotGeneric());
	}
	
	/**
	 * load the config data
	 * @param bSelectAll 
	 */
	private void prepopulateClinicTypeGrid(ServiceFunctionLiteVoCollection voCollServiceFunctions, boolean bSelectAll)
	{
		form.grdClinicTypes().getRows().clear();
	
		if(voCollServiceFunctions == null)
			return;
	
		form.grdClinicTypes().setReadOnly(bSelectAll);
		for(ServiceFunctionLiteVo voServiceFunction : voCollServiceFunctions)
		{
			grdClinicTypesRow row = form.grdClinicTypes().getRows().newRow();
			row.setColClinicType((voServiceFunction != null && voServiceFunction.getFunctionIsNotNull()) ? voServiceFunction.getFunction().getText() : null);
			row.setColSelect(bSelectAll);
			row.setValue(voServiceFunction);
		}
	}

	private DirectoryofServiceRefVoCollection getSelectedDOSs()
	{
		DirectoryofServiceRefVoCollection voCollDos = new DirectoryofServiceRefVoCollection();
		for(int i=0;i<form.grdDOS().getRows().size(); i++)
		{
			grdDOSRow row = form.grdDOS().getRows().get(i); 
			if(row.getColSelect())
				voCollDos.add(row.getColDOS());
		}
		return voCollDos.size() > 0 ? voCollDos : null;
	}

	protected Profile_SlotGenericVo populateDataFromScreen(Profile_SlotGenericVo value)
	{
		value = super.populateDataFromScreen(value);
		
		SlotDirectoryOfServiceVoCollection voCollSlotDos = new SlotDirectoryOfServiceVoCollection();	
		for(int i=0;i<form.grdDOS().getRows().size();i++)
		{
			grdDOSRow row = form.grdDOS().getRows().get(i);
			if(row.getColSelect())
			{			
				SlotDirectoryOfServiceVo voSlotDos = row.getValue();
				if(voSlotDos == null)
					voSlotDos = new SlotDirectoryOfServiceVo();
				
				voSlotDos.setDirectoryOfService(row.getColDOS());
				voCollSlotDos.add(voSlotDos);
			}		
		}
		if( voCollSlotDos != null && voCollSlotDos.size() == 0)	//wdev-20262
			voCollSlotDos = null;
		value.setDirectoryOfService(voCollSlotDos);
		
		ServiceFunctionRefVoCollection voCollServFunc = new ServiceFunctionRefVoCollection();
		for(int i=0;i<form.grdClinicTypes().getRows().size();i++)
		{
			grdClinicTypesRow row = form.grdClinicTypes().getRows().get(i);
			if(row.getColSelect())
			{			
				ServiceFunctionRefVo voServFunc = row.getValue();				
				voCollServFunc.add(voServFunc);
			}		
		}
		value.setFunctions(voCollServFunc);
		
		value.setEndTime(form.timEnd().getValue());
		
		return value;
	}

	protected void populateScreenFromData(Profile_SlotGenericVo value)
	{
		super.populateScreenFromData(value);
		populateSelectedClinicTypesFromData(value);
		
		//this is to populate the show all DOS checkbox
		boolean slotHasDOS = value != null && value.getDirectoryOfService() != null && value.getDirectoryOfService().size() > 0;
		
		if (slotHasDOS)
		{
			ims.core.vo.lookups.ServiceFunctionCollection tempColl = getFunctionsCollFromGeneralDetailsTab();
			DirectoryOfServiceVoCollection dosColl = domain.listDOS(form.getGlobalContext().Scheduling.getProfileService(), tempColl, form.getLocalContext().getLocation());
			DirectoryOfServiceVoCollection commonElements = getCommonElements(dosColl);

			boolean hasMoreDosThanNormal = commonElements != null && commonElements.size() < value.getDirectoryOfService().size();
			boolean differentValuesForDos = dosColl == null || dosColl.size() == 0;
			
			if (commonElements != null && commonElements.size() == value.getDirectoryOfService().size())
			{
				for (int i = 0; i < value.getDirectoryOfService().size(); i++)
				{
					if (!commonElements.contains(value.getDirectoryOfService().get(i).getDirectoryOfService()))
					{
						differentValuesForDos = true;
						break;
					}
				}
			}

			form.chkShowAllDos().setValue(slotHasDOS && (hasMoreDosThanNormal || differentValuesForDos) ? Boolean.TRUE : Boolean.FALSE);

		}
		
		cmbTypeValueChanged();	//wdev-20262
		//wdev-20074
		if( form.cmbActivity().getValues() != null && !form.cmbActivity().getValues().contains(value.getActivity()))
		{
			if( value.getActivity() != null)
			{
				form.cmbActivity().newRow(value.getActivity(), value.getActivity().getName());
				form.cmbActivity().setValue(value.getActivity());
			}
		}
		//-------
		if(value.getDirectoryOfServiceIsNotNull() && value.getDirectoryOfService().size() > 0)
		{
			for(SlotDirectoryOfServiceVo item : value.getDirectoryOfService())
			{
				grdDOSRow row;
				for(int i=0;i<form.grdDOS().getRows().size();i++)
				{
					row = form.grdDOS().getRows().get(i);
					if(row.getColDOS().equals(item.getDirectoryOfService()))
					{
						row.setColSelect(true);
						row.setValue(item);
					}
				}	
			}
			
			
			//add in the itens that were not added because they were removed from the profile without removing from slot
			for(SlotDirectoryOfServiceVo item : value.getDirectoryOfService())
			{
				if(!form.grdDOS().getValues().contains(item))
				{
					grdDOSRow row = form.grdDOS().getRows().newRow();
					row.setColDOS(item.getDirectoryOfService());
					row.setColSelect(true);
				}
			}
		}
		
		
		form.timEnd().setValue(value.getEndTime());
	}

	private void populateSelectedClinicTypesFromData(Profile_SlotGenericVo value)
	{
		if(value == null)
			return;
		
		if(value.getFunctionsIsNotNull() && value.getFunctions().size() > 0)
		{
			for(ServiceFunctionRefVo item : value.getFunctions())
			{
				grdClinicTypesRow row;
				for(int i=0;i<form.grdClinicTypes().getRows().size();i++)
				{
					row = form.grdClinicTypes().getRows().get(i);
					if(row.getValue().equals(item))
					{
						row.setColSelect(true);
					}
				}	
			}
		}
	}
	
	protected void onImbCalculateClick() throws PresentationLogicException
	{
		calculate(form.timStart().getValue(),form.timEnd().getValue(), form.intNoSlots().getValue(), form.intSlotInterval().getValue());
	}

	private void calculate(Time startTime, Time endTime, Integer noOfSlots, Integer slotDuration) //WDEV-19702 
	{		
		//this is mandatory for dialog
		if (form.getGlobalContext().Scheduling.getProfileEndTime() == null)
			return;
		if (form.getGlobalContext().Scheduling.getProfileSlotGeneric() != null && form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDurationIsNotNull() && form.getGlobalContext().Scheduling.getProfileSlotGeneric().getStartTmIsNotNull() && form.getLocalContext().getbWasSlotNoUserSet() == null && form.getLocalContext().getbWasEndTimeUserSet() == null &&  form.getGlobalContext().Scheduling.getProfileSlotGeneric().getStartTm().equals(form.timStart().getValue()) && form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDuration().equals(form.intSlotInterval().getValue()))
			return;  //no re-calculation if no value changed when editing a slot

		
		if (!Boolean.TRUE.equals(form.getLocalContext().getbWasEndTimeUserSet()) || (form.getGlobalContext().Scheduling.getProfileSlotGenericIsNotNull() &&  form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDurationIsNotNull() && !form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDuration().equals(form.intSlotInterval().getValue())))
				form.timEnd().setValue(null);
		if (!Boolean.TRUE.equals(form.getLocalContext().getbWasSlotNoUserSet()) && (Boolean.TRUE.equals(form.getLocalContext().getbWasEndTimeUserSet())) || (form.getGlobalContext().Scheduling.getProfileSlotGenericIsNotNull() &&  form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDurationIsNotNull() && !form.getGlobalContext().Scheduling.getProfileSlotGeneric().getDuration().equals(form.intSlotInterval().getValue())))
				form.intNoSlots().setValue(null);
		

		if ((endTime == null && (noOfSlots == null || noOfSlots != null && !Boolean.TRUE.equals(form.getLocalContext().getbWasSlotNoUserSet())) && slotDuration != null) || (slotDuration != null && endTime != null && !Boolean.TRUE.equals(form.getLocalContext().getbWasSlotNoUserSet()) && !Boolean.TRUE.equals(form.getLocalContext().getbWasEndTimeUserSet())))
			endTime =  form.getGlobalContext().Scheduling.getProfileEndTime();
		
		if(startTime == null || (form.intSlotInterval().getValue() == null || form.intSlotInterval().getValue() == 0))
		{
			engine.showErrors(new String[] {"At least Start Time and Slot Duration need to be provided for slot calculation."});
			return;
		}
		if  (!Boolean.TRUE.equals(form.getLocalContext().getbWasSlotNoUserSet()) && endTime != null)
		{	
			int iDuration = form.intSlotInterval().getValue();
			int iTime = endTime.getTotalMinutes() - startTime.getTotalMinutes();
			
			if (iTime/iDuration == 0)
			{
				form.timEnd().setValue(null);
				form.intNoSlots().setValue(null);
				engine.showErrors(new String[] {"Invalid set of values entered for No. of Slots and/or Slot Duration fields.\nThe resulted end time cannot exceed Profile End Time."});
				return;
			}	
			form.intNoSlots().setValue(iTime/iDuration);
			form.getLocalContext().setbWasSlotNoUserSet(false);
		}

		if (slotDuration != null && !Boolean.TRUE.equals(form.getLocalContext().getbWasEndTimeUserSet()))
		{
			if (noOfSlots == null || !Boolean.TRUE.equals(form.getLocalContext().getbWasSlotNoUserSet())) // WDEV-19959
				noOfSlots = form.intNoSlots().getValue();
			if (noOfSlots != null && ((noOfSlots * slotDuration > (form.getGlobalContext().Scheduling.getProfileEndTime().getTotalMinutes() - startTime.getTotalMinutes()) || (slotDuration > (form.getGlobalContext().Scheduling.getProfileEndTime().getTotalMinutes() - startTime.getTotalMinutes()))))) // WDEV-19959
			{			
				form.timEnd().setValue(null);
				form.intNoSlots().setValue(null);
				engine.showErrors(new String[] {"Invalid set of values entered for No. of Slots and/or Slot Duration fields.\nThe resulted end time cannot exceed Profile End Time."});
				return;
			}	
			form.timEnd().setValue(calculateEndTime(startTime,noOfSlots,slotDuration));
			form.getLocalContext().setbWasEndTimeUserSet(false);
		}	
	}

	private Time calculateEndTime(Time startTime, Integer noOfSlots,Integer slotDuration)
	{
		if (startTime == null)
			return null;
		if (noOfSlots == null) // WDEV-19959 
			return null;
		if (slotDuration == null) 
			return null;
		Time tempTime = (Time) startTime.clone();
		tempTime.addMinutes(noOfSlots*slotDuration);
		
		return new Time(tempTime.toString());
	}

	@Override
	protected void onGrdDOSGridCheckBoxClicked(int column, grdDOSRow row, boolean isChecked) throws PresentationLogicException
	{
		//cmbTypeValueChanged();
		/*for( int i = 0; i < form.grdDOS().getRows().size();i++)
		{
			grdDOSRow rowtemp = form.grdDOS().getRows().get(i);
			if( !row.getColDOS().equals(rowtemp.getColDOS()))
			{
				rowtemp.setColSelect(false);
			}
		}*/
	}

	@Override
	protected void onTimEndValueChanged() throws PresentationLogicException
	{
		boolean isEndTimeSet = form.timEnd().getValue() != null;
		if (isEndTimeSet)
			form.intNoSlots().setValue(null);
		form.getLocalContext().setbWasSlotNoUserSet(false);
		form.getLocalContext().setbWasEndTimeUserSet( isEndTimeSet ? true : false);
		//form.imbCalculate().setTooltip(isEndTimeSet ? "Calculate No. of Slots" : "Calculate End Time");	//wdev-20074
		
	}

	@Override
	protected void onIntNoSlotsValueChanged() throws PresentationLogicException 
	{
		boolean isNoOfSlotsSet = form.intNoSlots().getValue() != null;
		if (isNoOfSlotsSet)
			form.timEnd().setValue(null);
		form.getLocalContext().setbWasEndTimeUserSet(false);
		form.getLocalContext().setbWasSlotNoUserSet(isNoOfSlotsSet ? true : false);
		//form.imbCalculate().setTooltip(isNoOfSlotsSet ? "Calculate End Time" : "Calculate No. of Slots");	//wdev-20074
		
	}

	//wdev-20074
	protected void onBtnCalculateNrOfSlotsEndTimeClick() throws PresentationLogicException
	{
		calculate(form.timStart().getValue(),form.timEnd().getValue(), form.intNoSlots().getValue(), form.intSlotInterval().getValue());
		
	}
	//wdev-20074
	protected void onCmbActivityValueChanged() throws PresentationLogicException
	{
		form.intSlotInterval().setValue(form.cmbActivity().getValue() != null && form.cmbActivity().getValue().getTmReqIsNotNull()?form.cmbActivity().getValue().getTmReq():null);
		
	}
	//wdev-20262
	@Override
	protected void onGrdClinicTypesGridCheckBoxClicked(int column, grdClinicTypesRow row, boolean isChecked) throws PresentationLogicException
	{
		for( int i = 0; i < form.grdClinicTypes().getRows().size();i++)
		{
			grdClinicTypesRow rowtemp = form.grdClinicTypes().getRows().get(i);
			if( !row.getValue().equals(rowtemp.getValue()))
			{
				rowtemp.setColSelect(false);
			}
		}
		if( form.cmbType().getValue() != null && (form.cmbType().getValue().equals(SchedCABSlotType.BOTH) || form.cmbType().getValue().equals(SchedCABSlotType.CAB)))
		{
			loadDos(form.getGlobalContext().Scheduling.getProfileService());
		}
		
		form.chkShowAllDos().setValue(Boolean.FALSE);
		
		updateControlsState();
		
	}
	private void loadDos(ServiceRefVo  voService)
	{
		if( voService != null)
		{
			ims.core.vo.lookups.ServiceFunctionCollection tempColl = getFunctionsCollFromGeneralDetailsTab();	//wdev-20262
			DirectoryOfServiceVoCollection dosColl = domain.listDOS(voService, tempColl, form.getLocalContext().getLocation());	//wdev-20188
			
			
			loadDosGrid(getCommonElements(dosColl));	//wdev-20262
			
		}
	}
	private DirectoryOfServiceVoCollection getCommonElements(DirectoryOfServiceVoCollection domainColl)
	{
		DirectoryOfServiceVoCollection selectedColl = form.getGlobalContext().Scheduling.getDirectoryofServicesCollection();
		
		if (selectedColl == null || selectedColl.size() == 0)
			return null;
		
		DirectoryOfServiceVoCollection commonElements = new DirectoryOfServiceVoCollection();
		
		if (domainColl == null || domainColl.size() == 0)
			return null;
		
		for (int i = 0; i < domainColl.size(); i++)
		{
			if (selectedColl.contains(domainColl.get(i)))
				commonElements.add(domainColl.get(i));
		}
		
		return commonElements;
	}
	//wdev-20262
	private ims.core.vo.lookups.ServiceFunctionCollection getFunctionsCollFromGeneralDetailsTab()
	{
		ims.core.vo.lookups.ServiceFunctionCollection tempColl = new ServiceFunctionCollection();
		 
		if (form.grdClinicTypes().getRows().size() >  0)
		{
			for(int m = 0; m < form.grdClinicTypes().getRows().size();m++)
			{
				grdClinicTypesRow rowF = form.grdClinicTypes().getRows().get(m);
				if( rowF.getColSelect() == true)
				{
					if( rowF.getValue() != null )
						tempColl.add(rowF.getValue().getFunction());
				}
			}
		}
		
		if( tempColl != null && tempColl.size() == 0)
			tempColl = null;
		
		return tempColl;
	}
	
	@Override
	protected void onChkShowAllDosValueChanged() throws PresentationLogicException
	{
		if (Boolean.TRUE.equals(form.chkShowAllDos().getValue()))
			loadDosGrid(form.getGlobalContext().Scheduling.getDirectoryofServicesCollection());
		else
			loadDos(form.getGlobalContext().Scheduling.getProfileService());
	}
	
	//WDEV-21166
	@Override
	protected void onDteEffectiveFromDateValueChanged() throws PresentationLogicException
	{
		//WDEV-21641
		String[] errors = getUIErrorsOnDteEffectiveFromDateValueChanged();
		
		if (errors!=null && errors.length>0)
		{
			engine.showErrors(errors);
		}
	}

	private String[] getUIErrorsOnDteEffectiveFromDateValueChanged() //WDEV-21641
	{
		ArrayList<String> errors = new ArrayList<String>();
		
		if (form.dteEffectiveFromDate().getValue()!=null && form.dteEffectiveFromDate().getValue().isLessThan(new Date()))
		{
			errors.add("'Effective From Date' should be greater than today's date.");
		}
		
		if (form.dteEffectiveFromDate().getValue()!=null && form.getLocalContext().getSelectedProfile()!=null && form.getLocalContext().getSelectedProfile().getLastGenDate()!=null && form.dteEffectiveFromDate().getValue().isGreaterThan(form.getLocalContext().getSelectedProfile().getLastGenDate())) //WDEV-21450
		{
			errors.add("'Effective From Date' is greater than the last generation date for sessions on the profile. In this case no ripple out is required and the profile should be cloned on the Profile Configuration screen and the relevant changes made there.");
		}

		if (errors.size() > 0)
		{
			String[] UIErrors = new String[errors.size()];
			errors.toArray(UIErrors);
			return UIErrors;
		}

		return null;
	}
}
