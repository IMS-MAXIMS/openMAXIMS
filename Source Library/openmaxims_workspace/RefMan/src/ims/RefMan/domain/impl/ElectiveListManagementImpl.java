//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Cornel Ventuneac using IMS Development Environment (version 1.80 build 4972.23166)
// Copyright (C) 1995-2013 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;


import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.helper.Keywords;
import ims.admin.vo.ElectiveListConfigLiteVoCollection;
import ims.admin.vo.ServiceForElectiveListConfigVoCollection;
import ims.admin.vo.domain.ElectiveListConfigLiteVoAssembler;
import ims.admin.vo.domain.ServiceForElectiveListConfigVoAssembler;
import ims.RefMan.domain.BookAppointment;
import ims.RefMan.domain.ReferralAppointmentDetailsComponent;
import ims.RefMan.domain.ReferralStatusList;
import ims.RefMan.domain.base.impl.BaseElectiveListManagementImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIOutcomeForPatientElectiveList;
import ims.RefMan.vo.CatsReferralERODWithElectiveOnlyVo;
import ims.RefMan.vo.CatsReferralListVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.CatsReferralVo;
import ims.RefMan.vo.PatientElectiveListDetailsToSaveVo;
import ims.RefMan.vo.PatientElectiveListForTCIDetailsDialogVo;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.PatientElectiveListShortVoCollection;
import ims.RefMan.vo.PatientElevectiveListManagementVo;
import ims.RefMan.vo.SearchCriteriaForElectiveListManagementVo;
import ims.RefMan.vo.TCIOutcomeForPatientElectiveListRefVo;
import ims.RefMan.vo.TCIOutcomeForPatientElectiveListVo;
import ims.RefMan.vo.TheatreProcedureServiceAndConsultantLiteVo;
import ims.RefMan.vo.domain.CatsReferralERODWithElectiveOnlyVoAssembler;
import ims.RefMan.vo.domain.CatsReferralVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListDetailsToSaveVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListForTCIDetailsDialogVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListShortVoAssembler;
import ims.RefMan.vo.domain.PatientElevectiveListManagementVoAssembler;
import ims.RefMan.vo.domain.TCIOutcomeForPatientElectiveListVoAssembler;
import ims.RefMan.vo.lookups.ERODStatus;
import ims.RefMan.vo.lookups.ElectiveAdmissionType;
import ims.RefMan.vo.lookups.ReferralUrgency;
import ims.RefMan.vo.lookups.WaitingCardAdmissionType;
import ims.chooseandbook.vo.lookups.ActionRequestType;
import ims.core.admin.domain.objects.CareContext;
import ims.core.admin.domain.objects.EpisodeOfCare;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.admin.vo.EpisodeOfCareRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.patient.domain.objects.Patient;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.CareContextShortVo;
import ims.core.vo.EpisodeofCareShortVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.PatientShort;
import ims.core.vo.ProcedureLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.ServiceLiteVo;
import ims.core.vo.domain.CareContextShortVoAssembler;
import ims.core.vo.domain.EpisodeofCareShortVoAssembler;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientShortAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.domain.ProcedureVoAssembler;
import ims.core.vo.domain.ServiceLiteVoAssembler;
import ims.core.vo.lookups.MedicGrade;
import ims.core.vo.lookups.SourceOfReferral;
import ims.core.vo.lookups.TimeUnitsSecondsToMonths;
import ims.core.vo.lookups.WaitingListStatus;
import ims.core.vo.lookups.YesNoUnknown;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.hibernate3.IMSCriteria;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.utils.Date;
import ims.scheduling.domain.PatientAppointmentManagement;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.PatientAppointmentManagementImpl;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Session_Slot;
import ims.scheduling.vo.BookingAppointmentTheatreVo;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.Sch_SessionRefVo;
import ims.scheduling.vo.SessionServiceAndSlotActivityVo;
import ims.scheduling.vo.SessionShortVo;
import ims.scheduling.vo.SessionSlotVo;
import ims.scheduling.vo.Session_SlotRefVo;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.domain.SessionShortVoAssembler;
import ims.scheduling.vo.domain.SessionSlotVoAssembler;
import ims.scheduling.vo.lookups.Rule28DayStatus;

import java.util.ArrayList;
import java.util.List;

public class ElectiveListManagementImpl extends BaseElectiveListManagementImpl
{
	private static final long serialVersionUID = 1L;


	public PatientElectiveListShortVoCollection listElectiveListEntries(SearchCriteriaForElectiveListManagementVo searchCriteria)
	{
		if (searchCriteria == null)
			return null;

		StringBuilder query = new StringBuilder("SELECT patientElectiveList FROM PatientElectiveList AS patientElectiveList ");
		StringBuilder joinQueryPart = new StringBuilder(" LEFT JOIN patientElectiveList.electiveList AS electiveList ");
		joinQueryPart.append(" LEFT JOIN patientElectiveList.referral AS referral LEFT JOIN referral.referralDetails AS referralDetails ");

		StringBuilder conditionQueryPart = new StringBuilder(" WHERE "); 

		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		
		conditionQueryPart.append(" (patientElectiveList.requiresVetting is null OR patientElectiveList.requiresVetting = 0) ");
		String conditionString = " AND ";
		
		
		// Search criteria for Patient Elective List Type
		if (searchCriteria.getType() != null && searchCriteria.getType().size() > 0)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.electiveAdmissionType AS electiveType ");

			conditionQueryPart.append(conditionString);
			conditionQueryPart.append(" electiveType.id IN (");

			for (int i = 0; i < searchCriteria.getType().size(); i++)
			{
				conditionQueryPart.append(searchCriteria.getType().get(i).getID());
				
				if (i < searchCriteria.getType().size() - 1)
					conditionQueryPart.append(", ");
			}
			
			conditionQueryPart.append(") ");
			
			conditionString = " AND ";
		}
		
		// Search criteria for Admission Type
		if (searchCriteria.getAdmissionType() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.admissionType AS admissionType ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" admissionType.id = :ADMISSION_TYPE ");
			paramNames.add("ADMISSION_TYPE");
			paramValues.add(searchCriteria.getAdmissionType().getID());
			
			conditionString = " AND ";
		}
		
		// Search criteria for Urgency
		if (searchCriteria.getUrgency() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.priority AS urgency ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" urgency.id = :URGENCY ");
			paramNames.add("URGENCY");
			paramValues.add(searchCriteria.getUrgency().getID());
			
			conditionString = " AND ";
		}
		
		// Search criteria for 'List only Cancer Referrals'
		if (Boolean.TRUE.equals(searchCriteria.getOnlyCancerReferrals()))
		{
			joinQueryPart.append(" LEFT JOIN referral.urgency AS referralUrgency ");
			joinQueryPart.append(" LEFT JOIN referralDetails.referrerType AS sourceOfReferral ");
			
			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" (referralUrgency.id = :TWO_WEEK_WAIT OR referralUrgency.id = :CONSULTANT_UPGRADE OR sourceOfReferral.id = :NATIONAL_SCREENING) ");
			paramNames.add("TWO_WEEK_WAIT");
			paramValues.add(ReferralUrgency.TWO_WEEK_WAIT.getID());
			paramNames.add("CONSULTANT_UPGRADE");
			paramValues.add(ReferralUrgency.CONSULTANT_UPGRADE.getID());
			paramNames.add("NATIONAL_SCREENING");
			paramValues.add(SourceOfReferral.NATIONAL_SCREENING.getID());
			
			conditionString = " AND ";
		}
		
		
		if (searchCriteria.getHospital() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.hospital AS hospital ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" hospital.id = :HOSPITAL ");
			paramNames.add("HOSPITAL");
			paramValues.add(searchCriteria.getHospital().getID_Location());
			
			conditionString = " AND ";
		}
		
		
		if (searchCriteria.getService() != null)
		{
			conditionString = " AND( ";
			
			joinQueryPart.append(" LEFT JOIN electiveList.service AS service ");
			joinQueryPart.append(" LEFT JOIN referralDetails.service AS referralService ");//WDEV-23010
			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" (service.id = :SERVICE) ");
			conditionQueryPart.append(" OR (referralService.id = :SERVICE AND service.id is null )");//WDEV-23010
			paramNames.add("SERVICE");
			paramValues.add(searchCriteria.getService().getID_Service());
			conditionQueryPart.append(" ) ");
			
			conditionString = " AND ";
		}
		
		
		if (searchCriteria.getConsultant() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.responsibleHCP AS hcp ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" hcp.id = :HCP ");
			paramNames.add("HCP");
			paramValues.add(searchCriteria.getConsultant().getID_Hcp());
			
			conditionString = " AND ";
		}
		
		if (searchCriteria.getProcedure() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.primaryProcedure AS procedure ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" procedure.id = :PROCEDURE ");
			paramNames.add("PROCEDURE");
			paramValues.add(searchCriteria.getProcedure().getID_Procedure());
			
			conditionString = " AND ";
		}
		
		if (searchCriteria.getElectiveListName() != null)
		{
			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" electiveList.id = :ELECTIVE_LIST ");
			paramNames.add("ELECTIVE_LIST");
			paramValues.add(searchCriteria.getElectiveListName().getID_ElectiveListConfiguration());
			
			conditionString = " AND ";
		}
		
		if (searchCriteria.getAnaestheticType() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.anaestheticType AS anaestheticType ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" anaestheticType.id = :ANAESTHETIC_TYPE ");
			paramNames.add("ANAESTHETIC_TYPE");
			paramValues.add(searchCriteria.getAnaestheticType().getID());
			
			conditionString = " AND ";
		}
		
		
		if (searchCriteria.getTheatreType() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.requiredTheatreType AS theatreyType ");

			conditionQueryPart.append(conditionString);
			
			conditionQueryPart.append(" theatreyType.id = :THEATRE_TYPE ");
			paramNames.add("THEATRE_TYPE");
			paramValues.add(searchCriteria.getTheatreType().getID());
			
			conditionString = " AND ";
		}
			
		// Search criteria for 'Elective List Status'
		if (searchCriteria.getElectiveListStatus() != null)
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.electiveListStatus AS electiveListStatus ");
			joinQueryPart.append(" LEFT JOIN electiveListStatus.electiveListStatus AS status ");

			conditionQueryPart.append(conditionString);

			if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_STATUS_REQUIRES_TCI.equals(searchCriteria.getElectiveListStatus()))
			{
				conditionQueryPart.append(" (status.id = :REQUIRES_TCI ");
				paramNames.add("REQUIRES_TCI");
				paramValues.add(WaitingListStatus.REQUIRES_TCI.getID());
				
				if (Boolean.TRUE.equals(searchCriteria.getOnlyCancerReferrals()))
				{
					joinQueryPart.append(" LEFT JOIN patientElectiveList.fitForSurgery AS fitForSurgery ");
					
					conditionQueryPart.append(" OR (status.id = :CREATED AND (fitForSurgery.id <> :NOT_FIT_FOR_SURGERY OR fitForSurgery is null)) ");
					
					paramNames.add("CREATED");
					paramValues.add(WaitingListStatus.CREATED.getID());
					
					paramNames.add("NOT_FIT_FOR_SURGERY");
					paramValues.add(YesNoUnknown.NO.getID());
				}
				
				conditionQueryPart.append(" )");
				
				if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_REQUIRES_TCI_DEFERRED_RECORDDS_FOR_CLINICAL_REASONS.equals(searchCriteria.getElectiveListStatusRequiresTCISubOption()))
				{
					joinQueryPart.append(" LEFT JOIN patientElectiveList.rule28DayStatus AS rule28DayStatus ");

					conditionQueryPart.append(" AND rule28DayStatus.id = :DISCHARGED_DEFERRED_MEDICAL_REASON ");
					
					paramNames.add("DISCHARGED_DEFERRED_MEDICAL_REASON");
					paramValues.add(Rule28DayStatus.DEFERRED_FOR_CLINICAL_REASON.getID());
				}
				else if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_REQUIRES_TCI_28_DAYS_RULE_PATIENTS.equals(searchCriteria.getElectiveListStatusRequiresTCISubOption()))
				{
					conditionQueryPart.append(" AND patientElectiveList.subjectTo28DayRule = 1 ");
				}

				conditionString = " AND ";
			}
			else if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_STATUS_PREASSESSMENT_OUTCOME_REQUIRED.equals(searchCriteria.getElectiveListStatus()))
			{
				conditionQueryPart.append(" (patientElectiveList.preAssessmentRequired = 1 AND patientElectiveList.preAssessmentOutcome is null ");
				conditionQueryPart.append(" AND status.id <> :REMOVED_ELECTIVE_STATUS) ");
				
				paramNames.add("REMOVED_ELECTIVE_STATUS");
				paramValues.add(WaitingListStatus.REMOVED.getID());
				
				conditionString = " AND ";
			}
			else if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_STATUS_NOT_FIT_FOR_SURGERY.equals(searchCriteria.getElectiveListStatus()))
			{
				joinQueryPart.append(" LEFT JOIN patientElectiveList.fitForSurgery AS fitForSurgery ");

				conditionQueryPart.append(" fitForSurgery.id = :NOT_FIT_FOR_SURGERY AND status.id <> :REMOVED_ELECTIVE_STATUS ");
				paramNames.add("NOT_FIT_FOR_SURGERY");
				paramValues.add(YesNoUnknown.NO.getID());
				paramNames.add("REMOVED_ELECTIVE_STATUS");
				paramValues.add(WaitingListStatus.REMOVED.getID());
				
				conditionString = " AND ";
			}
			else if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_STATUS_TCI_GIVEN.equals(searchCriteria.getElectiveListStatus()))
			{
				conditionQueryPart.append(" status.id = :TCI_GIVEN ");
				paramNames.add("TCI_GIVEN");
				paramValues.add(WaitingListStatus.TCI_GIVEN.getID());
				
				conditionString = " AND ";
			}
			else if (ims.RefMan.forms.electivelistmanagement.Logic.ELECTIVE_LIST_STATUS_REMOVED.equals(searchCriteria.getElectiveListStatus()))
			{
				conditionQueryPart.append(" status.id = :REMOVED ");
				paramNames.add("REMOVED");
				paramValues.add(WaitingListStatus.REMOVED.getID());
				
				conditionString = " AND ";
			}
		}
		
		
		// Search criteria for 'Short Notice'
		if (Boolean.TRUE.equals(searchCriteria.getShortNotice()))
		{
			joinQueryPart.append(" LEFT JOIN patientElectiveList.preAssessmentOutcome AS preassessOutcome ");	//wdev-22217
			
			
			conditionQueryPart.append(conditionString);
			conditionQueryPart.append(" ( ( patientElectiveList.availableAtShortNotice = 1");
			
			if (searchCriteria.getDaysNoticeRequired() != null)
			{
				conditionQueryPart.append(" AND patientElectiveList.availableAtShortNoticePeriod <= :SHORT_NOTICE_DAYS ");
				paramNames.add("SHORT_NOTICE_DAYS");
				paramValues.add(searchCriteria.getDaysNoticeRequired());
			}
			
			conditionQueryPart.append(" )");
			//------ wdev-22217
			conditionQueryPart.append(" OR ");
			conditionQueryPart.append(" ( preassessOutcome.shortNotice = 1");
			
			if (searchCriteria.getDaysNoticeRequired() != null)
			{
				conditionQueryPart.append(" AND preassessOutcome.noticePeriodValue <= :SHORT_NOTICE_DAYSPRE ");
				paramNames.add("SHORT_NOTICE_DAYSPRE");
				paramValues.add(searchCriteria.getDaysNoticeRequired());
			}
			
			conditionQueryPart.append(" ) )");
			//---------------
			
			
			
			conditionString = " AND ";
		}
		
		
		// Search criteria for 'RTT Breach Date'
		if (searchCriteria.getRTTBreachIn() != null && searchCriteria.getRTTBreachInPeriod() != null)
		{
			conditionQueryPart.append(conditionString);
			
			// Calculate RTT Breach Date limit
			Date endRTTDate = calculateToDate(searchCriteria.getRTTBreachIn(), searchCriteria.getRTTBreachInPeriod());
			
			conditionQueryPart.append(" referralDetails.end18WW <= :RTT_BREACH_TO_DATE ");
			paramNames.add("RTT_BREACH_TO_DATE");
			paramValues.add(endRTTDate.getDate());
			
			if (!Boolean.TRUE.equals(searchCriteria.getIncludePatientsRTTBreached()))
			{
				conditionQueryPart.append(" AND referralDetails.end18WW >= :RTT_BREACH_FROM_DATE ");
				paramNames.add("RTT_BREACH_FROM_DATE");
				paramValues.add(new Date().getDate());
			}
			
			conditionString = " AND ";
		}
		
		// Search criteria for 'Planned Date'
		if (searchCriteria.getPlannedDateIn() != null && searchCriteria.getPlannedDateInPeriod() != null)
		{
			conditionQueryPart.append(conditionString);
			
			// Calculate Planned Date limit
			Date endPlannedDate = calculateToDate(searchCriteria.getPlannedDateIn(), searchCriteria.getPlannedDateInPeriod());
			
			conditionQueryPart.append(" patientElectiveList.plannedDate <= :PLANNED_TO_DATE ");
			paramNames.add("PLANNED_TO_DATE");
			paramValues.add(endPlannedDate.getDate());
			
			if (!Boolean.TRUE.equals(searchCriteria.getIncludePatientsPastPlannedDates()))
			{
				conditionQueryPart.append(" AND patientElectiveList.plannedDate >= :PLANNED_FROM_DATE ");
				paramNames.add("PLANNED_FROM_DATE");
				paramValues.add(new Date().getDate());
			}
		}
		
		query.append(joinQueryPart).append(conditionQueryPart);
		
		
		if (searchCriteria.getType() == null || searchCriteria.getType().size() == 0)
		{
			query.append(" ORDER BY patientElectiveList.dateOnList ");
		}
		else if (searchCriteria.getType().contains(ElectiveAdmissionType.BOOKED_TYPE12) || searchCriteria.getType().contains(ElectiveAdmissionType.ELECTIVE_TYPE11))
		{
			query.append(" ORDER BY referralDetails.end18WW ");
		}
		else if (searchCriteria.getType().contains(ElectiveAdmissionType.PLANNED_TYPE13))
		{
			query.append(" ORDER BY patientElectiveList.plannedDate ");
		}
		
		
		return PatientElectiveListShortVoAssembler.createPatientElectiveListShortVoCollectionFromPatientElectiveList(getDomainFactory().find(query.toString(), paramNames, paramValues));
	}

	
	
	public LocationLiteVoCollection listHospitals()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}
	
	
	public ServiceForElectiveListConfigVoCollection listServices(String name)
	{
		if (name == null)
			return null;
		
		StringBuilder query = new StringBuilder("SELECT service FROM Service AS service ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append(" WHERE service.upperName LIKE :NAME AND service.isActive = 1 ");
		
		paramNames.add("NAME");
		paramValues.add(name.toUpperCase() + "%");
		
		query.append(" ORDER BY service.upperName");
		
		return ServiceForElectiveListConfigVoAssembler.createServiceForElectiveListConfigVoCollectionFromService(getDomainFactory().find(query.toString(), paramNames, paramValues)); 
	}

	//WDEV-23318
	public ProcedureLiteVoCollection listProcedures(String name, WaitingCardAdmissionType admissionType) throws DomainInterfaceException
	{
		if (name == null || name.length() == 0)
			return null;
		
		DomainFactory factory = getDomainFactory();
		
		StringBuffer query = new StringBuffer(" FROM Procedure proc JOIN proc.keywords AS kw ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append(" WHERE proc.isActive = :isActive");
		paramNames.add("isActive");
		paramValues.add(Boolean.TRUE);
		
		if (WaitingCardAdmissionType.SURGICAL.equals(admissionType))
		{
			query.append(" AND (proc.isEndoscopy is null OR proc.isEndoscopy = 0) AND (proc.medicalWL is null OR proc.medicalWL = 0) ");
		}
		else if (WaitingCardAdmissionType.MEDICAL.equals(admissionType))
		{
			query.append(" AND (proc.medicalWL = 1)");
		}
		else if (WaitingCardAdmissionType.ENDOSCOPY.equals(admissionType))
		{
			query.append(" AND (proc.isEndoscopy = 1)");
		}
		
		return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(Keywords.searchByKeywords(factory, name, query.toString(), paramNames, paramValues));	
	}
	//WDEV-23318 ends here
	
	
	public ElectiveListConfigLiteVoCollection listElectiveListConfigurations(String electiveListName)
	{
		return listElectiveListConfigurations(electiveListName, null, null);
	}
	
	public ElectiveListConfigLiteVoCollection listElectiveListConfigurations(String electiveListName, ServiceRefVo service, HcpRefVo listOwner)  //WDEV-19417
	{
		if (electiveListName == null)
			return null;

		StringBuilder query = new StringBuilder("SELECT electiveList FROM ElectiveListConfiguration AS electiveList ");
		query.append(" LEFT JOIN electiveList.hCPs AS listOwner LEFT JOIN listOwner.hCP AS hcp ");
		query.append(" LEFT JOIN electiveList.service AS service ");
		
		ArrayList<String> paramNames = new ArrayList<String>();
		ArrayList<Object> paramValues = new ArrayList<Object>();
		
		query.append(" WHERE UPPER(electiveList.waitingListName) LIKE :ELECTIVE_LIST_NAME AND electiveList.isActive = 1 ");
		paramNames.add("ELECTIVE_LIST_NAME");
		paramValues.add(electiveListName.toUpperCase() + "%");
		
		if (service != null && service.getID_Service() != null)
		{
			query.append(" AND service.id = :SERVICE ");
			paramNames.add("SERVICE");
			paramValues.add(service.getID_Service());
		}
		
		if (listOwner != null && listOwner.getID_Hcp() != null)
		{
			query.append(" AND hcp.id = :HCP");
			paramNames.add("HCP");
			paramValues.add(listOwner.getID_Hcp());
		}
		
		query.append(" ORDER BY UPPER(electiveList.waitingListName) ASC ");
		
		return ElectiveListConfigLiteVoAssembler.createElectiveListConfigLiteVoCollectionFromElectiveListConfiguration(getDomainFactory().find(query.toString(), paramNames, paramValues)); 
	}

	
	private Date calculateToDate(Integer rttBreachIn, TimeUnitsSecondsToMonths rttBreachInPeriod)
	{
		if (rttBreachIn == null || rttBreachInPeriod == null)
			return null;
		
		if (TimeUnitsSecondsToMonths.DAYS.equals(rttBreachInPeriod))
		{
			return (new Date()).addDay(rttBreachIn);
		}
		else if (TimeUnitsSecondsToMonths.WEEKS.equals(rttBreachInPeriod))
		{
			return (new Date()).addDay(7 * rttBreachIn);
		}
		else if (TimeUnitsSecondsToMonths.MONTHS.equals(rttBreachInPeriod))
		{
			return (new Date()).addMonth(rttBreachIn);
		}
		
		return new Date();
	}






//	public ims.RefMan.vo.PatientElevectiveListManagementVoCollection getElectiveListEntries(ims.admin.vo.ServiceForElectiveListConfigVo service, String electivelistname, String electivelistcode, ims.core.vo.HcpLiteVo consultant, ims.framework.utils.Date datefrom, ims.framework.utils.Date dateto, ims.core.vo.lookups.WaitingListStatus status, Boolean showAdmitted, Boolean showSuspended, Boolean show28Day, ProcedureLiteVo procedure, LocationRefVo hospital, LocationRefVo ward, ReferralUrgency urgency, ElectiveAdmissionType electiveType) //wdev-18596, wdev-18662 //WDEV-19348, wdev-19535 //WDEV-19699
//	{
//		if (service == null && electivelistname == null && electivelistcode == null && consultant == null && datefrom == null && dateto == null && status == null && procedure == null && hospital==null && ward==null && electiveType==null) //WDEV-19348 //WDEV-19699
//			throw new CodingRuntimeException("At least one search criteria must be provided");
//
//		DomainFactory factory = getDomainFactory();
//
//		StringBuffer hqlConditions = new StringBuffer();
//		
//		StringBuffer hql = new StringBuffer("select p1_1 from PatientElectiveList as p1_1 left join p1_1.electiveList as w1_1 left join p1_1.electiveListStatus as e1_1 left join e1_1.electiveListStatus as l1_1 left join p1_1.tCIDetails as p2_1 left join p2_1.currentOutcome as t2_1 left join t2_1.outcome as l2_1");
//		
//		ArrayList<String> markers = new ArrayList<String>();
//		ArrayList<Object> values = new ArrayList<Object>();
//
//		String andStr = "";
//		if( service != null)
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" w1_1.service.id = :Service ");
//			markers.add("Service");
//			values.add(service.getID_Service());
//			andStr = " and ";
//		}
//		if( electivelistname != null )
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" UPPER(w1_1.waitingListName) like :WaitingListName ");
//			markers.add("WaitingListName");
//			values.add(electivelistname.toUpperCase()+"%");
//			andStr = " and ";
//		}
//		if( electivelistcode != null )
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" UPPER(w1_1.waitingListCode) like :WaitingListCode ");
//			markers.add("WaitingListCode");
//			values.add(electivelistcode.toUpperCase()+"%");
//			andStr = " and ";
//		}
//		//wdev-19535
//		if( urgency != null)
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" p1_1.priority.id = :urgency ");
//			markers.add("urgency");
//			values.add(getDomLookup(urgency).getId());
//			andStr = " and ";
//		}
//		//--------------
//		if( consultant != null )
//		{
//			hql.append(" left join p1_1.consultant as consultants ");
//			hqlConditions.append(andStr);
//			hqlConditions.append(" consultants.id = :consultantId");
//			markers.add("consultantId");
//			values.add(consultant.getID_Hcp());
//			andStr = " and ";
//		}
//		//wdev-18662
//		if( procedure != null )
//		{
//			hql.append(" left join p1_1.primaryProcedure as proc_1 ");
//			hqlConditions.append(andStr);
//			hqlConditions.append(" proc_1.id = :ProcedureId");
//			markers.add("ProcedureId");
//			values.add(procedure.getID_Procedure());
//			andStr = " and ";
//		}
//		
//		//WDEV-19348
//		if( hospital != null )
//		{
//			hql.append(" left join p1_1.tCIDetails as tciDet left join tciDet.tCIHospital as hospital ");
//			hqlConditions.append(andStr);
//			hqlConditions.append(" hospital.id = :hospitalID ");
//			markers.add("hospitalID");
//			values.add(hospital.getID_Location());
//			andStr = " and ";
//		}
//		
//		if( ward != null )
//		{
//			hql.append(" left join p1_1.tCIDetails as tciDet left join tciDet.tCIWard as ward ");
//			hqlConditions.append(andStr);
//			hqlConditions.append(" ward.id = :wardID ");
//			markers.add("wardID");
//			values.add(ward.getID_Location());
//			andStr = " and ";
//		}
//		
//		
//		
//		if( status != null )
//		{
//			if( WaitingListStatus.REQUIRES_TCI.equals(status) && !ElectiveAdmissionType.PLANNED_TYPE13.equals(electiveType) ) //WDEV-19107 //WDEV-19699
//			{
//				if( datefrom != null )
//				{
//					hqlConditions.append(andStr);
//					hqlConditions.append(" p1_1.dateOnList >= :dateFrom ");
//					markers.add("dateFrom");
//					DateTime fromDateTime = new DateTime(datefrom, new Time(0, 0));
//					values.add(fromDateTime.getJavaDate());
//					andStr = " and ";
//				}
//
//				if( dateto != null)
//				{
//					hqlConditions.append(andStr);
//					hqlConditions.append(" p1_1.dateOnList <= :dateTo ");
//					markers.add("dateTo");
//					DateTime toDateTime = new DateTime( dateto, new Time(0, 0));
//					values.add(toDateTime.getJavaDate());
//					andStr = " and ";
//				}
//
//				hqlConditions.append(andStr);
//				hqlConditions.append(" (e1_1.electiveListStatus.id = :Status or e1_1.electiveListStatus.id = :Status1) ");
//				markers.add("Status");
//				markers.add("Status1");
//				values.add(getDomLookup(WaitingListStatus.CREATED).getId());
//				values.add(getDomLookup(WaitingListStatus.REQUIRES_TCI).getId());
//				andStr = " and ";
//			}
//			else if( WaitingListStatus.REQUIRES_TCI.equals(status) && ElectiveAdmissionType.PLANNED_TYPE13.equals(electiveType) ) //WDEV-19699
//			{
//				if( datefrom != null )
//				{
//					hqlConditions.append(andStr);
//					hqlConditions.append(" p2_1.plannedTCIDate >= :dateFrom ");
//					markers.add("dateFrom");
//					DateTime fromDateTime = new DateTime(datefrom, new Time(0, 0));
//					values.add(fromDateTime.getJavaDate());
//					andStr = " and ";
//				}
//
//				if( dateto != null)
//				{
//					hqlConditions.append(andStr);
//					hqlConditions.append(" p2_1.plannedTCIDate <= :dateTo ");
//					markers.add("dateTo");
//					DateTime toDateTime = new DateTime( dateto, new Time(0, 0));
//					values.add(toDateTime.getJavaDate());
//					andStr = " and ";
//				}
//
//				hqlConditions.append(andStr);
//				hqlConditions.append(" (e1_1.electiveListStatus.id = :Status ) ");
//				markers.add("Status");
//				values.add(getDomLookup(WaitingListStatus.REQUIRES_TCI).getId());
//				andStr = " and ";
//			}
//			
//			else 
//			{	
//				if ( WaitingListStatus.TCI_GIVEN.equals(status))
//				{
//					if( datefrom != null )
//					{
//						hqlConditions.append(andStr);
//						hqlConditions.append(" p2_1.tCIDate >= :dateFrom ");
//						markers.add("dateFrom");
//						DateTime fromDateTime = new DateTime(datefrom, new Time(0, 0));
//						values.add(fromDateTime.getJavaDate());
//						andStr = " and ";
//					}
//
//					if( dateto != null)
//					{
//						hqlConditions.append(andStr);
//						hqlConditions.append(" p2_1.tCIDate <= :dateTo ");
//						markers.add("dateTo");
//						DateTime toDateTime = new DateTime( dateto, new Time(0, 0));
//						values.add(toDateTime.getJavaDate());
//						andStr = " and ";
//					}
//				}
//				else
//				{
//					if( datefrom != null )
//					{
//						hqlConditions.append(andStr);
//						hqlConditions.append(" p1_1.dateOnList >= :dateFrom ");
//						markers.add("dateFrom");
//						DateTime fromDateTime = new DateTime(datefrom, new Time(0, 0));
//						values.add(fromDateTime.getJavaDate());
//						andStr = " and ";
//					}
//
//					if( dateto != null)
//					{
//						hqlConditions.append(andStr);
//						hqlConditions.append(" p1_1.dateOnList <= :dateTo ");
//						markers.add("dateTo");
//						DateTime toDateTime = new DateTime( dateto, new Time(0, 0));
//						values.add(toDateTime.getJavaDate());
//						andStr = " and ";
//					}
//				}
//				
//				hqlConditions.append(andStr); 
//				hqlConditions.append(" e1_1.electiveListStatus.id = :Status ");
//				markers.add("Status");
//				values.add(status.getID());
//				andStr = " and ";
//			}	
//		}
//		else
//		{
//			if( datefrom != null )
//			{
//				hqlConditions.append(andStr);
//				if (ElectiveAdmissionType.PLANNED_TYPE13.equals(electiveType)) //WDEV-19940
//				{
//					hqlConditions.append(" p2_1.plannedTCIDate >= :dateFrom ");
//				}
//				else
//				{
//					hqlConditions.append(" p1_1.dateOnList >= :dateFrom ");
//				}
//				markers.add("dateFrom");
//				DateTime fromDateTime = new DateTime(datefrom, new Time(0, 0));
//				values.add(fromDateTime.getJavaDate());
//				andStr = " and ";
//			}
//
//			if( dateto != null)
//			{
//				hqlConditions.append(andStr);
//				if (ElectiveAdmissionType.PLANNED_TYPE13.equals(electiveType)) //WDEV-19940
//				{
//					hqlConditions.append(" p2_1.plannedTCIDate <= :dateTo ");
//				}
//				else
//				{
//					hqlConditions.append(" p1_1.dateOnList <= :dateTo ");
//				}
//				
//				markers.add("dateTo");
//				DateTime toDateTime = new DateTime( dateto, new Time(0, 0));
//				values.add(toDateTime.getJavaDate());
//				andStr = " and ";
//			}
//			
//			hqlConditions.append(andStr);
//			hqlConditions.append(" (e1_1.electiveListStatus.id = :Status or e1_1.electiveListStatus.id = :Status1) ");
//			markers.add("Status");
//			markers.add("Status1");
//			values.add(getDomLookup(WaitingListStatus.CREATED).getId());
//			values.add(getDomLookup(WaitingListStatus.REQUIRES_TCI).getId());
//			andStr = " and ";
//		}
//		if( Boolean.TRUE.equals(showAdmitted))
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" (l2_1.id = :Status) ");
//			markers.add("Status");
//			values.add(getDomLookup(AdmissionOfferOutcome.PATIENT_ADMITTED_TREATMENT_DEFERRED_5).getId());
//			andStr = " and ";
//		}
//		if( Boolean.TRUE.equals(showSuspended))
//		{
//			hqlConditions.append(andStr);
//			//wdev-18361
//			hqlConditions.append(" (p1_1.currentSuspensionEndDate is not null  and p1_1.currentSuspensionEndDate <= :enddate) ");   
//			markers.add("enddate");
//			DateTime toDateTime = new DateTime();
//			values.add(toDateTime.getJavaDate());
//			andStr = " and ";
//		}
//		
//		//WDEV-19699
//		if (electiveType!=null)
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" p1_1.electiveAdmissionType.id = :electiveAdmType ");
//			markers.add("electiveAdmType");
//			values.add(electiveType.getId());
//			andStr = " and ";
//		}
//		
//		//wdev-18596
//		if( Boolean.TRUE.equals(show28Day))
//		{
//			hqlConditions.append(andStr);
//			hqlConditions.append(" (p1_1.was28DayRuleApplied = 1) ");			// Temporary fix for WDEV-20587 - this form will be reviewed
////			hqlConditions.append(" (p1_1.tCIDetails is null and p1_1.requiresTCIBy <= :add28Days) ");   
////			markers.add("add28Days");
////			DateTime add28Day = (new DateTime()).addDays(28);
////			values.add(add28Day.getJavaDate());
//			andStr = " and ";
//		}
//		String strOrder = "";
//		
//		if (Boolean.TRUE.equals(show28Day))
//		{
//			strOrder="order by p1_1.requiresTCIBy asc";
//		}
//		else
//		{
//			strOrder="order by p1_1.dateOnList desc";
//		}
//		
//		if (hqlConditions.length() > 0)
//		{
//			hqlConditions.insert(0, " where (");
//			hqlConditions.append(" ) ");
//		}
//
//		List<?> list = factory.find(hql.toString() + hqlConditions.toString() + strOrder, markers, values, 2000);//wdev-18596
//
//		if (list == null || list.size() == 0)
//			return null;
//		
//		
//		return PatientElevectiveListManagementVoAssembler.createPatientElevectiveListManagementVoCollectionFromPatientElectiveList(list);
//	}

	public ims.core.vo.HcpLiteVoCollection listConsultants(String name)
	{
		if(name == null || (name != null && name.length() == 0))
			throw new DomainRuntimeException("Can not search on null name.");
		
		StringBuffer hqlConditions = new StringBuffer();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		
		String hql = "select medic.mos.hcp from Medic as medic where medic.isActive = 1 and (medic.mos.name.upperSurname like :hcpSname or medic.mos.name.upperForename like :hcpFname) and medic.grade.id =:idMedicGrade";
		markers.add("hcpSname");
		values.add(name.toUpperCase() + "%");
		
		markers.add("hcpFname");
		values.add(name.toUpperCase() + "%");
		
		markers.add("idMedicGrade");
		values.add(getDomLookup(MedicGrade.CONS).getId());

		DomainFactory factory = getDomainFactory();
		List<?> list = factory.find((hql + hqlConditions.toString() + " order by medic.mos.name.upperSurname , medic.mos.name.upperForename asc").toString(), markers, values,400);
		 
		if (list != null && list.size() > 0)
			return HcpLiteVoAssembler.createHcpLiteVoCollectionFromHcp(list);
			
		return null;
	}

	public PatientElectiveListForTCIDetailsDialogVo save(PatientElectiveListForTCIDetailsDialogVo record) throws StaleObjectException, UniqueKeyViolationException
	{
		DomainFactory factory = getDomainFactory();
		PatientElectiveList doPatientElectiveList = PatientElectiveListForTCIDetailsDialogVoAssembler.extractPatientElectiveList(factory, record);
		if( doPatientElectiveList != null)
			factory.save(doPatientElectiveList);
		
		return PatientElectiveListForTCIDetailsDialogVoAssembler.create(doPatientElectiveList);
	}

	public PatientElectiveListForTCIDetailsDialogVo getPatientElecticeList(PatientElectiveListRefVo record)
	{
		DomainFactory factory = getDomainFactory();
		PatientElectiveList doPatientElectiveList = (PatientElectiveList)factory.getDomainObject(PatientElectiveList.class, record.getID_PatientElectiveList());
		return PatientElectiveListForTCIDetailsDialogVoAssembler.create(doPatientElectiveList);
	}

	public CatsReferralERODWithElectiveOnlyVo getCatsReferralErod(CatsReferralRefVo catsRef)
	{
		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral)factory.getDomainObject(CatsReferral.class, catsRef.getID_CatsReferral());
		return CatsReferralERODWithElectiveOnlyVoAssembler.create(doCatsReferral);

	}

	public SessionServiceAndSlotActivityVo getServiceAndActivityByAppt(Booking_AppointmentRefVo appt, Boolean isFlexible)
	{
		PatientAppointmentManagement impl = (PatientAppointmentManagement)getDomainImpl(PatientAppointmentManagementImpl.class);
		return impl.getServiceAndActivityByAppt(appt, isFlexible);
	}
	
	public SessionSlotVo getSessionSlot(Session_SlotRefVo slotRef)
	{
		if (slotRef == null || !slotRef.getID_Session_SlotIsNotNull())
			throw new DomainRuntimeException("Invalid Session Slot reference provided.");
		return SessionSlotVoAssembler.create((Session_Slot) getDomainFactory().getDomainObject(Session_Slot.class, slotRef.getID_Session_Slot()));
	
	}

	public CatsReferralListVo getCatsReferral(CatsReferralRefVo voReferralRef)
	{
		ReferralStatusList impl = (ReferralStatusList) getDomainImpl(ReferralStatusListImpl.class);
		return impl.getCatsReferral(voReferralRef);		
	}

	public Booking_AppointmentVo cancelAppt(Booking_AppointmentVo appt, ActionRequestType requestType, String requestSource) throws StaleObjectException, DomainInterfaceException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		return impl.cancelAppt(appt, requestType, requestSource);
	}

	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(catsReferral,null);	
		
	}

	public void updateCatsReferralCancelStatus(CatsReferralRefVo catsReferral) throws StaleObjectException
	{
		ReferralAppointmentDetailsComponent impl = (ReferralAppointmentDetailsComponent) getDomainImpl(ReferralAppointmentDetailsComponentImpl.class);
		impl.updateCatsReferralCancelStatus(catsReferral);
		
	}

	public CatsReferralRefVo getCatsReferralForAppointment(Booking_AppointmentRefVo appt)
	{
		if(appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provide for getCatsReferralForAppointment");
		
		DomainFactory factory = getDomainFactory();
		List<?> catsRefId = factory.find("select catsRef.id from CatsReferral as catsRef left join catsRef.appointments as bookAppt where (bookAppt.id = '" + appt.getID_Booking_Appointment() + "')");
		if(catsRefId != null)
		{
			Integer val = (Integer) catsRefId.get(0);
			if(val != null && val.intValue() > 0)
			{
				return new CatsReferralRefVo(val, 0);
			}
		}	
		return null;
	}
	
	public PatientShort getPatient(PatientRefVo patient)
	{
		if (patient!=null)
			if (patient.getID_Patient()!=null)
			{
				IMSCriteria imsc=new IMSCriteria(Patient.class,getDomainFactory());
				imsc.equal("this.id", patient.getID_Patient());
				List<?> patients = imsc.find();
				if (patients.size()>0)
					return PatientShortAssembler.create((Patient) patients.get(0));
				return null;
			}
		return null;
	}

	public SessionShortVo getSessionShortVo(Sch_SessionRefVo sessVo)
	{
		if(sessVo == null)
			throw new CodingRuntimeException("sessVo is null");
		
		DomainFactory factory = getDomainFactory();
		Sch_Session doSch_Session = (Sch_Session)factory.getDomainObject(Sch_Session.class, sessVo.getID_Sch_Session());
		return SessionShortVoAssembler.create(doSch_Session);
	}

	public Booking_AppointmentVo getBookingAppointment(Booking_AppointmentRefVo appt)
	{
		BookAppointment impl = (BookAppointment) getDomainImpl(BookAppointmentImpl.class);
		return impl.getBookingAppointment(appt);
	}

	public void cancelReferralEROD(CatsReferralRefVo catsReferral, Booking_AppointmentRefVo apptRef) throws StaleObjectException
	{
		if(catsReferral == null || catsReferral.getID_CatsReferral() == null)
			throw new CodingRuntimeException("catsReferral is null or id not provided in method cancelReferralEROD");
		
		if(apptRef == null || apptRef.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("apptRef is null or id not provided in method getTheatreAppointment");
		
		DomainFactory factory = getDomainFactory();
		CatsReferral doCatsReferral = (CatsReferral) factory.getDomainObject(catsReferral);
		
		if(doCatsReferral.getElectiveEROD() == null)
			return;
		
		ReferralEROD doErod = null;
		
		for(int i=0; i<doCatsReferral.getElectiveEROD().size(); i++)
		{
			if(doCatsReferral.getElectiveEROD().get(i) instanceof ReferralEROD)
			{
				if(((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getAppointment() != null && ((ReferralEROD) doCatsReferral.getElectiveEROD().get(i)).getAppointment().getId().equals(apptRef.getID_Booking_Appointment()))
				{
					doErod = (ReferralEROD) doCatsReferral.getElectiveEROD().get(i);
					doCatsReferral.getElectiveEROD().remove(doErod);
					break;
				}
			}
		}
		
		if(doErod != null)
		{
			doErod.setErodStatus(getDomLookup(ERODStatus.CANCELLED));
		
			if(doCatsReferral.getElectiveERODHistory() == null)
				doCatsReferral.setElectiveERODHistory(new java.util.ArrayList());
		
			doCatsReferral.getElectiveERODHistory().add(doErod);
		
			factory.save(doCatsReferral);
		}
		
	}

	public BookingAppointmentTheatreVo getTheatreAppointment(Booking_AppointmentRefVo appt)
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided in method getTheatreAppointment");
		
		return BookingAppointmentTheatreVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(appt));
	}

	public TheatreProcedureServiceAndConsultantLiteVo getTheatreServiceProcedureAndConsultant(Booking_AppointmentRefVo voAppt)
	{
		if (voAppt == null || voAppt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided in method getTheatreServiceProcedureAndConsultant");
		
		TheatreProcedureServiceAndConsultantLiteVo voPsc = null;
		
		Booking_Appointment doAppt = (Booking_Appointment)getDomainFactory().getDomainObject(voAppt);
		if(doAppt != null)
		{
			ServiceLiteVo voService = ServiceLiteVoAssembler.create(doAppt.getSession() != null ? doAppt.getSession().getService() : null);
			ProcedureLiteVo voProc = ProcedureLiteVoAssembler.create(doAppt.getTheatreBooking() != null ? doAppt.getTheatreBooking().getProcedure() : null);
			HcpLiteVo voMos = HcpLiteVoAssembler.create(doAppt.getTheatreBooking() != null ? doAppt.getTheatreBooking().getConsultant() : null);
			
			voPsc = new TheatreProcedureServiceAndConsultantLiteVo();
			voPsc.setService(voService);
			voPsc.setProcedure(voProc);
			voPsc.setConsultant(voMos);
		}
		
		return voPsc;
	}

	public CatsReferralVo getCatsReferralVo(CatsReferralRefVo voCatsRef)
	{
		if( voCatsRef == null )
			return null;
		
		return CatsReferralVoAssembler.create((CatsReferral)getDomainFactory().getDomainObject(CatsReferral.class, voCatsRef.getID_CatsReferral()));
	}

	public EpisodeofCareShortVo getEpisodeofCareShortVo(EpisodeOfCareRefVo episode)
	{
		if( episode == null )
			return null;
		
		return EpisodeofCareShortVoAssembler.create((EpisodeOfCare)getDomainFactory().getDomainObject(EpisodeOfCare.class, episode.getID_EpisodeOfCare()));
	}

	public CareContextShortVo getCareContextShortVo(CareContextRefVo voCareContextRef)
	{
		if (voCareContextRef == null)
			throw new RuntimeException("Cannot get CareContextShortVo for null CareContextRefVo");

		CareContext doCareContext = (CareContext) getDomainFactory().getDomainObject(CareContext.class, voCareContextRef.getID_CareContext());
		return CareContextShortVoAssembler.create(doCareContext);
	}

	//wdev-18361
	public PatientElectiveListDetailsToSaveVo getPatientElectiveListDetailsToSaveVo(PatientElectiveListRefVo record)
	{
		if( record == null )
			throw new RuntimeException("Cannot get PatientElectiveListRefVo for null PatientElectiveListRefVo");
		
		PatientElectiveList doPatientElectiveList = (PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, record.getID_PatientElectiveList());
		return PatientElectiveListDetailsToSaveVoAssembler.create(doPatientElectiveList);
	}

	
	//WDEV-19348
	public LocationLiteVoCollection listWards(String strName, LocationRefVo locationRef)
	{
		OrganisationAndLocation orgAdmin = (OrganisationAndLocation)getDomainImpl(OrganisationAndLocationImpl.class);
		return orgAdmin.listActiveWardsForHospitalByNameLite(locationRef, strName);
	}

	public LocationLiteVo getLocation(Integer locationId)
	{
		DomainFactory factory = getDomainFactory();
		return LocationLiteVoAssembler.create((Location) factory.getDomainObject(Location.class, locationId));
	}


	public PatientElevectiveListManagementVo getPatientElectiveListManagement(PatientElectiveListRefVo patientElectiveList)
	{
		if (patientElectiveList == null || patientElectiveList.getID_PatientElectiveList() == null)
			return null;
		
		return PatientElevectiveListManagementVoAssembler.create((PatientElectiveList) getDomainFactory().getDomainObject(PatientElectiveList.class, patientElectiveList.getID_PatientElectiveList()));
	}


	public TCIOutcomeForPatientElectiveListVo getTCIOutcomeToCancel(TCIOutcomeForPatientElectiveListRefVo tciOutcome)
	{
		if (tciOutcome == null || tciOutcome.getID_TCIOutcomeForPatientElectiveList() == null)
			return null;
		
		return TCIOutcomeForPatientElectiveListVoAssembler.create((TCIOutcomeForPatientElectiveList) getDomainFactory().getDomainObject(TCIOutcomeForPatientElectiveList.class, tciOutcome.getID_TCIOutcomeForPatientElectiveList()));
	}


	public void cancelTCI(PatientElectiveListRefVo patientElectiveList, TCIOutcomeForPatientElectiveListVo tciOutcome, Booking_AppointmentRefVo appointment) throws StaleObjectException
	{
		ReferralAppointmentDetailsComponent impl = (ReferralAppointmentDetailsComponent) getDomainImpl(ReferralAppointmentDetailsComponentImpl.class);
		impl.cancelTCI(patientElectiveList, tciOutcome, appointment);
	}


	public void updateCatsReferralAdditionalInvStatus(CatsReferralRefVo referral, Booking_AppointmentRefVo appointment) throws StaleObjectException
	{
		ReferralAppointmentDetailsComponent impl = (ReferralAppointmentDetailsComponent) getDomainImpl(ReferralAppointmentDetailsComponentImpl.class);
		impl.updateCatsReferralAdditionalInvStatus(referral, appointment);
	}
}
