//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Daniel Laffan using IMS Development Environment (version 1.80 build 4198.17562)
// Copyright (C) 1995-2011 IMS MAXIMS. All rights reserved.

package ims.RefMan.domain.impl;

import ims.admin.domain.OrganisationAndLocation;
import ims.admin.domain.impl.OrganisationAndLocationImpl;
import ims.admin.vo.CaseNoteTrackingConfigVo;
import ims.admin.vo.ElectiveListConfigurationVoCollection;
import ims.admin.vo.domain.CaseNoteTrackingConfigVoAssembler;
import ims.admin.vo.domain.ElectiveListConfigurationVoAssembler;
import ims.admin.vo.lookups.HardCodedEvents;
import ims.RefMan.domain.BookTheatre;
import ims.RefMan.domain.base.impl.BaseBookTheatreSlotDetailDialogImpl;
import ims.RefMan.domain.objects.CatsReferral;
import ims.RefMan.domain.objects.PatientElectiveList;
import ims.RefMan.domain.objects.ReferralEROD;
import ims.RefMan.domain.objects.TCIForPatientElectiveList;
import ims.RefMan.vo.CatsReferralForNewElectivListEntryVo;
import ims.RefMan.vo.CatsReferralRefVo;
import ims.RefMan.vo.ElectiveTCIForReferralDetailsVo;
import ims.RefMan.vo.PatientElectiveListRefVo;
import ims.RefMan.vo.PatientElectiveListVo;
import ims.RefMan.vo.PatientElectiveListVoCollection;
import ims.RefMan.vo.ReferralERODForBookTheatreVo;
import ims.RefMan.vo.ReferralERODRefVo;
import ims.RefMan.vo.ReferralERODVo;
import ims.RefMan.vo.domain.CatsReferralForNewElectivListEntryVoAssembler;
import ims.RefMan.vo.domain.ElectiveTCIForReferralDetailsVoAssembler;
import ims.RefMan.vo.domain.PatientElectiveListVoAssembler;
import ims.RefMan.vo.domain.ReferralERODForBookTheatreVoAssembler;
import ims.RefMan.vo.domain.ReferralERODVoAssembler;
import ims.RefMan.vo.lookups.ERODStatus;
import ims.RefMan.vo.lookups.ElectiveAdmissionType;
import ims.configuration.gen.ConfigFlag;
import ims.core.admin.domain.objects.ProviderSystem;
import ims.core.admin.vo.CareContextRefVo;
import ims.core.clinical.domain.objects.Service;
import ims.core.clinical.vo.ProcedureRefVo;
import ims.core.clinical.vo.ServiceRefVo;
import ims.core.configuration.domain.objects.CaseNoteTrackingConfig;
import ims.core.domain.PatientCaseNotes;
import ims.core.domain.impl.PatientCaseNotesImpl;
import ims.core.patient.vo.PatientRefVo;
import ims.core.resource.people.domain.objects.Hcp;
import ims.core.resource.people.vo.HcpRefVo;
import ims.core.resource.place.domain.objects.LocSite;
import ims.core.resource.place.domain.objects.Location;
import ims.core.resource.place.vo.LocationRefVo;
import ims.core.vo.HcpLiteVo;
import ims.core.vo.HcpMinVo;
import ims.core.vo.LocationLiteVo;
import ims.core.vo.LocationLiteVoCollection;
import ims.core.vo.MemberOfStaffLiteVo;
import ims.core.vo.PatientCaseNoteRequestVoCollection;
import ims.core.vo.PatientLiteVo;
import ims.core.vo.ProcedureLiteVoCollection;
import ims.core.vo.domain.HcpLiteVoAssembler;
import ims.core.vo.domain.HcpMinVoAssembler;
import ims.core.vo.domain.LocationLiteVoAssembler;
import ims.core.vo.domain.PatientListVoAssembler;
import ims.core.vo.domain.ProcedureLiteVoAssembler;
import ims.core.vo.lookups.LocationType;
import ims.core.vo.lookups.MsgEventType;
import ims.core.vo.lookups.PreActiveActiveInactiveStatus;
import ims.core.vo.lookups.QueueType;
import ims.core.vo.lookups.ServiceCategory;
import ims.core.vo.lookups.WaitingListStatus;
import ims.core.vo.lookups.YesNo;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.emergency.vo.lookups.ElectiveListReason;
import ims.framework.exceptions.CodingRuntimeException;
import ims.framework.interfaces.ILocation;
import ims.framework.utils.Date;
import ims.framework.utils.DateTime;
import ims.framework.utils.Time;
import ims.hl7adtout.domain.objects.ElectiveListMessageQueue;
import ims.icp.vo.PatientICPFullVo;
import ims.ocrr.vo.lookups.OrderMessageStatus;
import ims.pathways.configuration.domain.objects.Event;
import ims.pathways.domain.HL7PathwayIf;
import ims.pathways.domain.impl.HL7PathwayIfImpl;
import ims.pathways.domain.objects.PathwayClock;
import ims.pathways.domain.objects.PatientPathwayJourney;
import ims.pathways.domain.objects.PauseDetails;
import ims.pathways.vo.EventLiteVo;
import ims.pathways.vo.PatientEventVo;
import ims.pathways.vo.domain.EventLiteVoAssembler;
import ims.pathways.vo.domain.PatientJourneyVoAssembler;
import ims.pathways.vo.lookups.EventStatus;
import ims.scheduling.domain.SessionAdmin;
import ims.scheduling.domain.impl.SessionAdminImpl;
import ims.scheduling.domain.objects.Booking_Appointment;
import ims.scheduling.domain.objects.PendingEmergencyTheatre;
import ims.scheduling.domain.objects.Sch_Booking;
import ims.scheduling.domain.objects.Sch_Session;
import ims.scheduling.domain.objects.Sch_Session_Appointment_Order;
import ims.scheduling.domain.objects.SessionParentChildSlot;
import ims.scheduling.domain.objects.SessionSlotStatus;
import ims.scheduling.domain.objects.SessionTheatreProceduresRemanining;
import ims.scheduling.vo.BookingAppointmentTheatreVo;
import ims.scheduling.vo.Booking_AppointmentRefVo;
import ims.scheduling.vo.Booking_AppointmentVo;
import ims.scheduling.vo.PendingEmergencyTheatreRefVo;
import ims.scheduling.vo.PendingEmergencyTheatreVo;
import ims.scheduling.vo.Sch_BookingTheatreVo;
import ims.scheduling.vo.SessionParentChildSlotRefVo;
import ims.scheduling.vo.SessionParentChildSlotRefVoCollection;
import ims.scheduling.vo.SessionParentChildSlotVo;
import ims.scheduling.vo.SessionTheatreProceduresRemainingVo;
import ims.scheduling.vo.SessionTheatreProceduresRemaniningRefVo;
import ims.scheduling.vo.domain.BookingAppointmentTheatreVoAssembler;
import ims.scheduling.vo.domain.Booking_AppointmentVoAssembler;
import ims.scheduling.vo.domain.PendingEmergencyTheatreVoAssembler;
import ims.scheduling.vo.domain.Sch_BookingTheatreVoAssembler;
import ims.scheduling.vo.domain.SessionParentChildSlotVoAssembler;
import ims.scheduling.vo.domain.SessionTheatreProceduresRemainingVoAssembler;
import ims.scheduling.vo.lookups.Status_Reason;
import ims.scheduling.vo.lookups.TheatreType;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.hibernate.exception.LockAcquisitionException;

public class BookTheatreSlotDetailDialogImpl extends BaseBookTheatreSlotDetailDialogImpl
{

	private static final long serialVersionUID = 1L;

	/**
	 * saveBooking needs to handle child slots for theatre booking handles also
	 * the status points for the appointment and history
	 */
	public Sch_BookingTheatreVo saveTheatreBooking(Sch_BookingTheatreVo voBooking, CatsReferralRefVo catsRef, SessionParentChildSlotRefVoCollection voCollChildSlots, SessionParentChildSlotVo voSessParentChildSlot, TheatreType theatreType, ReferralERODForBookTheatreVo referralEROD, PatientElectiveListVo patientElectiveListToSave, PendingEmergencyTheatreVo pendingEmergencyTheatre, Date previousEarliestDateOffered) throws DomainInterfaceException, StaleObjectException // WDEV-18084
	{
		if (voBooking == null)
			throw new CodingRuntimeException("voBooking is null in method saveBooking");

		DomainFactory factory = getDomainFactory();

		// get old slot if we are rebooking so we can release it and its
		// children
		SessionParentChildSlot doOldSlot = null;
		if (voBooking.getAppointmentsIsNotNull() && voBooking.getAppointments().size() == 1)
		{
			if (voBooking.getAppointments().get(0).getID_Booking_AppointmentIsNotNull())
			{
				Booking_Appointment doAppt = (Booking_Appointment) factory.getDomainObject(voBooking.getAppointments().get(0));
				if (doAppt.getParentChildSlot() != null)
				{
					doOldSlot = doAppt.getParentChildSlot();
				}
			}
		}

		HashMap objMap = new HashMap();
		Sch_Booking doBooking = Sch_BookingTheatreVoAssembler.extractSch_Booking(factory, voBooking, objMap);

		// If CatsReferral record is in scope IE. Appointment booked through UI
		// associate the created appointments with the catsReferral record and
		// patient from cats referral with booking
		CatsReferral doCatsReferral = null;
		if (catsRef != null && catsRef.getID_CatsReferralIsNotNull())
		{
			doCatsReferral = (CatsReferral) factory.getDomainObject(catsRef);
			doBooking.setPatient(doCatsReferral.getPatient());
		}

		// If this is a new patient (from gateway) we will need to save the
		// patient first
		if (doBooking.getPatient().getId() == null)
		{
			factory.save(doBooking.getPatient());
		}

		// WDEV-5727 - consultation appt
		Booking_Appointment doConsultationAppt = null;
		if (doCatsReferral != null)
			doConsultationAppt = doCatsReferral.getConsultationAppt();

		int procedureMinsUsed = 0;
		int slotsDuration = 0;
		
		Sch_Session doTheatreSession = null;
		if (doBooking.getAppointments() != null)
		{
			Iterator it = doBooking.getAppointments().iterator();
			Booking_Appointment doEarliestAppt = null;
			while (it.hasNext())
			{
				Booking_Appointment doBookAppt = (Booking_Appointment) it.next();

				doBookAppt.setRequiresRebook(false); // WDEV-12918

				if (doTheatreSession == null)
					doTheatreSession = doBookAppt.getSession();

				// WDEV-11964
				getDomainFactory().refresh(doTheatreSession);

				// Set patient at this level if not already set
				if (doBookAppt.getPatient() == null)
					doBookAppt.setPatient(doBooking.getPatient());

				if (doEarliestAppt != null && doEarliestAppt.getAppointmentDate().before(doBookAppt.getAppointmentDate()))
					doEarliestAppt = doBookAppt;

				if (doEarliestAppt == null)
					doEarliestAppt = doBookAppt;

				// WDEV-5727 - consultation appt
				if (doConsultationAppt == null)
				{
					if (doBookAppt.getSession().getService() != null)
					{
						if (doBookAppt.getSession().getService().getServiceCategory().equals(getDomLookup(ServiceCategory.CLINICAL)))
							doConsultationAppt = doBookAppt;
					}
				}

				// WDEV-5984
				if (doCatsReferral != null)
				{
					if (doCatsReferral.getReferralDetails() != null && doCatsReferral.getReferralDetails().getTransportRequired() != null && doCatsReferral.getReferralDetails().getTransportRequired().equals(getDomLookup(YesNo.YES)))
					{
						if (doBookAppt.getId() == null) // for every new appt
						{
							doBookAppt.setIsTransportRequired(true);
						}
					}
				}

				// go through the sessions configured TheatreProcedures and if
				// they have a limit - subtract 1 from the
				// NumberOfProceduresLeft
				// also subtract duration of procedure from Remaining Mins
				if (doBookAppt.getTheatreBooking() != null)
				{
					if (doCatsReferral != null && doCatsReferral.getCareContext() != null)
					{
						CareContextRefVo voCCRef = new CareContextRefVo(doCatsReferral.getCareContext().getId(), doCatsReferral.getCareContext().getVersion());
						// WDEV-12918
						BookTheatre impl = (BookTheatre) getDomainImpl(BookTheatreImpl.class);
						doBookAppt.getTheatreBooking().setSuitableForSurgeryProcedure(impl.getLastSuitableForSurgeryAssessmentProcedureTextByCareContext(voCCRef));
					}

					//WDEV-23620 calculate the occupied slots duration
					if (doBookAppt.getParentChildSlot() != null && doBookAppt.getParentChildSlot().getDuration() != null) 
						slotsDuration = slotsDuration + doBookAppt.getParentChildSlot().getDuration();

					if (voCollChildSlots != null)
					{
						for (SessionParentChildSlotRefVo voSlot : voCollChildSlots)
						{
							SessionParentChildSlot doSlot = (SessionParentChildSlot) factory.getDomainObject(voSlot);
								
							if (doSlot.getDuration() != null)
								slotsDuration = slotsDuration + doSlot.getDuration();
						}
					}
					
					if (doBookAppt.getTheatreBooking().getProcedure() != null)
					{
						if (doBookAppt.getCustomProcedureDuration() != null)
							procedureMinsUsed += doBookAppt.getCustomProcedureDuration();
						else if (doBookAppt.getTheatreBooking().getProcedure().getDurationInMins() != null)
							procedureMinsUsed += doBookAppt.getTheatreBooking().getProcedure().getDurationInMins().intValue();
					}
				}
			}
			
			
			if ( doTheatreSession != null && doTheatreSession.getTheatreProceduresRemaining() != null && doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins() != null && !doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().equals(new Integer(0)))
			{
				if (slotsDuration > 0 && slotsDuration < procedureMinsUsed) //WDEV-23620 this means overbook
				{
					doTheatreSession.getTheatreProceduresRemaining().setRemainingTimeInMins(new Integer(doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().intValue() - slotsDuration));
				} 
				else if (procedureMinsUsed > 0 )
					doTheatreSession.getTheatreProceduresRemaining().setRemainingTimeInMins(new Integer(doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().intValue() - procedureMinsUsed));
			}

			doBooking.setFirstAppointment(doEarliestAppt);

			// if the first appointment is no longer associated with this
			// booking ie. was cancelled
			if (!doBooking.getAppointments().contains(doEarliestAppt))
			{
				doBooking.setFirstAppointment(null);
			}
		}

		// WDEV-13551
		// Refresh all slots except the ones required for rebooking (the parent
		// slot and those calculated
		Iterator parentSlotIterator = doBooking.getFirstAppointment().getSession().getParentChildSlots().iterator();

		while (parentSlotIterator.hasNext())
		{
			SessionParentChildSlot parentSlot = (SessionParentChildSlot) parentSlotIterator.next();

			if (parentSlot.getId().equals(voSessParentChildSlot.getID_SessionParentChildSlot()))
				continue;

			if (foundInSlots(parentSlot.getId(), voCollChildSlots))
				continue;

			factory.refresh(parentSlot);
		}

		//try
		//{
			factory.save(doBooking);
		//}
		//catch (StaleObjectException ex)
		/*{
			//ex.printStackTrace();
			
			// WDEV-11964
			if (ex != null && ex.getStaleObject() instanceof SessionTheatreProceduresRemanining)
			{
				// check if persisted slot is still available
				SessionParentChildSlot doSlot = (SessionParentChildSlot) factory.getDomainObject(voSessParentChildSlot);
				if (doSlot.getAppointment() != null)
					throw new StaleObjectException(doBooking);
				
				// attempt to do the booking again in this scenario
				SessionTheatreProceduresRemanining doSessTheatreProcRem = (SessionTheatreProceduresRemanining) ex.getStaleObject();
				doSessTheatreProcRem = (SessionTheatreProceduresRemanining) getDomainFactory().getDomainObject(SessionTheatreProceduresRemanining.class, doSessTheatreProcRem.getId());
				
				System.out.println("First Stale - SessionTheatreProceduresRemanining version for id = " + doSessTheatreProcRem.getId() + " is " + doSessTheatreProcRem.getVersion());

				//doTheatreSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, doTheatreSession.getId());
				//SessionTheatreProceduresRemanining doSessTheatreProcRem = doTheatreSession.getTheatreProceduresRemaining();

				doSessTheatreProcRem.setRemainingTimeInMins(new Integer(doSessTheatreProcRem.getRemainingTimeInMins().intValue() - procedureMinsUsed));
		
				if (doBooking.getAppointments() != null)
				{
					Iterator it = doBooking.getAppointments().iterator();
					while (it.hasNext())
					{
						Booking_Appointment doBookAppt = (Booking_Appointment) it.next();
						doBookAppt.getSession().setTheatreProceduresRemaining(doSessTheatreProcRem);
					}
				}
				//trying to save again
				refreshAndSaveBooking(voSessParentChildSlot, doBooking, procedureMinsUsed, doTheatreSession);
			}
		}
		catch (Exception ex)
		{
			if(ex instanceof LockAcquisitionException)
			{
				System.out.println("First LockAcquisitionException");
				// check if persisted slot is still available
				SessionParentChildSlot doSlot = (SessionParentChildSlot) factory.getDomainObject(voSessParentChildSlot);
				if (doSlot.getAppointment() != null)
					throw new StaleObjectException(doBooking);
				
				// attempt to do the booking again in this scenario
				//SessionTheatreProceduresRemanining doSessTheatreProcRem = (SessionTheatreProceduresRemanining) ex.getStaleObject();
				//factory.refresh(doSessTheatreProcRem);

				doTheatreSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, doTheatreSession.getId());
				SessionTheatreProceduresRemanining doSessTheatreProcRem = doTheatreSession.getTheatreProceduresRemaining();

				doSessTheatreProcRem.setRemainingTimeInMins(new Integer(doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().intValue() - procedureMinsUsed));
				
				if (doBooking.getAppointments() != null)
				{
					Iterator it = doBooking.getAppointments().iterator();
					while (it.hasNext())
					{
						Booking_Appointment doBookAppt = (Booking_Appointment) it.next();
						doBookAppt.setSession(doTheatreSession);
					}
				}
		
				//trying to save again
				refreshAndSaveBooking(voSessParentChildSlot, doBooking, procedureMinsUsed, doTheatreSession);
			}
		}*/

		ReferralEROD doReferralEROD = null;
		if (doCatsReferral != null)
		{
			doCatsReferral.getAppointments().addAll(doBooking.getAppointments());
			// WDEV-5727 - consultation appt
			doCatsReferral.setConsultationAppt(doConsultationAppt);
			// WDEV-5727 - has appointments
			doCatsReferral.setHasAppointments(true);

			doCatsReferral.setHasTheatreAppt(true);// wdev-7607
			if (theatreType != null && theatreType.equals(TheatreType.OP_CASE)) // wdev-13765
				doCatsReferral.setHasOPProcAwaitingAppt(Boolean.FALSE); // wdev-13765

			boolean isPlannedList = patientElectiveListToSave != null && ElectiveAdmissionType.PLANNED_TYPE13.equals(patientElectiveListToSave.getElectiveAdmissionType());
			Boolean isDiagnostic = patientElectiveListToSave != null && ElectiveListReason.DIAGNOSTIC.equals(patientElectiveListToSave.getElectiveListReason());
			
			PathwayClock currentClock = null;
			if (referralEROD != null)
			{
				if (!isPlannedList && !isDiagnostic && doCatsReferral.getJourney() != null && doCatsReferral.getJourney().getCurrentClock() != null)
				{
					currentClock = doCatsReferral.getJourney().getCurrentClock();

					factory.refresh(currentClock);

					/*PauseDetails doPauseDetails = new PauseDetails();
					doPauseDetails.setPauseStart(referralEROD.getERODDate1() != null ? referralEROD.getERODDate1().getDate() : null);// http://jira/browse/WDEV-22354
					doPauseDetails.setPauseStop(referralEROD.getPatAvailFromDate() != null ? referralEROD.getPatAvailFromDate().getDate() : null);
					doPauseDetails.setActive(true);

					currentClock.setCurrentPause(doPauseDetails);

					if (currentClock.getPauseDetails() == null)
						currentClock.setPauseDetails(new java.util.ArrayList());

					currentClock.getPauseDetails().add(doPauseDetails);*/
					
					boolean shouldPauseBeAddedToHistory = false;
					
					PauseDetails currentPause = currentClock.getCurrentPause();
					PauseDetails notUpdatedCurrentPause = clonePause(currentPause);
					
					if (currentPause != null && Boolean.TRUE.equals(currentPause.isActive()) && referralEROD.getID_ReferralEROD() != null && (currentPause.getPauseStart().equals(referralEROD.getERODDate1().getDate()) || (previousEarliestDateOffered != null && currentPause.getPauseStart().equals(previousEarliestDateOffered.getDate()))))
					{
						if(!currentPause.getPauseStart().equals(referralEROD.getERODDate1().getDate()))
						{
							currentPause.setPauseStart(referralEROD.getERODDate1().getDate());
						}
						
						currentPause.setPauseStop(referralEROD.getPatAvailFromDate().getDate());
					}
					else if (currentPause == null || Boolean.FALSE.equals(currentPause.isActive()) || referralEROD.getID_ReferralEROD() == null)
					{
						// Current Pause is null, so create a new one to store the EROD details
						currentPause = new PauseDetails();
						currentPause.setPauseStart(referralEROD.getERODDate1().getDate());
						currentPause.setPauseStop(referralEROD.getPatAvailFromDate().getDate());
						currentPause.setActive(referralEROD.getIsActive());
						doCatsReferral.getJourney().getCurrentClock().setCurrentPause(currentPause);
						
						shouldPauseBeAddedToHistory = true;
					}
					
					if(shouldPauseBeAddedToHistory)
					{
						if(currentClock.getPauseDetails() == null)
							doCatsReferral.getJourney().getCurrentClock().setPauseDetails(new java.util.ArrayList());
						
						currentClock.getPauseDetails().add(currentPause);
					}
					else
					{
    					List<PauseDetails> pauses = doCatsReferral.getJourney().getCurrentClock().getPauseDetails();
    					if (pauses != null && pauses.size() > 0)
    					{
    						for (int i=0; i<pauses.size(); i++)
    						{
    							PauseDetails pause = pauses.get(i);
    							//if (pause.getPauseStart().equals(referralEROD.getERODDate1().getDate()) || (previousEarliestDateOffered != null && pause.getPauseStart().equals(previousEarliestDateOffered.getDate())) && Boolean.TRUE.equals(pause.isActive()))
    							if(pause.equals(notUpdatedCurrentPause) && Boolean.TRUE.equals(pause.isActive()))
    							{
    								if(!pause.getPauseStart().equals(referralEROD.getERODDate1().getDate()))
    								{
    									pause.setPauseStart(referralEROD.getERODDate1().getDate());
    								}
    								
    								pause.setPauseStop(referralEROD.getPatAvailFromDate().getDate());
    								
    								break;
    							}
    						}
    					}
					}

					// WDEV-19772
					if (ConfigFlag.DOM.PATHWAY_ENTITY_EVENT_FUNCTIONALITY.getValue() && doCatsReferral != null && doCatsReferral.getJourney() != null && patientElectiveListToSave != null && !ElectiveListReason.DIAGNOSTIC.equals(patientElectiveListToSave.getElectiveListReason()))
					{
						EventLiteVo hardCodedEvent = getHardCodedEvent(HardCodedEvents.PATHWAYPAUSED.getID());
						createPatientEvent(doCatsReferral, hardCodedEvent, referralEROD.getERODDate1());
					}
				}

				doReferralEROD = createdReferralEROD(factory, doCatsReferral.getElectiveEROD(), currentClock, referralEROD, objMap);

				if (doCatsReferral.getElectiveEROD() == null)
					doCatsReferral.setElectiveEROD(new java.util.ArrayList());

				doCatsReferral.getElectiveEROD().add(doReferralEROD);
			}

			/*
			 * if(patientElectiveListToSave != null &&
			 * patientElectiveListToSave.getTCIDetails() != null &&
			 * patientElectiveListToSave.getTCIDetails().getTCIDate() != null) {
			 * if(doCatsReferral.getJourney() != null &&
			 * doCatsReferral.getJourney().getCurrentClock() != null &&
			 * doCatsReferral.getJourney().getCurrentClock().getCurrentPause()
			 * != null) { PauseDetails currentPause =
			 * doCatsReferral.getJourney().getCurrentClock().getCurrentPause();
			 * 
			 * if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails()
			 * != null) { for(int i=0;
			 * i<doCatsReferral.getJourney().getCurrentClock
			 * ().getPauseDetails().size(); i++) { PauseDetails pause =
			 * (PauseDetails)
			 * doCatsReferral.getJourney().getCurrentClock().getPauseDetails
			 * ().get(i); if(currentPause.equals(pause) &&
			 * Boolean.TRUE.equals(pause.isActive())) {
			 * doCatsReferral.getJourney
			 * ().getCurrentClock().getPauseDetails().remove(i); break; } } }
			 * 
			 * currentPause.setPauseStop(patientElectiveListToSave.getTCIDetails(
			 * ).getTCIDate().getDate());
			 * 
			 * if(doCatsReferral.getJourney().getCurrentClock().getPauseDetails()
			 * == null)
			 * doCatsReferral.getJourney().getCurrentClock().setPauseDetails(new
			 * java.util.ArrayList());
			 * 
			 * doCatsReferral.getJourney().getCurrentClock().getPauseDetails().add
			 * (currentPause); } }
			 */

			factory.save(doCatsReferral);

			/*
			 * if(currentClock != null) { String patientElectiveListQuery =
			 * "select electiveList from PatientElectiveList as electiveList left join electiveList.referral as cats left join electiveList.pathwayClock as pc where cats.id = :CatsId and pc.id = :PathwayClock"
			 * ; List<?> electiveList = factory.find(patientElectiveListQuery,
			 * new String[] {"CatsId", "PathwayClock"}, new Object[]
			 * {catsRef.getID_CatsReferral(), currentClock.getId()});
			 * 
			 * if(electiveList != null && electiveList.size() > 0 &&
			 * electiveList.get(0) instanceof PatientElectiveList) {
			 * PatientElectiveList doPatientElectiveList = (PatientElectiveList)
			 * electiveList.get(0);
			 * doPatientElectiveList.setEROD(doReferralEROD);
			 * 
			 * factory.save(doPatientElectiveList); } }
			 */
			// WDEV-12157
			// Update the CatsReferral status (hasCancelled appointments field)
			//SessionAdmin impl = (SessionAdmin) getDomainImpl(SessionAdminImpl.class);//WDEV-23545 - this method should not be called for theatre appoitments
			//impl.updateCatsReferralAdditionalInvStatus(catsRef, null);

			BookTheatre implBT = (BookTheatre) getDomainImpl(BookTheatreImpl.class);
			implBT.updateActiveMonitoring(catsRef);
		}

		// WDEV-7528 - maintain SessionAppointmentOrder
		if (doTheatreSession != null)
		{
			Sch_Session_Appointment_Order doSessApptOrder = Sch_Session_Appointment_Order.getSch_Session_Appointment_OrderFromSession(factory, doTheatreSession.getId());
			if (doSessApptOrder == null)
			{
				doSessApptOrder = new Sch_Session_Appointment_Order();
				doSessApptOrder.setSession(doTheatreSession);
			}

			Iterator it1 = doBooking.getAppointments().iterator();
			while (it1.hasNext())
			{
				Booking_Appointment doAppt = (Booking_Appointment) it1.next();

				// WDEV-8271
				BookTheatre impl = (BookTheatre) getDomainImpl(BookTheatreImpl.class);
				impl.removeApptFromExistingSessionApptOrder(doAppt);

				if (!impl.alreadyExists(doSessApptOrder, doAppt))
					doSessApptOrder.getAppointments().add(doAppt);
			}

			factory.save(doSessApptOrder);
		}

		// WDEV-11777 - update the SessionTheatreSlot record
		if (voSessParentChildSlot != null)
		{
			SessionParentChildSlot doSessParentChildSlot = SessionParentChildSlotVoAssembler.extractSessionParentChildSlot(factory, voSessParentChildSlot);

			// get the one(first) appointment from the collection
			if (doBooking.getAppointments() != null)
			{
				Iterator it = doBooking.getAppointments().iterator();
				Booking_Appointment doBookedAppt = (Booking_Appointment) it.next();
				bookAppointmentIntoParentChildSlot(doBookedAppt, doSessParentChildSlot);
			}

			factory.save(doSessParentChildSlot);

			// WDEV-12918 - find and update the child slots with their (new
			// parent) also set them to booked
			if (voCollChildSlots != null)
			{
				for (SessionParentChildSlotRefVo voSlot : voCollChildSlots)
				{
					SessionParentChildSlot doSlot = (SessionParentChildSlot) factory.getDomainObject(voSlot);
					doSlot.setParentSlot(doSessParentChildSlot);
					doSlot.setStatus(getDomLookup(Status_Reason.BOOKED));
					factory.save(doSlot);
				}
			}
		}

		// WDEV-12918 rebooking theatre fixed slots
		if (doOldSlot != null)
		{
			doOldSlot.setAppointment(null);
			doOldSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));

			if (doOldSlot.getSession() != null)
			{
				if (doOldSlot.getSession().getParentChildSlots() != null)
				{
					Iterator it = doOldSlot.getSession().getParentChildSlots().iterator();
					while (it.hasNext())
					{
						// release child slots
						SessionParentChildSlot doSlot = (SessionParentChildSlot) it.next();
						if (doSlot.getParentSlot() != null && doSlot.getParentSlot().equals(doOldSlot))
						{
							doSlot.setParentSlot(null);
							doSlot.setStatus(getDomLookup(Status_Reason.SLOTOPENED));
						}
					}
				}
			}

			SessionSlotStatus doStat = new SessionSlotStatus();
			doStat.setDateTime(new java.util.Date());
			doStat.setStatus(doOldSlot.getStatus());
			doStat.setStatusReason(doOldSlot.getStatusReason());
			doOldSlot.getStatusReasonHistory().add(doStat);

			factory.save(doOldSlot);
			factory.save(doOldSlot.getSession());
		}

		// WDEV-18084
		PatientElectiveList domPatElectiveList = null;

		if (patientElectiveListToSave != null)
		{
			domPatElectiveList = PatientElectiveListVoAssembler.extractPatientElectiveList(factory, patientElectiveListToSave, objMap);
			domPatElectiveList.setEROD(doReferralEROD);

			// WDEV-20746 Trigger A05 HL7 message
			triggerElectiveListEvent(domPatElectiveList);
			// WDEV-20746

			factory.save(domPatElectiveList);

			// //WDEV-19704 Trigger HL7 message
			// triggerElectiveListEvent(domPatElectiveList);
			// //WDEV-19704

		}

		if (pendingEmergencyTheatre != null)
		{
			PendingEmergencyTheatre domPET = PendingEmergencyTheatreVoAssembler.extractPendingEmergencyTheatre(factory, pendingEmergencyTheatre, objMap);
			factory.save(domPET);
		}

		Sch_BookingTheatreVo sch_booking = Sch_BookingTheatreVoAssembler.create(doBooking);

		if (domPatElectiveList != null && domPatElectiveList.getTCIDetails() != null)
			sch_booking.setTciId(domPatElectiveList.getTCIDetails().getId());

		return sch_booking;
	}

	private void refreshAndSaveBooking(SessionParentChildSlotVo voSessParentChildSlot, Sch_Booking doBooking, int procedureMinsUsed, Sch_Session doTheatreSession) throws StaleObjectException
	{
		try
		{
			getDomainFactory().save(doBooking);
		}
		catch (StaleObjectException exsec)
		{
			//exsec.printStackTrace();
			
			// WDEV-11964
			if (exsec != null && exsec.getStaleObject() instanceof SessionTheatreProceduresRemanining)
			{
				// check if persisted slot is still available
				SessionParentChildSlot doSlotSec = (SessionParentChildSlot) getDomainFactory().getDomainObject(voSessParentChildSlot);
				if (doSlotSec.getAppointment() != null)
					throw new StaleObjectException(doBooking);
				
				// attempt to do the booking again in this scenario
				SessionTheatreProceduresRemanining doSessTheatreProcRemSec = (SessionTheatreProceduresRemanining) exsec.getStaleObject();
				doSessTheatreProcRemSec = (SessionTheatreProceduresRemanining) getDomainFactory().getDomainObject(SessionTheatreProceduresRemanining.class, doSessTheatreProcRemSec.getId());
				
				System.out.println("Second Stale - SessionTheatreProceduresRemanining version for id = " + doSessTheatreProcRemSec.getId() + " is " + doSessTheatreProcRemSec.getVersion());

				//doTheatreSession = (Sch_Session) factory.getDomainObject(Sch_Session.class, doTheatreSession.getId());
				//SessionTheatreProceduresRemanining doSessTheatreProcRemSec = doTheatreSession.getTheatreProceduresRemaining();

				doSessTheatreProcRemSec.setRemainingTimeInMins(new Integer(doSessTheatreProcRemSec.getRemainingTimeInMins().intValue() - procedureMinsUsed));
		
				if (doBooking.getAppointments() != null)
				{
					Iterator it = doBooking.getAppointments().iterator();
					while (it.hasNext())
					{
						Booking_Appointment doBookAppt = (Booking_Appointment) it.next();
						doBookAppt.getSession().setTheatreProceduresRemaining(doSessTheatreProcRemSec);
					}
				}
				
				getDomainFactory().save(doBooking);
			}
		}
		catch (Exception exsec)
		{
			if(exsec instanceof LockAcquisitionException)
			{
				System.out.println("Second LockAcquisitionException");
				// check if persisted slot is still available
				SessionParentChildSlot doSlotSec = (SessionParentChildSlot) getDomainFactory().getDomainObject(voSessParentChildSlot);
				if (doSlotSec.getAppointment() != null)
					throw new StaleObjectException(doBooking);
				
				// attempt to do the booking again in this scenario
				//SessionTheatreProceduresRemanining doSessTheatreProcRem = (SessionTheatreProceduresRemanining) ex.getStaleObject();
				//factory.refresh(doSessTheatreProcRem);

				doTheatreSession = (Sch_Session) getDomainFactory().getDomainObject(Sch_Session.class, doTheatreSession.getId());
				SessionTheatreProceduresRemanining doSessTheatreProcRemSec = doTheatreSession.getTheatreProceduresRemaining();

				doSessTheatreProcRemSec.setRemainingTimeInMins(new Integer(doTheatreSession.getTheatreProceduresRemaining().getRemainingTimeInMins().intValue() - procedureMinsUsed));
				
				if (doBooking.getAppointments() != null)
				{
					Iterator it = doBooking.getAppointments().iterator();
					while (it.hasNext())
					{
						Booking_Appointment doBookAppt = (Booking_Appointment) it.next();
						doBookAppt.setSession(doTheatreSession);
					}
				}
		
				getDomainFactory().save(doBooking);
			}
		}
	}
	
	private PauseDetails clonePause(PauseDetails pause)
	{
		if(pause == null)
			return null;
		
		PauseDetails newPause = new PauseDetails();
		newPause.setPauseStart(pause.getPauseStart());
		newPause.setPauseStop(pause.getPauseStop());
		newPause.setActive(pause.isActive());
		
		return newPause;
	}

	// WDEV-19704 Create message queue trigger record(s) for each provider
	// system for A05 HL7 message
	public void triggerElectiveListEvent(PatientElectiveList domPatElectiveList) throws StaleObjectException
	{
		if (domPatElectiveList != null
		// WDEV-20746 Tighten up checks
		&& domPatElectiveList.getTCIDetails() != null && domPatElectiveList.getTCIDetails().getTCIDate() != null && domPatElectiveList.getElectiveListStatus() != null && domPatElectiveList.getElectiveListStatus().getElectiveListStatus() != null && WaitingListStatus.TCI_GIVEN.getID() == (domPatElectiveList.getElectiveListStatus().getElectiveListStatus().getId())) // WDEV-20746
		{
			DomainFactory factory = getDomainFactory();
			String hqlString = "select ot.providerSystem from OutboundTriggers as ot left join ot.queueType as qt left join qt.instance as i" + " where(i.id = " + QueueType.ELECTIVELIST.getId() + ")";

			java.util.List<ProviderSystem> list = factory.find(hqlString);
			for (ProviderSystem providerSystem : list)
			{
				ElectiveListMessageQueue messageQueue = new ElectiveListMessageQueue();
				messageQueue.setPatientElectiveList(domPatElectiveList);
				messageQueue.setProviderSystem(providerSystem);
				messageQueue.setWasProcessed(Boolean.FALSE);
				messageQueue.setMessageStatus(getDomLookup(OrderMessageStatus.CREATED));
				messageQueue.setMsgType(getDomLookup(MsgEventType.A05));
				messageQueue.setQueueType(getDomLookup(QueueType.ELECTIVELIST));

				factory.save(messageQueue);
			}
		}
	}

	// WDEV-19772
	private void createPatientEvent(CatsReferral doCatsReferral, EventLiteVo hardCodedEvent, Date erodStartDate) throws StaleObjectException, DomainInterfaceException
	{
		PatientPathwayJourney patientJBo = doCatsReferral != null ? doCatsReferral.getJourney() : null;

		if (patientJBo != null && hardCodedEvent != null)
		{
			PatientEventVo patEvent = new PatientEventVo();
			patEvent.setPatient((PatientRefVo) PatientListVoAssembler.create(doCatsReferral.getPatient()));
			patEvent.setEvent(hardCodedEvent);
			patEvent.setEventDateTime(erodStartDate != null ? new DateTime(erodStartDate) : new DateTime());
			patEvent.setEventStatus(EventStatus.ACTIVE);
			patEvent.setJourney(PatientJourneyVoAssembler.create(patientJBo));

			HL7PathwayIf implPath = (HL7PathwayIf) getDomainImpl(HL7PathwayIfImpl.class);
			implPath.instantiatePatientEvent(patEvent);
		}
	}

	// WDEV-19772
	private EventLiteVo getHardCodedEvent(int event_Id)
	{
		StringBuilder hqlBuilder = new StringBuilder("select event from Event as event left join event.status as s where event.id = :eventID and s.id = :statusID ");

		List<?> list = getDomainFactory().find(hqlBuilder.toString(), new String[] { "eventID", "statusID" }, new Object[] { event_Id, PreActiveActiveInactiveStatus.ACTIVE.getID() });

		if (list == null || list.size() == 0)
			return null;

		return EventLiteVoAssembler.create((Event) list.get(0));
	}

	// WDEV-19489 //WDEV-20064
	public void createCaseNoteRequests(Integer tciId, LocationLiteVo caseNoteFolderLoc) throws DomainInterfaceException
	{
		if (tciId == null || caseNoteFolderLoc == null)// WDEV-20064
			return;

		TCIForPatientElectiveList domTciDetails = (TCIForPatientElectiveList) getDomainFactory().getDomainObject(TCIForPatientElectiveList.class, tciId);

		if (domTciDetails == null)
			return;

		Booking_AppointmentVo voBooking = Booking_AppointmentVoAssembler.create(domTciDetails.getAppointment());
		ElectiveTCIForReferralDetailsVo tci = ElectiveTCIForReferralDetailsVoAssembler.create(domTciDetails);

		boolean sessionHasCaseNoteLocation = voBooking.getSession() != null && voBooking.getSession().getCaseNoteFolderLocation() != null;

		if (tci.getTCIDate() != null && tci.getTCITime() != null) // WDEV-20064
		{
			if (tci.getTCIDate().isGreaterThan(new Date()) || (tci.getTCIDate().equals(new Date()) && tci.getTCITime().isGreaterOrEqualThan(new Time())))
			{
				saveAutomatedCaseNoteRequests(voBooking, tci, caseNoteFolderLoc);// WDEV-20064
			}
		}

	}

	public CaseNoteTrackingConfigVo getCaseNoteTrackingConfig()
	{
		DomainFactory factory = getDomainFactory();
		String query = "select config from CaseNoteTrackingConfig as config ";

		List<?> list = factory.find(query);

		if (list != null && list.size() > 0 && list.get(0) != null)
		{
			return CaseNoteTrackingConfigVoAssembler.create((CaseNoteTrackingConfig) list.get(0));
		}

		return null;

	}

	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequests(Booking_AppointmentVo voBooking, ElectiveTCIForReferralDetailsVo tci, LocationLiteVo caseNoteFolderLoc) throws DomainInterfaceException // WDEV-20064
	{
		PatientCaseNoteRequestVoCollection savedCaseNotesRequests = null;

		DateTime dateTimeRequired = new DateTime();

		dateTimeRequired.setDateTime(tci.getTCIDate(), tci.getTCITime());
		PatientLiteVo patient = new PatientLiteVo(voBooking.getPatient().getID_Patient(), voBooking.getPatient().getVersion_Patient());

		try
		{
			savedCaseNotesRequests = saveAutomatedCaseNoteRequest(patient, (MemberOfStaffLiteVo) getMosUser(), voBooking, dateTimeRequired, tci, caseNoteFolderLoc);// WDEV-20064
		}
		catch (StaleObjectException e)
		{
			e.printStackTrace();
		}
		catch (UniqueKeyViolationException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return savedCaseNotesRequests;
	}

	private PatientCaseNoteRequestVoCollection saveAutomatedCaseNoteRequest(PatientLiteVo patient, MemberOfStaffLiteVo mos, Booking_AppointmentVo appointment, DateTime requiredByDate, ElectiveTCIForReferralDetailsVo tci, LocationLiteVo caseNoteFolderLoc) throws StaleObjectException, DomainInterfaceException, UniqueKeyViolationException // WDEV-20064
	{
		PatientCaseNotes impl = (PatientCaseNotes) getDomainImpl(PatientCaseNotesImpl.class);
		return impl.saveAutomaticCaseNoteRequests(patient, mos, caseNoteFolderLoc, requiredByDate, null, tci); // WDEV-20064
	}

	private ReferralEROD createdReferralEROD(DomainFactory factory, List theatreEROD, PathwayClock pathwayClock, ReferralERODForBookTheatreVo referralEROD, HashMap objMap)
	{
		if (referralEROD == null)
			return null;

		int sequence = 0;

		if (theatreEROD != null)
		{
			for (int i = 0; i < theatreEROD.size(); i++)
			{
				if (theatreEROD.get(i) instanceof ReferralEROD)
				{
					ReferralEROD savedErod = (ReferralEROD) theatreEROD.get(i);

					if (savedErod.getSequence() != null && sequence < savedErod.getSequence())
						sequence = savedErod.getSequence();
				}
			}
		}

		sequence++;

		ReferralEROD doErod = ReferralERODForBookTheatreVoAssembler.extractReferralEROD(factory, referralEROD, objMap);
		doErod.setSequence(sequence);
		doErod.setPathWayClock(pathwayClock);

		return doErod;
	}

	/**
	 * WDEV-13551 Function used to determine if the slot with the ID is found in
	 * the provided Slot collection
	 */
	private boolean foundInSlots(Integer slotID, SessionParentChildSlotRefVoCollection slotCollection)
	{
		if (slotCollection == null || slotCollection.size() == 0)
			return false;

		if (slotID == null)
			return false;

		for (SessionParentChildSlotRefVo slot : slotCollection)
		{
			if (slotID.equals(slot.getID_SessionParentChildSlot()))
				return true;
		}

		return false;
	}

	/**
	 * @param doAppt
	 * @param doSessionTheatreSlot
	 */
	private SessionParentChildSlot bookAppointmentIntoParentChildSlot(Booking_Appointment doAppt, SessionParentChildSlot doSessParentChildSlot)
	{
		if (doSessParentChildSlot == null)
			throw new CodingRuntimeException("doSessParentChildSlot is null in method bookAppointmentIntoParentChildSlot");
		if (doAppt == null)
			throw new CodingRuntimeException("doAppt is null in method bookAppointmentIntoParentChildSlot");

		doSessParentChildSlot.setAppointment(doAppt);

		doSessParentChildSlot.setStatus(getDomLookup(Status_Reason.BOOKED));
		doSessParentChildSlot.setStatusReason(getDomLookup(Status_Reason.BOOKED));

		SessionSlotStatus doStat = new SessionSlotStatus();
		doStat.setDateTime(new java.util.Date());
		doStat.setStatus(doSessParentChildSlot.getStatus());
		doStat.setStatusReason(doSessParentChildSlot.getStatusReason());
		doSessParentChildSlot.getStatusReasonHistory().add(doStat);

		return doSessParentChildSlot;
	}

	public BookingAppointmentTheatreVo getBookingTheatreAppointment(Booking_AppointmentRefVo appt)
	{
		if (appt == null || appt.getID_Booking_Appointment() == null)
			throw new CodingRuntimeException("appt is null or id not provided in method getBookingTheatreAppointment");

		return BookingAppointmentTheatreVoAssembler.create((Booking_Appointment) getDomainFactory().getDomainObject(appt));
	}

	public PatientICPFullVo getPatientICP(CareContextRefVo careContext)
	{
		BookTheatre impl = (BookTheatre) getDomainImpl(BookTheatreImpl.class);
		return impl.getPatientICP(careContext);
	}

	public PatientICPFullVo savePatientICP(PatientICPFullVo icp) throws DomainInterfaceException, StaleObjectException
	{
		BookTheatre impl = (BookTheatre) getDomainImpl(BookTheatreImpl.class);
		return impl.savePatientICP(icp);
	}

	public Boolean hasTheatreEROD(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return false;

		DomainFactory factory = getDomainFactory();
		Object[] count = factory.find("select count(theaErod.id) from CatsReferral as cats left join cats.electiveEROD as theaErod where cats.id = :CatsReferralId and theaErod.isActive = 1 and (theaErod.isRIE is null or theaErod.isRIE = 0)", new String[] { "CatsReferralId" }, new Object[] { catsReferral.getID_CatsReferral() }).toArray();

		if (count != null && count.length > 0)
			return ((Long) count[0]).intValue() > 0;

		return false;
	}

	public ReferralERODVo getReferralERODByAppointment(Booking_AppointmentRefVo apptRef)
	{
		if (apptRef == null || apptRef.getID_Booking_Appointment() == null)
			return null;

		DomainFactory factory = getDomainFactory();
		String query = "select erod from ReferralEROD as erod left join erod.appointment as appt left join erod.erodStatus as eStatus where appt.id = :BookAppointment and (eStatus is null or eStatus.id <> :ErodStatus)";
		List<?> list = factory.find(query, new String[] { "BookAppointment", "ErodStatus" }, new Object[] { apptRef.getID_Booking_Appointment(), ERODStatus.CANCELLED.getID() });

		if (list != null && list.size() > 0 && list.get(0) != null)
		{
			return ReferralERODVoAssembler.create((ReferralEROD) list.get(0));
		}

		return null;
	}

	// WDEV-18084
	public CatsReferralForNewElectivListEntryVo getCatsReferral(CatsReferralRefVo catsReferralRef)
	{
		if (catsReferralRef == null || catsReferralRef.getID_CatsReferral() == null)
		{
			throw new CodingRuntimeException("Cannot get CatsReferralForNewElectivListEntryVo for null ID");
		}

		DomainFactory factory = getDomainFactory();
		CatsReferral domCatsRef = (CatsReferral) factory.getDomainObject(CatsReferral.class, catsReferralRef.getID_CatsReferral());

		return CatsReferralForNewElectivListEntryVoAssembler.create(domCatsRef);
	}

	public LocationLiteVoCollection listWardsForCurrentLocation(ILocation location)
	{
		if (location == null)
			return null;

		OrganisationAndLocation implLoc = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		LocationRefVo voRef = new LocationRefVo();
		voRef.setID_Location(location.getID());

		return implLoc.listActiveWardsForHospitalLite(voRef).sort();

	}

	public HcpMinVo getHCPMin(HcpRefVo hcpRef)
	{
		if (hcpRef == null || hcpRef.getID_Hcp() == null)
		{
			throw new CodingRuntimeException("Cannot get HCPMin for null ID");
		}

		DomainFactory factory = getDomainFactory();
		Hcp domHCP = (Hcp) factory.getDomainObject(Hcp.class, hcpRef.getID_Hcp());

		return HcpMinVoAssembler.create(domHCP);
	}

	public HcpLiteVo getHCPLiteVo(HcpRefVo hcpRef)
	{
		if (hcpRef == null || hcpRef.getID_Hcp() == null)
		{
			throw new CodingRuntimeException("Cannot get HCPMin for null ID");
		}

		DomainFactory factory = getDomainFactory();
		Hcp domHCP = (Hcp) factory.getDomainObject(Hcp.class, hcpRef.getID_Hcp());

		return HcpLiteVoAssembler.create(domHCP);
	}

	public PatientElectiveListVoCollection getPatientElectiveList(PatientRefVo patientRef, CatsReferralRefVo catsRef, ServiceRefVo serviceRef, ProcedureRefVo procedureRef, String listIdHcp, CatsReferralForNewElectivListEntryVo catsReferralWithPathwayClock, Boolean nonDiagnosticELE) // WDEV-18396
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		StringBuffer hqlConditions = new StringBuffer();
		String andStr = " and ";

		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("select pEL from PatientElectiveList as pEL left join pEL.primaryProcedure as primProc left join pEL.electiveList as eL left join eL.service as service left join eL.hCPs as listOwners left join pEL.electiveListStatus as pELStatus left join pELStatus.electiveListStatus as status left join pEL.pathwayClock as pathClock  ");

		if (patientRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pEL.patient.id = :PatID ");
			markers.add("PatID");
			values.add(patientRef.getID_Patient());
			andStr = " and ";
		}

		if (catsRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pEL.referral.id = :CatsID ");
			markers.add("CatsID");
			values.add(catsRef.getID_CatsReferral());
			andStr = " and ";
		}

		if (serviceRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" service.id=:Service ");
			markers.add("Service");
			values.add(serviceRef.getID_Service());
			andStr = " and ";
		}

		if (procedureRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" primProc.id=:Procedure ");
			markers.add("Procedure");
			values.add(procedureRef.getID_Procedure());
			andStr = " and ";
		}

		if (listIdHcp != null && listIdHcp.length() > 0)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" ( listOwners.hCP.id in " + listIdHcp + " ) ");
			andStr = " and ";
		}

		if (nonDiagnosticELE)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pEL.electiveListReason.id not in (" + ElectiveListReason.DIAGNOSTIC.getID() + " ) ");
			andStr = " and ";
		}

		if (catsReferralWithPathwayClock != null && catsReferralWithPathwayClock.getJourney() != null && catsReferralWithPathwayClock.getJourney().getCurrentClock() != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pathClock.id = :Clock ");
			markers.add("Clock");
			values.add(catsReferralWithPathwayClock.getJourney().getCurrentClock().getID_PathwayClock());
			andStr = " and ";
		}

		hqlConditions.insert(0, " where ( status.id not in (" + WaitingListStatus.REMOVED.getID() + ")");
		hqlConditions.append(" ) ");

		List<?> list = factory.find(hql.toString() + hqlConditions.toString(), markers, values);

		if ((list == null || list.size() == 0) && catsReferralWithPathwayClock != null && catsReferralWithPathwayClock.getJourney() != null && catsReferralWithPathwayClock.getJourney().getCurrentClock() != null)
		{
			// If none found, perform the extended search to see if a
			// patientElectiveList exists for the current clock for a service
			// that uses the same specialty as this service's specialty.
			String query = "select pEL from PatientElectiveList as pEL left join pEL.pathwayClock as pathClock left join pEL.electiveListStatus as pELStatus left join pELStatus.electiveListStatus as status where pathClock.id = :Clock and status.id not in (" + WaitingListStatus.REMOVED.getID() + ")";

			List<?> extendedList = factory.find(query, new String[] { "Clock" }, new Object[] { catsReferralWithPathwayClock.getJourney().getCurrentClock().getID_PathwayClock() });

			if (extendedList == null || extendedList.size() == 0 || extendedList.get(0) == null)
				return null;

			PatientElectiveListVoCollection coll = new PatientElectiveListVoCollection();
			if (extendedList.get(0) instanceof PatientElectiveList)
			{
				PatientElectiveList electiveList = (PatientElectiveList) extendedList.get(0);
				PatientElectiveListVo electiveListVo = PatientElectiveListVoAssembler.create(electiveList);

				electiveListVo.setCanBeUsed(false);

				if (electiveList.getElectiveList() != null && electiveList.getElectiveList().getService() != null && serviceRef != null)
				{
					if (electiveList.getElectiveList().getService().getId().equals(serviceRef.getID_Service()))
					{
						electiveListVo.setCanBeUsed(true);
					}
					else if (electiveList.getElectiveList().getService().getSpecialty() != null)
					{
						Service service = (Service) factory.getDomainObject(Service.class, serviceRef.getID_Service());

						if (service != null && service.getSpecialty() != null && electiveList.getElectiveList().getService().getSpecialty().getId() == service.getSpecialty().getId())
						{
							electiveListVo.setCanBeUsed(true);
						}
					}
				}

				coll.add(electiveListVo);

				return coll;
			}
		}

		return PatientElectiveListVoAssembler.createPatientElectiveListVoCollectionFromPatientElectiveList(list);
	}

	// WDEV-18396
	public PatientElectiveListVo getPatientElectiveListsOnFormOpen(CatsReferralRefVo catsRef, ServiceRefVo serviceRef, String listIdHcp, Boolean nonDiagnosticELE, CatsReferralForNewElectivListEntryVo catsReferralWithPathwayClock)
	{
		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		StringBuffer hqlConditions = new StringBuffer();
		String andStr = " and ";

		DomainFactory factory = getDomainFactory();
		StringBuffer hql = new StringBuffer("select pEL from PatientElectiveList as pEL left join pEL.electiveList as eL left join eL.service as service left join eL.hCPs as listOwners left join pEL.electiveListStatus as pELStatus left join pELStatus.electiveListStatus as status left join pEL.pathwayClock as pathClock ");

		if (catsRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pEL.referral.id = :CatsID ");
			markers.add("CatsID");
			values.add(catsRef.getID_CatsReferral());
			andStr = " and ";
		}

		if (serviceRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" service.id=:Service ");
			markers.add("Service");
			values.add(serviceRef.getID_Service());
			andStr = " and ";
		}

		if (listIdHcp != null && listIdHcp.length() > 0)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" ( listOwners.hCP.id in " + listIdHcp + " ) ");
			andStr = " and ";
		}

		if (nonDiagnosticELE)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pEL.electiveListReason.id not in (" + ElectiveListReason.DIAGNOSTIC.getID() + " ) ");
			andStr = " and ";
		}

		if (catsReferralWithPathwayClock != null && catsReferralWithPathwayClock.getJourney() != null && catsReferralWithPathwayClock.getJourney().getCurrentClock() != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" pathClock.id = :Clock ");
			markers.add("Clock");
			values.add(catsReferralWithPathwayClock.getJourney().getCurrentClock().getID_PathwayClock());
			andStr = " and ";
		}

		hqlConditions.insert(0, " where ( status.id not in (" + WaitingListStatus.REMOVED.getID() + ")");
		hqlConditions.append(" ) ");

		List<?> list = factory.find(hql.toString() + hqlConditions.toString(), markers, values);
		if (list == null || list.size() == 0)
			return null;
		return PatientElectiveListVoAssembler.create((PatientElectiveList) (list.get(0)));
	}

	// WDEV-18396
	public ElectiveListConfigurationVoCollection getElectiveListConfigurationOnFormOpen(ServiceRefVo serviceRef, LocationRefVo locationRef, String listIdHcp)
	{
		DomainFactory factory = getDomainFactory();

		StringBuffer hqlConditions = new StringBuffer();

		ArrayList<String> markers = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();

		String andStr = "";

		StringBuffer hql = new StringBuffer("select eLC from ElectiveListConfiguration as eLC left join eLC.hCPs as hcps left join hcps.hCP as hcp  left join eLC.listLocations as locations left join locations.listLocation as location ");

		if (serviceRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append(" eLC.service.id=:Service");
			markers.add("Service");
			values.add(serviceRef.getID_Service());
			andStr = " and ";
		}

		if (locationRef != null)
		{
			hqlConditions.append(andStr);
			hqlConditions.append("( location.id=:LocID or locations is null )");
			markers.add("LocID");
			values.add(locationRef.getID_Location());
			andStr = " and ";
		}

		if (listIdHcp != null && listIdHcp.length() > 0)
		{
			hqlConditions.append(andStr);
			hqlConditions.append("  hcp.id in " + listIdHcp + " and hcps.defaultForHCP=1");
			andStr = " and ";
		}

		if (hqlConditions.length() > 0)
		{
			hqlConditions.insert(0, " where (");
			hqlConditions.append(" ) ");
		}

		List<?> list = factory.find(hql.toString() + hqlConditions.toString() + " order by UPPER(eLC.waitingListName) asc ", markers, values);

		return ElectiveListConfigurationVoAssembler.createElectiveListConfigurationVoCollectionFromElectiveListConfiguration(list);
	}

	// WDEV-18656
	public LocationLiteVo getParentHospitalLocation(LocationRefVo wardLoc)
	{
		if (wardLoc == null)
			return null;

		DomainFactory factory = getDomainFactory();

		Location currentHospital = getHospital((Location) factory.getDomainObject(Location.class, wardLoc.getID_Location()));

		if (currentHospital instanceof LocSite)
			return LocationLiteVoAssembler.create((Location) currentHospital);

		return null;
	}

	// WDEV-20064
	private Location getHospital(Location doLocation)
	{
		if (doLocation == null)
			return null;

		if (doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
			return doLocation;

		while (doLocation.getParentLocation() != null)
		{
			doLocation = doLocation.getParentLocation();
			if (doLocation instanceof LocSite && doLocation.getType().equals(getDomLookup(LocationType.HOSP)))
				return doLocation;
		}

		return null;
	}

	public Boolean hasNonDiagnosticPatientElectiveList(CatsReferralRefVo catsReferral)
	{
		if (catsReferral == null || catsReferral.getID_CatsReferral() == null)
			return false;

		DomainFactory factory = getDomainFactory();
		String query = "select count(pel.id) from PatientElectiveList as pel left join pel.electiveListStatus as els left join els.electiveListStatus as status left join pel.referral as cats left join cats.journey as j left join j.currentClock as cc left join pel.pathwayClock as pc where cats.id = :CatsReferral and cc.id = pc.id and status.id not in (" + WaitingListStatus.REMOVED.getID() + ")";

		Object[] count = factory.find(query, new String[] { "CatsReferral" }, new Object[] { catsReferral.getID_CatsReferral() }).toArray();

		if (count != null && count.length > 0)
			return ((Long) count[0]).intValue() > 0;

		return false;
	}

	// WDEV-19479
	public PatientElectiveListVo getPatientElectiveListByRefId(PatientElectiveListRefVo patientElectiveListRefVo)
	{
		if (patientElectiveListRefVo == null || patientElectiveListRefVo.getID_PatientElectiveList() == null)
			return null;

		DomainFactory factory = getDomainFactory();

		PatientElectiveList pELDo = (PatientElectiveList) factory.getDomainObject(PatientElectiveList.class, patientElectiveListRefVo.getID_PatientElectiveList());

		return PatientElectiveListVoAssembler.create(pELDo);
	}

	// WDEV-19445
	public Boolean hasReferralPatientElectiveListTciBreached(CatsReferralRefVo catsRef, PatientElectiveListRefVo patElectiveListRef)
	{
		if (catsRef == null)
			throw new CodingRuntimeException("Cannot retrieve CatsReferral for a null CatsReferralRefVo reference.");
		DomainFactory factory = getDomainFactory();

		ArrayList<String> paramNames = new ArrayList<String>(Arrays.asList(new String[] { "REFERRAL_ID" }));
		ArrayList<Object> paramValues = new ArrayList<Object>(Arrays.asList(new Object[] { catsRef.getID_CatsReferral() }));

		StringBuilder hqlquery = new StringBuilder();

		if (patElectiveListRef != null && patElectiveListRef.getID_PatientElectiveListIsNotNull())
		{
			hqlquery.append("select count(tciHist.id) from PatientElectiveList as pel left join pel.tCIHistory as tciHist where (tciHist.rTTBreachComment is not null or tciHist.rTTBreachReason is not null) and pel.referral.id = :REFERRAL_ID and pel.id = :ELECTIVELIST_ID");
			paramNames.add("ELECTIVELIST_ID");
			paramValues.add(patElectiveListRef.getID_PatientElectiveList());
		}
		else
		{
			return false;
		}

		long countappts = factory.countWithHQL(hqlquery.toString(), paramNames.toArray(new String[paramNames.size()]), paramValues.toArray());

		return countappts > 0;
	}

	// WDEV-20386
	public ProcedureLiteVoCollection listProcedures(String filter)
	{
		StringBuilder queryBuilder = new StringBuilder();
		queryBuilder.append("SELECT procedure FROM Procedure AS procedure ");
		queryBuilder.append("WHERE ");

		ArrayList<String> paramName = new ArrayList<String>();
		ArrayList<Object> paramValue = new ArrayList<Object>();
		String condition = "";

		if (filter != null)
		{
			queryBuilder.append("upper(procedure.procedureName) LIKE :PROCNAME ");
			paramName.add("PROCNAME");
			paramValue.add(filter.toUpperCase() + "%");
			condition = " AND ";
		}

		queryBuilder.append(condition);
		queryBuilder.append(" procedure.isActive = :ACTIVE");
		paramName.add("ACTIVE");
		paramValue.add(Boolean.TRUE);

		List<?> find = getDomainFactory().find(queryBuilder.toString(), paramName, paramValue);

		if (find.size() > 0)
			return ProcedureLiteVoAssembler.createProcedureLiteVoCollectionFromProcedure(find);
		return null;
	}

	// WDEV-20386 ends here

	public PendingEmergencyTheatreVo getPendingEmergencyTheatre(PendingEmergencyTheatreRefVo pendingEmergencyTheatre)
	{
		if (pendingEmergencyTheatre == null || pendingEmergencyTheatre.getID_PendingEmergencyTheatre() == null)
			return null;

		return PendingEmergencyTheatreVoAssembler.create((PendingEmergencyTheatre) getDomainFactory().getDomainObject(PendingEmergencyTheatre.class, pendingEmergencyTheatre.getID_PendingEmergencyTheatre()));
	}

	public LocationLiteVoCollection listHospitals()
	{
		OrganisationAndLocation impl = (OrganisationAndLocation) getDomainImpl(OrganisationAndLocationImpl.class);
		return impl.listActiveHospitalsLite();
	}

	public ReferralERODForBookTheatreVo getEROD(ReferralERODRefVo erod)
	{
		if (erod == null || erod.getID_ReferralEROD() == null)
			return null;

		return ReferralERODForBookTheatreVoAssembler.create((ReferralEROD) getDomainFactory().getDomainObject(ReferralEROD.class, erod.getID_ReferralEROD()));
	}
	
	public SessionTheatreProceduresRemainingVo getSessionTheatreProcedureRemaining(SessionTheatreProceduresRemaniningRefVo sessionTheatreProcedureRemaining)
	{
		if(sessionTheatreProcedureRemaining == null || sessionTheatreProcedureRemaining.getID_SessionTheatreProceduresRemanining() == null)
			return null;
		
		return SessionTheatreProceduresRemainingVoAssembler.create((SessionTheatreProceduresRemanining) getDomainFactory().getDomainObject(SessionTheatreProceduresRemanining.class, sessionTheatreProcedureRemaining.getID_SessionTheatreProceduresRemanining()));
	}	
}
