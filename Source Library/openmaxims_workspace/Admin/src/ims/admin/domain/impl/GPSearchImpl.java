//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Alexie Ursache using IMS Development Environment (version 1.52 build 2505.17727)
// Copyright (C) 1995-2006 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import ims.admin.domain.base.impl.BaseGPSearchImpl;
import ims.admin.vo.GPSearchCriteriaVo;
import ims.configuration.gen.ConfigFlag;
import ims.core.resource.people.domain.objects.Gp;
import ims.core.resource.people.vo.GpRefVo;
import ims.core.vo.GP;
import ims.core.vo.GPLiteWithPracticesVo;
import ims.core.vo.GPLiteWithPracticesVoCollection;
import ims.core.vo.GpLiteToPracticeLiteVo;
import ims.core.vo.GpLiteToPracticeLiteVoCollection;
import ims.core.vo.GpPracticeLiteVo;
import ims.core.vo.LocSiteShortVo;
import ims.core.vo.LocSiteShortVoCollection;
import ims.core.vo.domain.GPAssembler;
import ims.core.vo.domain.GPLiteWithPracticesVoAssembler;
import ims.core.vo.lookups.GPStatus;
import ims.core.vo.lookups.TaxonomyType;
import ims.domain.DomainFactory;
import ims.framework.exceptions.CodingRuntimeException;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class GPSearchImpl extends BaseGPSearchImpl
{
	private static final long serialVersionUID = 1L;

	/**
	* List Gps
	*/
	public GPLiteWithPracticesVoCollection listGps(GPSearchCriteriaVo filter)
	{
		DomainFactory factory = getDomainFactory();
		String andStr = " ";
		StringBuffer clause = new StringBuffer();

		ArrayList<String> names = new ArrayList<String>();
		ArrayList<Object> values = new ArrayList<Object>();
		StringBuffer hql = new StringBuffer();
		// If a code type and code is supplied in the search criteria, we use
		// that first without using the name
		if (filter.getCodeTypeIsNotNull() && filter.getCodeIsNotNull())
		{
			if(filter.getPracticeIsNotNull()) //WDEV-19443
			{
    			//WDEV-18377  - GP Select for Patients changes
    			if (filter.getAreDistinctRecToBeRetrievedIsNotNull() && Boolean.TRUE.equals(filter.getAreDistinctRecToBeRetrieved()))
    			{
    				hql.append("select distinct gp from Gp gp left join gp.codeMappings as mappings left join gp.practices as Pract where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode and Pract.practice.isActive = 1 and Pract.practice.id = :practiceId"); 
    			}
    			else
    			{	
    				hql.append("select gp from Gp gp join gp.codeMappings as mappings left join gp.practices as Pract where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode and Pract.practice.isActive = 1 and Pract.practice.id = :practiceId");
    			}

				names.add("practiceId");
				values.add(filter.getPractice().getID_Organisation());
			}
			else
			{
    			//WDEV-18377  - GP Select for Patients changes
    			if (filter.getAreDistinctRecToBeRetrievedIsNotNull() && Boolean.TRUE.equals(filter.getAreDistinctRecToBeRetrieved()))
    			{
    				hql.append("select distinct gp from Gp gp left join gp.codeMappings as mappings where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode"); 
    			}
    			else
    			{	
    				hql.append("select gp from Gp gp join gp.codeMappings as mappings where mappings.taxonomyName = :taxonomyType and mappings.taxonomyCode = :taxonomyCode");
    			}
			}
			names.add("taxonomyType");
			names.add("taxonomyCode");
			values.add(getDomLookup(filter.getCodeType()));
			values.add(filter.getCode());
			
			if (filter.getStatusIsNotNull())
			{
				hql.append(" and gp.status.id = :statusId");
				names.add("statusId");
				values.add(filter.getStatus().getID());
			}
			else	//wdev-9930
			{
				hql.append(" and gp.status.id <> :statusId");
				names.add("statusId");
				values.add(GPStatus.INACTIVE.getID());

			}
			
			List<?> gps = factory.find(hql.toString(), names, values);
			return GPLiteWithPracticesVoAssembler.createGPLiteWithPracticesVoCollectionFromGp(gps).sort();
		}
		
		StringBuilder mainHql = new StringBuilder();
		
		//WDEV-3053 - this line was omitted so the hql "Pract" was unknown
		//WDEV-18377  - GP Select for Patients changes
		if (filter.getAreDistinctRecToBeRetrievedIsNotNull() && Boolean.TRUE.equals(filter.getAreDistinctRecToBeRetrieved()))
		{
			mainHql.append("select distinct gp from Gp gp"); 
		}
		else
		{
			mainHql.append("select gp from Gp gp");
		}	
		
		//WDEV-15431
		String ret = "";
		if(filter != null &&  filter.getForenameIsNotNull())
			ret = filter.getForename().replaceAll("%", "");
		
		if (filter.getForenameIsNotNull()&& ret.length()!=0)//WDEV-15431
		{
			clause.append(" gp.name.upperForename like :forename");
			names.add("forename");
			String formatedForename = filter.getForename().replaceAll("[^a-zA-Z]+", "");
			values.add(formatedForename.toUpperCase() + "%");//WDEV-15431
			andStr = " and ";
		}

		if (filter.getSurnameIsNotNull())
		{
			clause.append(andStr + " gp.name.upperSurname like :surname");
			names.add("surname");
			String formatedSurname = filter.getSurname().replaceAll("[^a-zA-Z]+", "");	
			values.add(formatedSurname.toUpperCase() + "%");
			andStr = " and ";
		}
		
		if (filter.getStatusIsNotNull())
		{
			clause.append(andStr + " gp.status.id = :statusId");
			names.add("statusId");
			values.add(filter.getStatus().getID());
			andStr = " and ";
		}

		if (filter.getAddressContainsIsNotNull() && filter.getAddressContains().trim().length() > 0)
		{
			//WDEV-18377 
			mainHql.append (" left join gp.practices as Pract ");
					
			if (ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
			{
				mainHql.append ("left join Pract.practice as pract left join pract.locationSites as surgeries");
				
				clause.append(andStr + " gp.id = Pract.gp.id and Pract.practice.isActive = 1 and (surgeries.isActive = 1 and (surgeries.upperName like :partialAddress ");  //WDEV-18828  WDEV-20219
				clause.append(" or (upper(surgeries.address.line1) like :partialAddress ");
				clause.append(" or upper(surgeries.address.line2) like :partialAddress");
				clause.append(" or upper(surgeries.address.line3) like :partialAddress");
				clause.append(" or upper(surgeries.address.line4) like :partialAddress");
				clause.append(" or upper(surgeries.address.line5) like :partialAddress");
				clause.append(" or upper(REPLACE(surgeries.address.postCode,' ','')) = :partialAddressAsPCode )))");
				andStr = " and ";
			}
			else
			{	
				clause.append(andStr + " gp.id = Pract.gp.id and (Pract.practice.isActive = 1 and (Pract.practice.upperName like :partialAddress "); //WDEV-20219(upper(Pract.practice.name) //WDEV-18828
				clause.append(" or (upper(Pract.practice.address.line1) like :partialAddress ");
				clause.append(" or upper(Pract.practice.address.line2) like :partialAddress");
				clause.append(" or upper(Pract.practice.address.line3) like :partialAddress");
				clause.append(" or upper(Pract.practice.address.line4) like :partialAddress");
				clause.append(" or upper(Pract.practice.address.line5) like :partialAddress");
				clause.append(" or upper(REPLACE(Pract.practice.address.postCode,' ','')) = :partialAddressAsPCode )))");
				andStr = " and ";
			}
			
			names.add("partialAddress");
			values.add("%" + filter.getAddressContains().toUpperCase() + "%");
						
			names.add("partialAddressAsPCode");
			values.add(filter.getAddressContains().trim().replaceAll(" ","").toUpperCase());
			andStr = " and ";

			//WDEV-19443
			if(filter.getPracticeIsNotNull()) //WDEV-19443
			{
    			clause.append(andStr + " Pract.practice.isActive = 1 and Pract.practice.id = :practiceId "); 
    			names.add("practiceId");
    			values.add(filter.getPractice().getID_Organisation());
    			andStr = " and ";
			}
		}
		else if(filter.getPracticeIsNotNull()) //WDEV-19443
		{
			mainHql.append (" left join gp.practices as Pract ");
			
			clause.append(andStr + " Pract.practice.isActive = 1 and Pract.practice.id = :practiceId "); 
			names.add("practiceId");
			values.add(filter.getPractice().getID_Organisation());
			andStr = " and ";
		}

		if (clause != null && clause.length() > 0)
		{	
			mainHql.append (" where ");
		}
		
		mainHql.append(clause.toString());
		List<?> gps = factory.find(mainHql.toString(), names, values);
		
		GPLiteWithPracticesVoCollection gpWithPractColl = GPLiteWithPracticesVoAssembler.createGPLiteWithPracticesVoCollectionFromGp(gps);
		
		if (gpWithPractColl != null && gpWithPractColl.size() > 0 && filter.getAddressContainsIsNotNull() && filter.getAddressContains().trim().length() > 0)
		{
			gpWithPractColl = getFilteredPracticesAndSurgeriesforAddress(filter, gpWithPractColl);
			
			if (ConfigFlag.DOM.GP_USE_SURGERIES.getValue() && ConfigFlag.HL7.HEARTS_GP_MODEL.getValue()) //WDEV-18828
			{
				gpWithPractColl = filterGpsForGMCNumberAndPasCode(gpWithPractColl);
			}
		}
		
		return gpWithPractColl.sort();
	}
	//WDEV-18377
	private GPLiteWithPracticesVoCollection getFilteredPracticesAndSurgeriesforAddress(GPSearchCriteriaVo filter,GPLiteWithPracticesVoCollection gpWithPractColl) //WDEV-18377
	{		
		for (int i=gpWithPractColl.size()-1; i>=0;i--)
		{
			if (gpWithPractColl.get(i) == null || gpWithPractColl.get(i).getPractices() == null)
				continue;
			if (!ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
			{
				filterPracticesForAddress(filter, gpWithPractColl.get(i));
			}
			else
			{
				for (int x=gpWithPractColl.get(i).getPractices().size()-1; x>=0;x--)
				{
					if (gpWithPractColl.get(i).getPractices().get(x) ==null || gpWithPractColl.get(i).getPractices().get(x).getPractice() == null)
						continue;
					filterSurgeriesForAddress(filter,gpWithPractColl.get(i).getPractices().get(x).getPractice());

				}
				Iterator<GpLiteToPracticeLiteVo> iteratorForPractices = gpWithPractColl.get(i).getPractices().iterator();
				while (iteratorForPractices.hasNext())
				{	
					if (iteratorForPractices.next().getPractice().getSurgeries().size() == 0)
					{
						iteratorForPractices.remove();
					}
				}

			}
		}

		Iterator<GPLiteWithPracticesVo> iteratorForGP = gpWithPractColl.iterator();
		while (iteratorForGP.hasNext())
		{
			if (iteratorForGP.next().getPractices().size() == 0)
			{
				iteratorForGP.remove();
			}
		}

		return gpWithPractColl;
	}
	private void filterPracticesForAddress(GPSearchCriteriaVo filter,GPLiteWithPracticesVo gpWithPractices) //WDEV-18377 
	{
		if (gpWithPractices ==null || gpWithPractices.getPractices() == null)
			return;

		if (!ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
		{
			for (int k=gpWithPractices.getPractices().size()-1;k>=0;k--)
			{
				if (gpWithPractices.getPractices().get(k) ==null || gpWithPractices.getPractices().get(k).getPractice() == null)
					continue;

				if (!isPracticeValidforAddress(filter, gpWithPractices.getPractices().get(k).getPractice()))
				{
					gpWithPractices.getPractices().remove(k);
				}

			}	
		}	
	}
	//WDEV-18828
	private GPLiteWithPracticesVoCollection filterGpsForGMCNumberAndPasCode(GPLiteWithPracticesVoCollection gpColl)
	{
		if (gpColl == null || gpColl.size() == 0)
			return null;
		String gMCCode = null;
		GPLiteWithPracticesVoCollection filteredGps = new GPLiteWithPracticesVoCollection();

		for (int i=0;i<gpColl.size();i++)
		{	
			GPLiteWithPracticesVo voGpWithPractice = gpColl.get(i);

			if (voGpWithPractice != null)
			{
				if(voGpWithPractice.getCodeMappingsIsNotNull())
				{
					gMCCode = voGpWithPractice.getCodeMappings().getMappingValue(TaxonomyType.NAT_GP_CODE);
				}
				GpLiteToPracticeLiteVoCollection voPractices = voGpWithPractice.getPractices();
				for (int j=0;j<voPractices.size();j++)
				{
					GpLiteToPracticeLiteVo practiceWithSurg = voPractices.get(j);
					if (practiceWithSurg != null && practiceWithSurg.getPracticeIsNotNull() && practiceWithSurg.getPractice().getSurgeries() != null && practiceWithSurg.getPractice().getSurgeries().size() > 0)
					{	

						LocSiteShortVoCollection heartsSurgeries = getHeartsSurgery(practiceWithSurg.getPractice().getSurgeries(), gMCCode);
						if (heartsSurgeries != null && heartsSurgeries.size() > 0)
							filteredGps.add(voGpWithPractice);
					}
				}
			}
		}
		return filteredGps;
		
	}
	private LocSiteShortVoCollection getHeartsSurgery(LocSiteShortVoCollection surgeries, String gMCCode)
	{
		if (ConfigFlag.HL7.HEARTS_GP_MODEL.getValue()&& surgeries != null)
		{
			LocSiteShortVoCollection surgeriesForGp = new LocSiteShortVoCollection();
			for (LocSiteShortVo surgery : surgeries)
			{
				if(surgery.getIsActiveIsNotNull() && 
						surgery.getIsActive().equals(Boolean.TRUE)&&
						surgery.getPasCode()!=null&&
						gMCCode!=null&&
						gMCCode.trim()!=null&&
						surgery.getPasCode().toUpperCase().matches("\\S+_"+gMCCode.trim().toUpperCase()+"_\\S+")) //http://jira/browse/WDEV-15535 changed filter from PAS to GMC 
				{
					surgeriesForGp.add(surgery);
				}
			}
			return surgeriesForGp;
		}
		return null;
		
	}
	private void filterSurgeriesForAddress(GPSearchCriteriaVo filter, GpPracticeLiteVo practWithSurg) //WDEV-18377
	{
		if (practWithSurg.getSurgeriesIsNotNull() && practWithSurg.getSurgeries().size() >0 && ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
		{	
			for (int j=practWithSurg.getSurgeries().size()-1; j>=0;j--)
			{	
				if (practWithSurg.getSurgeries().get(j) == null)
					continue;
				if (!isSurgeryValidforAddress(filter, practWithSurg.getSurgeries().get(j)))
				{
					practWithSurg.getSurgeries().remove(j);
				}

			}
		}
	}
	/*private void filterPracticesForAddress(GPSearchCriteriaVo filter,GPLiteWithPracticesVo gpWithPractices)
	{
		if (gpWithPractices ==null || gpWithPractices.getPractices() == null)
			return;
		Iterator<GpLiteToPracticeLiteVo> it = gpWithPractices.getPractices().iterator();
		if (!ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
		{
			while (it.hasNext())
			{	
				if (it ==null || ((GpLiteToPracticeLiteVo)it).getPractice() == null)
					continue;

				if (!isPracticeValidforAddress(filter, ((GpLiteToPracticeLiteVo)it.next()).getPractice()))
				{
					it.remove();
				}

			}				
		}	
	}
	private void filterSurgeriesForAddress(GPSearchCriteriaVo filter, GpPracticeLiteVo practWithSurg)
	{
		if (practWithSurg.getSurgeriesIsNotNull() && practWithSurg.getSurgeries().r.size() >0 && ConfigFlag.DOM.GP_USE_SURGERIES.getValue())
		{	
			Iterator itSrg = practWithSurg.getSurgeries().iterator();
			while (itSrg.hasNext())
			{	
				if (!isSurgeryValidforAddress(filter,(LocSiteShortVo)itSrg.next()))
				{
					itSrg.remove();
				}
			}
		}
	}*/
	//WDEV-18377
	private boolean isSurgeryValidforAddress(GPSearchCriteriaVo filter, LocSiteShortVo surgery)
	{
		if (surgery != null && filter.getAddressContains() != null && filter.getAddressContains().length() > 0)
		{			
			if (surgery.getIsActiveIsNotNull() && Boolean.TRUE.equals(surgery.getIsActive()) && ((surgery.getNameIsNotNull() && surgery.getName().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || //WDEV-18828 
							(surgery.getAddressIsNotNull() &&
							(surgery.getAddress().getLine1IsNotNull() && surgery.getAddress().getLine1().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase()) ||
							(surgery.getAddress().getLine2IsNotNull()&& surgery.getAddress().getLine2().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) ||
							(surgery.getAddress().getLine3IsNotNull()&& surgery.getAddress().getLine3().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || 
							(surgery.getAddress().getLine4IsNotNull() && surgery.getAddress().getLine4().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) ||
							(surgery.getAddress().getLine5IsNotNull() && surgery.getAddress().getLine5().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) ||
							(surgery.getAddress().getPostCodeIsNotNull() && surgery.getAddress().getPostCode().replace(" ", "").toUpperCase().equals(filter.getAddressContains().replaceAll("%", "").replace(" ", "").toUpperCase()))))))
			{
				return true;
			}
		}
		return false;
	}
	//WDEV-18377
	private boolean isPracticeValidforAddress(GPSearchCriteriaVo filter, GpPracticeLiteVo practice)
	{
		if (practice != null && filter.getAddressContains() != null && filter.getAddressContains().length() > 0)
		{
			if (practice.getIsActiveIsNotNull() && Boolean.TRUE.equals(practice.getIsActive()) && ((practice.getNameIsNotNull() && practice.getName().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || //WDEV-18828
							(practice.getAddressIsNotNull() && 
							(practice.getAddress().getLine1IsNotNull() && practice.getAddress().getLine1().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase()) ||
							(practice.getAddress().getLine2IsNotNull()&& practice.getAddress().getLine2().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || 
							(practice.getAddress().getLine3IsNotNull()&& practice.getAddress().getLine3().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || 
							(practice.getAddress().getLine4IsNotNull() && practice.getAddress().getLine4().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) || 
							(practice.getAddress().getLine5IsNotNull() && practice.getAddress().getLine5().toUpperCase().contains(filter.getAddressContains().replaceAll("%", "").toUpperCase())) ||
							(practice.getAddress().getPostCodeIsNotNull() && practice.getAddress().getPostCode().replace(" ", "").toUpperCase().equals(filter.getAddressContains().replaceAll("%", "").replace(" ", "").toUpperCase()))))))
			{
				return true;
			}
		}
		return false;


	}
	public GPLiteWithPracticesVo getGpLite(GpRefVo gpRefVo)
	{
		if(gpRefVo == null)
			throw new CodingRuntimeException("Cannot get GpLiteVo for null GpRefVo");
		
		Gp doGp = (Gp)getDomainFactory().getDomainObject(Gp.class, gpRefVo.getID_Gp());
		
		return GPLiteWithPracticesVoAssembler.create(doGp);
	}

	public GP getGpFull(GpRefVo gpRefVo)
	{
		if(gpRefVo == null)
			throw new CodingRuntimeException("Cannot get GP for null GpRefVo");
		Gp doGp = (Gp)getDomainFactory().getDomainObject(Gp.class, gpRefVo.getID_Gp());
		
		return GPAssembler.create(doGp); 		
	}
}
