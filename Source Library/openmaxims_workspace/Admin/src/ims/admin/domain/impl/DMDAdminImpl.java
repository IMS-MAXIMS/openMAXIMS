//#############################################################################
//#                                                                           #
//#  Copyright (C) <2015>  <IMS MAXIMS>                                       #
//#                                                                           #
//#  This program is free software: you can redistribute it and/or modify     #
//#  it under the terms of the GNU Affero General Public License as           #
//#  published by the Free Software Foundation, either version 3 of the       #
//#  License, or (at your option) any later version.                          # 
//#                                                                           #
//#  This program is distributed in the hope that it will be useful,          #
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of           #
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
//#  GNU Affero General Public License for more details.                      #
//#                                                                           #
//#  You should have received a copy of the GNU Affero General Public License #
//#  along with this program.  If not, see <http://www.gnu.org/licenses/>.    #
//#                                                                           #
//#  IMS MAXIMS provides absolutely NO GUARANTEE OF THE CLINICAL SAFTEY of    #
//#  this program.  Users of this software do so entirely at their own risk.  #
//#  IMS MAXIMS only ensures the Clinical Safety of unaltered run-time        #
//#  software that it builds, deploys and maintains.                          #
//#                                                                           #
//#############################################################################
//#EOH
// This code was generated by Sean Nesbitt using IMS Development Environment (version 1.65 build 3223.30681)
// Copyright (C) 1995-2008 IMS MAXIMS plc. All rights reserved.

package ims.admin.domain.impl;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import ims.admin.domain.DMD;
import ims.admin.domain.base.impl.BaseDMDAdminImpl;
import ims.domain.DomainFactory;
import ims.domain.exceptions.DomainInterfaceException;
import ims.domain.exceptions.DomainRuntimeException;
import ims.domain.exceptions.StaleObjectException;
import ims.domain.exceptions.UniqueKeyViolationException;
import ims.domain.exceptions.UnqViolationUncheckedException;

import ims.clinical.configuration.domain.objects.AMP;
import ims.clinical.configuration.domain.objects.VMP;
import ims.clinical.configuration.domain.objects.VTM;
import ims.clinical.configuration.vo.VTMRefVo;
import ims.clinical.vo.AMPVo;
import ims.clinical.vo.AMPVoCollection;
import ims.clinical.vo.VMPVo;
import ims.clinical.vo.VMPVoCollection;
import ims.clinical.vo.VTMVo;
import ims.clinical.vo.VTMVoCollection;
import ims.clinical.vo.domain.AMPVoAssembler;
import ims.clinical.vo.domain.VMPVoAssembler;
import ims.clinical.vo.domain.VTMVoAssembler;
import ims.configuration.gen.ConfigFlag;
import ims.configuration.EnvironmentConfig;
import ims.core.vo.lookups.Specialty;


public class DMDAdminImpl extends BaseDMDAdminImpl
{
	private static File vtmLogFile,vmpLogFile,ampLogFile;
	private static FileWriter vtmlogout,vmplogout,amplogout;
	
	private static final long serialVersionUID = 1L;

	/**
	* save a VTM
	 * @throws StaleObjectException 
	*/
	public void saveVTM(ims.clinical.vo.VTMVo vtmVo) throws ims.domain.exceptions.DomainInterfaceException, ims.domain.exceptions.UniqueKeyViolationException, StaleObjectException
	{
		if (!vtmVo.isValidated())
		{
			throw new DomainRuntimeException("VTM VO has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
				
		//try get existing record by Moiety Identifier
		if (vtmVo.getMoietyIdentifierIsNotNull())
		{
			VTMVo vo = getVTM(vtmVo.getMoietyIdentifier());
			if (vo != null && vo.getID_VTMIsNotNull())
			{
				//Update
				vo.setName(vtmVo.getName());
				vo.setInvalid(vtmVo.getInvalid());
				vo.setAbbreviatedName(vtmVo.getAbbreviatedName());
				VTM domVTM = VTMVoAssembler.extractVTM(factory, vo);

				if (vtmlogout != null)
				{
					try {
						vtmlogout.write("Update VTM," + vtmVo.getMoietyIdentifier() + "," + vo.getMoietyIdentifier() + "," + vtmVo.getName() + "," + vo.getName() + "\r\n");
					} catch (IOException e) {
						throw new DomainInterfaceException(e.getMessage());
					}
				}
				
				factory.update(domVTM);
			}
			else
			{
				//Insert
				VTM domVTM = VTMVoAssembler.extractVTM(factory, vtmVo);
				try
				{
					factory.save(domVTM);
				}
				catch (UnqViolationUncheckedException e)
				{
					throw new ims.domain.exceptions.UniqueKeyViolationException(e);
				}
			}
		}				
	}
	
	public void saveVMP(VMPVo vmpVo) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		if (!vmpVo.isValidated())
		{
			throw new DomainRuntimeException("VMP VO has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		
		//try get existing record by Product Identifier
		if (vmpVo.getProductIdentifierIsNotNull())
		{
			VMPVo vo = getVMP(vmpVo.getProductIdentifier());
			if (vo != null && vo.getID_VMPIsNotNull())
			{
				vo.setName(vmpVo.getName());
				vo.setAbbreviatedName(vmpVo.getAbbreviatedName());
				vo.setInvalid(vmpVo.getInvalid());			
				vo.setVTM(vmpVo.getVTM());
				VMP domVMP = VMPVoAssembler.extractVMP(factory, vo);

				if (vmplogout != null)
				{
					try {
						vmplogout.write("Update VMP," + vmpVo.getProductIdentifier() + "," + vo.getProductIdentifier() + "," + vmpVo.getName() + "," + vo.getName() + "\r\n");
					} catch (IOException e) {
						throw new DomainInterfaceException(e.getMessage());
					}
				}
				
				factory.update(domVMP);
			}
			else
			{
				//Insert				
				VMP domVMP = VMPVoAssembler.extractVMP(factory, vmpVo);
				
				//get corresponding VTM by optional
				VTM vtm = null;
				if (domVMP.getVTM() != null)
				{
					ims.clinical.vo.VTMVoCollection vtmCol = VTMVoAssembler.createVTMVoCollectionFromVTM(factory.find("from VTM vt WHERE vt.moietyIdentifier = '" + domVMP.getVTM().getMoietyIdentifier() + "'"));
					if (vtmCol != null && vtmCol.size()>0)			
						vtm = VTMVoAssembler.extractVTM(factory, vtmCol.get(0));
					domVMP.setVTM(vtm);
				}
				
				try
				{
					factory.save(domVMP);
				}
				catch (UnqViolationUncheckedException e)
				{
					throw new ims.domain.exceptions.UniqueKeyViolationException(e);
				}				
				
			}
		}		
	}

	public void saveAMP(AMPVo ampVo) throws DomainInterfaceException, StaleObjectException, UniqueKeyViolationException 
	{
		if (!ampVo.isValidated())
		{
			throw new DomainRuntimeException("AMP VO has not been validated.");
		}
		
		DomainFactory factory = getDomainFactory();
		
		//setup log file
		
		//try to get existing record by 
		if (ampVo.getProductIdentifierIsNotNull())
		{
			AMPVo vo = getAMP(ampVo.getProductIdentifier());
			if (vo != null && vo.getID_AMPIsNotNull())
			{
				//Update
				vo.setName(ampVo.getName());
				vo.setAbbreviatedName(ampVo.getAbbreviatedName());
				vo.setInvalid(ampVo.getInvalid());				
				AMP domAMP = AMPVoAssembler.extractAMP(factory, vo);
				
				if (amplogout != null)
				{
					try {
						amplogout.write("Update AMP : " + ampVo.getProductIdentifier() + "," + vo.getProductIdentifier() + "," + ampVo.getName() + "," + vo.getName() + "\r\n");
					} catch (IOException e) {
						throw new DomainInterfaceException(e.getMessage());
					}
				}
				
				factory.update(domAMP);				
			}
			else
			{
				//Insert								
				AMP domAMP = AMPVoAssembler.extractAMP(factory, ampVo);
				
				try
				{
					factory.save(domAMP);
				}
				catch (UnqViolationUncheckedException e)
				{
					throw new ims.domain.exceptions.UniqueKeyViolationException(e);
				}
			}
		}
	}

	public VMPVo getVMP(String vmpId) throws DomainInterfaceException
	{
		if(vmpId == null)
			throw new DomainInterfaceException("Invalid VMP reference");
		
		VMPVoCollection vmpCol = VMPVoAssembler.createVMPVoCollectionFromVMP(getDomainFactory().find("from VMP vm WHERE vm.productIdentifier = '" + vmpId + "'"));
		if (vmpCol != null && vmpCol.size()>0)
			return vmpCol.get(0);
		else
			return null;
	}

	public VTMVo getVTM(String vtmId) throws DomainInterfaceException 
	{
		if(vtmId == null)
			throw new DomainInterfaceException("Invalid VTM reference");
		
		VTMVoCollection vtmCol = VTMVoAssembler.createVTMVoCollectionFromVTM(getDomainFactory().find("from VTM vtm WHERE vtm.moietyIdentifier = '" + vtmId + "'"));
		if (vtmCol != null && vtmCol.size() > 0)
			return vtmCol.get(0);
		else
			return null;
	}

	public AMPVo getAMP(String ampProductId) throws DomainInterfaceException 
	{
		if(ampProductId == null)
			throw new DomainInterfaceException("Invalid AMP reference");
		
		AMPVoCollection ampCol = AMPVoAssembler.createAMPVoCollectionFromAMP(getDomainFactory().find("from AMP amp WHERE amp.productIdentifier = '" + ampProductId + "'"));
		if (ampCol != null && ampCol.size() > 0)
			return ampCol.get(0);
		else
			return null;
	}

	public void closeLogFiles() 
	{
		try {
			if (vtmlogout != null)
			{
				vtmlogout.flush();
				vtmlogout.close();
			}
			if (vmplogout != null)
			{
				vmplogout.flush();
				vmplogout.close();
			}
			if (amplogout != null)
			{
				amplogout.flush();
				amplogout.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}

	public void openLogFiles() 
	{
		//setup log file
		if (vtmlogout == null)
		{
			try {
				String tempDir = EnvironmentConfig.getBaseUri() + ConfigFlag.GEN.FILE_UPLOAD_DIR.getValue() + "/log";
				File flDir = new File(tempDir);
				if (!flDir.exists())
					flDir.mkdirs();
				vtmLogFile = new File(tempDir + "/vtmUpdateload.log");
				if (!vtmLogFile.exists())
					vtmLogFile.createNewFile();
				vtmlogout = new FileWriter(vtmLogFile);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		//setup log file
		if (vmplogout == null)
		{
			try {
				String tempDir = EnvironmentConfig.getBaseUri() + ConfigFlag.GEN.FILE_UPLOAD_DIR.getValue() + "/log";
				File flDir = new File(tempDir);
				if (!flDir.exists())
					flDir.mkdirs();
				vmpLogFile = new File(tempDir + "/vmpUpdateLoad.log");
				if (!vmpLogFile.exists())
					vmpLogFile.createNewFile();
				vmplogout = new FileWriter(vmpLogFile);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		if (amplogout == null)
		{
			try {
				String tempDir = EnvironmentConfig.getBaseUri() + ConfigFlag.GEN.FILE_UPLOAD_DIR.getValue() + "/log";
				File flDir = new File(tempDir);
				if (!flDir.exists())
					flDir.mkdirs();
				ampLogFile = new File(tempDir + "/ampUpdateLoad.log");
				if (!ampLogFile.exists())
					ampLogFile.createNewFile();
				amplogout = new FileWriter(ampLogFile);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}


	}

	public void addToHotlist(Specialty specialty, VTMVo vtm) throws StaleObjectException 
	{
		DMD impl = (DMD)getDomainImpl(DMDImpl.class);
		impl.addToHotlist(specialty, vtm);
	}
	public VTMVoCollection listVTMHotlist(Specialty specialty) throws DomainInterfaceException 
	{
		if(specialty == null)
			throw new DomainInterfaceException("Invalid specialty");
		
		DomainFactory domainFactory = getDomainFactory();
		
		String hql = "select hli.vTM from VTMHotlist as hl join hl.hotListItem as hli left join hli.vTM as vtm where (hl.specialty.id = " + specialty.getID() + ")";
		return VTMVoAssembler.createVTMVoCollectionFromVTM(domainFactory.find(hql));
	}
	public void removeFromHotlist(Specialty specialty, VTMRefVo vtm) throws StaleObjectException 
	{
		DMD impl = (DMD)getDomainImpl(DMDImpl.class);
		impl.removeFromHotlist(specialty, vtm);
	}

	public void addToHotlist(Specialty specialty, VTMVoCollection vtm) throws StaleObjectException
	{
		for(int x = 0; x < vtm.size(); x++)
		{
			addToHotlist(specialty, vtm.get(x));
		}
	}
}
